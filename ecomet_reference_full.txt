# eCOMET Documentation Knowledge Base
# Auto-generated from https://phytoecia.github.io/eCOMET
# Last updated: 2026-01-28T01:25:25.496290


============================================================
## eCOMET

Source: https://phytoecia.github.io/eCOMET/index.html
============================================================

eCOMET
The eCOMET package provides tools for processing and analyzing mass spectrometry–based metabolomics data in ecological and evolutionary contexts. It establishes a standardized pipeline that integrates MS1 feature–abundance tables with MS2 spectral similarity to generate common data products, including principal component analyses (PCA), chemical dendrograms where tips represent compounds, principal coordinates analyses (PCoA), and differential expression analyses. Unlike existing metabolomics toolkits that focus primarily on biomedical or cheminformatics applications, ecomet is designed explicitly for ecometabolomics. It emphasizes workflows that link metabolomic variation to ecological data, making it easier to move from raw mass spectrometry files to reproducible, comparative analyses of plant chemical diversity.
Find more details at
our webpage
.
The major toolboxes of eCOMET are as follows:
Installation
You can install the development version of ecomet from
GitHub
with:
# install.packages("pak")
pak
::
pak
(
"phytoecia/eCOMET"
)
This is a basic example which shows you how to solve a common problem:
library
(
ecomet
)
## basic example code
0. Input files requirements
Following input files are required to run eCOMET. See ‘/raw_data’ of demo files. 1. Feature quantification table generated by MZMine4 (
features.csv
) -This file is generated by [Feature list methods → Export feature list → CSV]. See
https://mzmine.github.io/mzmine_documentation/module_docs/io/feat-list-export.html
2. Annotation of features by SIRIUS (
canopus_formula_summary.tsv
and
structure_identification.tsv
) -These are included in the standard output of SIRIUS. Make sure you run all SIRIUS → ZODIAC → CSI:FingerID → CANOPUS. Then export as tsv. 3. Metadata of samples (
metadata.csv
) -Metadata should have three or more columns; the first three being sample, group, and mass. Additional information can be provided (see Part 9. Regression with metadata). 4. (Optional) Custom annotation of features (‘custom_DB_glucosinolates.csv’) -The custom DB includes three columns: compound, mz, rt 5. (Optional) Chemical similarity table from MZMine 4. The metric can be cosine, DreaMS, and MS2DeepScore (cosine.csv, dreams.csv, and ms2deepscore.csv) -To obtain these data, you need to run molecular networking at MZMine4 for each metric. See
https://mzmine.github.io/mzmine_documentation/module_docs/group_spectral_net/molecular_networking.html
-Set the minimal similarity value as 0 to get all pairwise similarity. -These tables are impoted and processed for heatmap visualization and chemical diversity quantification (see 10. Chemical Diversity Measures)
1. Initializing the MMO object
All input files are imported to construct a
mmo
object. The
mmo
object will be used in downstream statistics.
###
# 1.1. Give directories
mzmine_featuredir
<-
'raw_data/250724_features_ms2.csv'
metadatadir
<-
"raw_data/250728_mmo_metadata.csv"
canopus_formuladir
<-
"raw_data/canopus_formula_summary.tsv"
canopus_structuredir
<-
"raw_data/structure_identifications.tsv"
gls_db
<-
'raw_data/250428_GLS_Ath_simplegrad_MMO.csv'
cos_dir
<-
'raw_data/250728_sim_ms2_(modified)_cosine.csv'
dreams_dir
<-
'raw_data/250728_sim_dreams.csv'
m2ds_dir
<-
'raw_data/250728_sim_ms2deepscore.csv'
First import the mzmine feature list and metadata to create a
mmo
object.
mmo <- GetMZmineFeature(mzmine_featuredir, metadatadir) head(mmo$featre_data)
then add annotation generated from sirius to the object
mmo <- AddSiriusAnnot(mmo, canopus_structuredir, canopus_formuladir) head(mmo$sirius_annot)
Custom annotation can be added based on m/z and RT.
mmo <- AddCustomAnnot(mmo, DB = gls_db, mztol = 5, rttol = 0.1) # Add annotation
then process the quantification data
# Normalize data
mmo
<-
ReplaceZero
(mmo,
method =
'one'
)
# Replace 0 and NA values by 1
mmo
<-
MassNormalization
(mmo)
# Normalize peak area by sample mass in metadata
mmo
<-
MeancenterNormalization
(mmo)
# Add mean-centered area
mmo
<-
LogNormalization
(mmo)
# Add log-transformed area
mmo
<-
ZNormalization
(mmo)
# Add Zscore
The chemical similarity tables are imported then transformed into distance matrix
# Import chemical distance data for chemical diversity analyses mmo <- AddChemDist(mmo, cos_dir = cos_dir, dreams_dir = dreams_dir, m2ds_dir = m2ds_dir)
Check every data are imported well
summary(mmo)
mmo object
The
mmo
object contains following information 1) Feature quantification value (
f
e
a
t
u
r
e
d
a
t
a
)
2
)
M
e
t
a
d
a
t
a
(
feature_data)
2) Metadata (
metadata) 3) Pairwise comparison data (
p
a
i
r
w
i
s
e
)
4
)
L
o
g
,
m
e
a
n
−
c
e
n
t
e
r
e
d
,
a
n
d
Z
−
t
r
a
n
s
f
o
r
m
e
d
f
e
a
t
u
r
e
q
u
a
n
t
i
f
i
c
a
t
i
o
n
v
a
l
u
e
(
pairwise)
4) Log, mean-centered, and Z-transformed feature quantification value (
log,
$meancentered, and #zscore)
5) Sirius annotation ($
sirius_annot) 6) cosine distance (
c
o
s
.
d
i
s
s
i
m
)
7
)
D
r
e
a
M
S
d
i
s
t
a
n
c
e
(
cos.dissim)
7) DreaMS distance (
dreams.dissim) 8) MS2DeepScore distance (m2ds.dissim)
All features have id (from mzmine) and feature (mz_rt generated by GetMZmineFeature()). Both can be interchangable by FeatureToID(mmo, features) and IDToFeature(mmo, IDs).
Annotated features by SIRIUS
Some feature groups may deserve particular interest. For the demo file, glucosinolates and flavonoids are. We can briefly annotate those metabolites using annotation from sirius.
features
<-
mmo
$
sirius_annot
# Get list of glucosinolated using custom annoatation DB
gls_hits
<-
mmo
$
custom_annot
%>%
filter
(
lengths
(custom_annot)
>
0
)
GLSs
<-
gls_hits
%>%
pull
(feature)
# Get list of flavonoids using sirius annotation
FLVs
<-
features
%>%
filter
(
str_detect
(features[[
46
]],
"Flavonoid"
))
%>%
pull
(feature)
2. Summarise using PLS-DA
By using PLS-DA plot, the general distribution of metabolic profile of each sample and group can be visualized. For each group give colors
# Define your custom colors for each group
custom_colors
<-
c
(
"ctrl"
=
"#999999"
,
"sl1"
=
"#fdcdac"
,
"le1"
=
"#b3e2cd"
)
#Or automatically give colors
custom_colors
<-
setNames
(
brewer.pal
(
length
(
unique
(mmo
$
metadata
$
group)),
"Set3"
),
unique
(mmo
$
metadata
$
group))
Then plot PLS-DA
PLSDAplot
(mmo,
color =
custom_colors,
outdir =
'plots/plsda/PLSDA_Z.pdf'
,
normalization =
'Z'
)
PLSDAplot
(mmo,
color =
custom_colors,
topk =
0
,
outdir =
'plots/plsda/PLSDA_Z_noLoadings.pdf'
,
normalization =
'Z'
)
The
topk
parameter can be adjusted to plot loadings of top features on the plot. The
normalization
can be
None
,
Log
,
Meancentered
, and
Z
. If a subset of features are to be used for ploting, set
filter_feature = TRUE
then provide the list of features to the
feature_list
If a subset of groups are to be plotted, set ‘filter_group = TRUE’ then provide the list of groups to the group_list.
# Glucosinolates only
PLSDAplot
(mmo, custom_colors,
topk =
0
,
outdir =
'plots/plsda_GLS.pdf'
,
normalization =
'Z'
,
filter_feature =
TRUE
,
feature_list =
GLSs)
3. Pairwise Comparison (DAMs)
Many analyses targets to find
Differentially Accumulated Metabolites (DAMs)
. DAMs can be defined by thresholds of log2-fold change and adjusted p-value. Those two metrics are calculated by following code. Note that the divisor group is at the left.
# 3.1. Add pairwise comparisons mmo <- PairwiseComp(mmo, 'ctrl', 'sl1') mmo <- PairwiseComp(mmo, 'ctrl', 'le1')
Then DAMs of each comparison can be extracted.
# 3.2. Get DAMs from the comparisons
DAMs
<-
GetDAMs
(mmo,
fc_cutoff =
0.5849625
,
pval_cutoff =
0.1
)
# log2(1.5) = 0.5849625
DAMs_up
<-
DAMs
$
DAMs_up
DAMs_down
<-
DAMs
$
DAMs_down
head
(DAMs_up)
The cutoffs for DAMs can be adjusted in the GetDAMs function
4. Upset and Venn Diagram
How many features are overlapping and specific are the common questions following DAM analysis. It can be visualized by UpSet plot and Venn diagram. The inputs for both are identical and can be prepared as following
# 4.1. Define groups
VennInput
<-
list
(
sl1.up =
DAMs_up
$
ctrl_vs_sl1.up,
le1.up =
DAMs_up
$
ctrl_vs_le1.up
)
Then can be plotted as following
# 4.2. Plot
# 4.2.1. Venn Diagram
ggvenn
(VennInput,
stroke_size =
0.5
,
set_name_size =
4
,
show_percentage =
FALSE
)
+
theme
(
legend.position =
"none"
)
ggsave
(
"plots/Venn/Venn_Upreg.pdf"
,
height =
5
,
width =
5
)
# 4.2.2. Upset plot
pdf
(
"plots/Venn/Upset_Upreg.pdf"
,
7
,
5
)
upset
(
fromList
(VennInput),
nsets=
10
,
nintersects=
20
,
order.by=
'freq'
,
mainbar.y.label=
'Features in Set'
,
line.size=
1
,
point.size=
4
,
shade.color=
'white'
,
text.scale=
1
,
show.numbers=
FALSE
)
dev.off
()
5. Volcano plot
The pairwise comparion can be visualized by a volcano plot. Following code generates volcano plots for all comparison made in section 3.
comparison_columns
<-
colnames
(mmo
$
pairwise)
log2FC_columns
<-
grep
(
"log2FC"
, comparison_columns,
value =
TRUE
)
comparisons
<-
sub
(
"_$"
,
""
,
unique
(
sub
(
"log2FC"
,
""
, log2FC_columns)))
# Remove trailing underscore from comparisons
for
(comp
in
comparisons){
VolcanoPlot
(mmo,
comp =
comp,
topk =
10
,
outdir =
paste
(
'plots/volcano/volcano_'
, comp,
'.pdf'
,
sep =
''
))
}
6. Heat Map
A heatmap is a great way to visualize the whole metabolome. Typically the features are clustered by the distribution pattern but alternatively the chemical similarity between features can be visualized. For heatmap, required inputs can be generated from mmo as follows:
# 6.1. Generate inputs for heat map
HMinput
<-
GenerateHeatmapInputs
(mmo,
filter_feature =
FALSE
,
feature_list =
feature_list,
filter_group =
FALSE
,
group_list =
group_list,
summarize =
'mean'
,
control_group =
'ctrl'
,
normalization =
'Z'
,
distance =
'dreams'
)
summary
(HMinput)
Where filter_feature and filter_group can be used on desire. The ‘summarize’ argument can be ‘mean’ or ‘fold_change’. If ‘fold_change’ is used, the ‘control_group’ should be noted. If the chemical similarities are to be plotted, the distance metric to be used should be designated in ‘distance’ as one of dreams, cosine, or m2ds. Then the class-level annotation table is generated.
# 6.2. Generate NPC-based annotation table for heatmap
sirius_annot
<-
mmo
$
sirius_annot
# Get NPC Annotations
NPC_pathway
<-
unique
(sirius_annot[[
32
]])
NPC_pathway
<-
NPC_pathway[
!
is.na
(NPC_pathway)
&
NPC_pathway
!=
""
]
# remove NA and empty
NPC_superclass
<-
unique
(sirius_annot[[
34
]])
NPC_superclass
<-
NPC_superclass[
!
is.na
(NPC_superclass)
&
NPC_superclass
!=
""
]
# remove NA and empty
NPC_class
<-
unique
(sirius_annot[[
36
]])
NPC_class
<-
NPC_class[
!
is.na
(NPC_class)
&
NPC_class
!=
""
]
# remove NA and empty
sirius_annot_filtered
<-
sirius_annot
%>%
# select(id = 1, NPC_pathway = 30, NPC_class = 34) %>%
select
(
id =
1
,
NPC_class =
36
,
NPC_superclass =
34
,
NPC_pathway =
32
)
%>%
# select(id = 1, NPC_pathway = 30, NPC_superclass = 32) %>%
filter
(id
%in%
rownames
(distance_matrix))
# get features with fingerprints
rownames
(sirius_annot_filtered)
<-
sirius_annot_filtered
$
id
sirius_annot_filtered
$
id
<-
NULL
ann_colors
=
list
(
NPC_pathway =
setNames
(
brewer.pal
(
length
(NPC_pathway),
"Set2"
), NPC_pathway),
NPC_class =
setNames
(
viridis
(
length
(NPC_class)), NPC_class),
NPC_superclass =
setNames
(
viridis
(
length
(NPC_superclass)), NPC_superclass)
)
The ann_colors will be plotted along with the heapmap to show which chemical class each features are included in. The heatmap can be visualized as follows:
pdf
(
"plots/heatmap/dreams_total_Z.pdf"
,
width =
15
,
height =
20
)
pheatmap
(
mat =
HMinput
$
FC_matrix,
cluster_rows =
TRUE
,
#do not change
clustering_distance_rows =
HMinput
$
dist_matrix,
# Delete this line for UPGMA clustering of rows
cluster_cols =
FALSE
,
clustering_method =
"average"
,
#UPGMA
show_rownames =
TRUE
,
show_colnames =
TRUE
,
annotation_row =
sirius_annot_filtered,
# Dataframe with the rownames are identical with 'mat' and gives annotation
annotation_colors =
ann_colors,
cellwidth =
25
,
cellheight =
0.05
,
treeheight_row =
100
,
fontsize_row =
3
,
fontsize_col =
15
,
scale =
'none'
,
annotation_names_row =
TRUE
,
#  labels_row = row_label,
border_color =
NA
,
color =
colorRampPalette
(
c
(
"blue"
,
"white"
,
"red"
))(
100
))
dev.off
()
7. Chemical class enrichment analysis
Biological questions ask which class of chemical compounds are enriched in a set of compounds of interest (e.g., DAMs from above). This is analogue to the Gene Ontology enrichment analysis performed in transcriptomics. In MMO, NPC and Classyfire terms annotated by Canopus of SIRIUS are used to perform chemical class enrichment analysis of given list of features. The enrichment score of each term is calculated to plot the number of each term and the significance.
# 7.1. For a single set of features, a detailed enrichment plot can be generated
# There are two plotting styles available
CanopusListEnrichmentPlot
(mmo, DAMs_up
$
ctrl_vs_sl1.up,
pthr =
0.1
,
outdir =
'plots/enrichment/sl1_up.pdf'
,
height =
6
,
width =
6
)
CanopusListEnrichmentPlot_2
(mmo, DAMs_up
$
ctrl_vs_sl1.up,
pthr =
0.1
,
outdir =
'plots/enrichment/sl1_up_2.pdf'
,
topn =
10
,
height =
6
,
width =
6
)
# 7.2. For a list of sets features, a summary enrichment plot can be generated
# The summary enrichment plot can be generated for either a single level of CANOPUS classification (8.2.1) or for all levels (8.2.2)
# 7.2.1. For a single level of CANOPUS classification
term_levels
<-
c
(
'NPC_class'
,
'NPC_superclass'
,
'NPC_pathway'
,
'ClassyFire_most_specific'
,
'ClassyFire_level5'
,
'ClassyFire_subclass'
,
'ClassyFire_class'
,
'ClassyFire_superclass'
)
CanopusLevelEnrichmentPlot
(mmo, DAMs_up,
term_level =
'NPC_class'
,
pthr =
0.1
,
prefix =
'plots/enrichment/DAMs_up_NPC_class.pdf'
)
# 7.2.2. For all levels of CANOPUS classification
# All levels, or onlt NPC or ClassyFire
terms
<-
c
(
'NPC'
,
'ClassyFire'
,
'all_terms'
)
CanopusAllLevelEnrichmentPlot
(mmo, DAMs_up,
term_level =
'all_terms'
,
pthr =
0.1
,
prefix =
'plots/enrichment/DAMs_up_all_terms'
,
width =
8
,
height =
12
)
8. Regression with Metadata
We are interested in finding anti-herbivore resistive compounds from the plant metabolome and testing whether such compounds are upregulated by insect attack. To do so, we first fit linear mixed model to the amount of each feature and the herbivore performance fed on each plant sample (see metadata). The negative effect size of the model represents the resistive value of the feature. We then test whether resistive features are upregulated (log2FC > 1) by plotting the effect size of the LMM and the log2FC as scatter plot. In the demo file, resistive compounds (which have neative effect sizes) were upregulated, which implies plants produce resistive compounds properly in response to sl attack. The analysis can be done as follows:
# To perform regression, the phenotype of interest should be defined in the metadata as a column
# 8.1. Regression of individual feature against a phenotype
# model can be 'lm' or 'pearson' or 'lmm'
# groups can be a vector of group names, or a single group name which has the phenotpye values in the metadata
FeaturePerformanceRegression
(mmo,
target =
'477.0636_7.5687'
,
phenotype =
'sl'
,
groups =
c
(
'sl1'
),
model =
'lm'
,
normalization =
'Z'
,
output =
paste
(
'plots/phenotype_regression/477.0636_7.5687_sl_lm.pdf'
))
# 8.2. Regression of all features against a phenotype and plotting the results
sl.lm
<-
GetPerformanceFeatureRegression
(mmo,
phenotype =
'sl'
,
groups =
c
(
'sl1'
),
DAM.list =
list
(
sl.up =
DAMs_up
$
ctrl_vs_sl1.up,
sl.down =
DAMs_down
$
ctrl_vs_sl1.down),
comparisons =
c
(
'ctrl_vs_sl1'
))
sl.lm.sig
<-
sl.lm
%>%
filter
(p_value
<
0.1
)
head
(sl.lm.sig)
sl.cor
<-
GetPerformanceFeatureCorrelation
(mmo,
phenotype =
'sl'
,
groups =
c
(
'sl1'
),
DAM.list =
list
(
sl.up =
DAMs_up
$
ctrl_vs_sl1.up,
sl.down =
DAMs_down
$
ctrl_vs_sl1.down),
comparisons =
c
(
'ctrl_vs_sl1'
))
sl.cor.sig
<-
sl.cor
%>%
filter
(p_value
<
0.1
)
head
(sl.cor.sig)
# One may want to plot the regression results along with the fold change values
PlotFoldchangeResistanceRegression
(sl.lm.sig,
fold_change =
'ctrl_vs_sl1_log2FC'
,
color =
c
(
'sl.up'
=
'#d42525ff'
,
'sl.down'
=
'#281e99ff'
),
output_dir =
'plots/phenotype_regression/sl_lm_sig.pdf'
)
9. Chemical Diversity Measures
The chemical diversity is one of the key parameters in ecological studies. MMO quantifies the chemical diversity idices using idea from
ChemoDiv
package. The fingerprint distances are treated as phylogenetic diversity as in measuring taxonomic diversity. Alpha diversity can be calculated as following.
# 9.1. Alpha diversity by Hill numbers
# q : Hill number order, 0 for richness, 1 for Shannon, 2 for Simpson
# mode : weighted for the chemical structure (use distance argument), unweighted for no chemical weight
# filter_feature : if TRUE, only features in the feature_list are used
# feature_list : a list of features to filter the alpha diversity calculation
alphadiv
<-
GetAlphaDiversity
(mmo,
q =
3
,
normalization =
'Log'
,
mode =
'weighted'
,
distance =
'dreams'
,
filter_feature =
FALSE
,
feature_list =
NULL
)
# 9.1.1 Plot the alpha diversity
ggplot
(alphadiv,
aes
(
x =
group,
y =
hill_number))
+
geom_boxplot
(
outlier.shape =
NA
)
+
geom_beeswarm
(
size =
0.5
)
+
theme_classic
()
+
labs
(
title =
'Alpha Diversity by Hill Numbers'
,
x =
'Group'
,
y =
'Hill Number'
)
+
theme
(
legend.position =
"none"
,
axis.text.x =
element_text
(
angle =
45
,
vjust =
1
,
hjust=
1
))
ggsave
(
'plots/alphadiv/dreams_q3_log.pdf'
,
width =
5
,
height =
5
)
# Test for significant differences between groups with ANOVA
anova
<-
anova_tukey_dunnett
(alphadiv,
'hill_number ~ group'
)
write_anova
(anova,
'plots/alphadiv/anova_hill_number.csv'
)
# 9.1.2 Plot the feature distribution
# Function to plot histogram of values for each feature for given groups
groups
<-
c
(
'ctrl'
,
'sl1'
,
'le1'
)
group.mean
<-
GetGroupMeans
(mmo,
normalization =
'Z'
,
filter_feature =
FALSE
,
feature_list =
NULL
)[,
-
1
]
long.group.mean
<-
data.frame
(
value =
double
(),
group =
character
())
for
(group
in
groups) {
group_data
<-
data.frame
(
value =
group.mean[, group],
group =
group)
colnames
(group_data)
<-
c
(
'value'
,
'group'
)
long.group.mean
<-
rbind
(long.group.mean, group_data)
}
ggplot
(
data =
long.group.mean,
aes
(
x =
value,
fill =
group,
color =
group))
+
geom_density
(
position =
'identity'
,
alpha =
0
)
+
theme_classic
()
+
labs
(
x =
"Normalized peak intensity"
,
y =
"Density"
)
+
# scale_fill_manual(values = custom_colors) +
theme
(
legend.position =
"right"
)
ggsave
(
'plots/alphadiv/density_function_Z.pdf'
,
height =
6
,
width =
6
)
metadata
<-
mmo
$
metadata
feature
<-
mmo
$
zscore
# The distribution should be shown!
plot_data
<-
data.frame
(
value =
double
(),
rank =
double
(),
sample =
character
(),
group =
character
())
for
(group
in
groups) {
group_samples
<-
metadata
%>%
filter
(group
==
!!
group)
%>%
pull
(sample)
for
(sample
in
group_samples) {
sample_data
<-
unlist
(
as.vector
(feature[, sample]))
sorted_data
<-
sort
(sample_data,
decreasing =
TRUE
)
sample_plot_data
<-
data.frame
(
value =
sorted_data,
rank =
seq_along
(sorted_data),
group =
group,
sample =
sample)
plot_data
<-
rbind
(plot_data, sample_plot_data)
}
}
ggplot
(plot_data,
aes
(
x =
rank,
y =
value,
color =
group))
+
stat_summary
(
fun.data =
mean_se,
geom =
"errorbar"
,
width =
0.2
,
position =
position_dodge
(
width =
0.5
),
alpha =
0.06
)
+
stat_summary
(
fun =
mean,
geom =
"line"
,
position =
position_dodge
(
width =
0.5
))
+
theme_classic
()
+
labs
(
title =
"Sorted Feature"
,
x =
"Rank"
,
y =
"Value"
)
ggsave
(
'plots/alphadiv/sorted_intensity_Z.png'
,
height =
6
,
width =
6
)
# 9.2. Beta diversity
# Calculate beta diversity for different normalizations and methods
# For unweighted beta diversity, Bray-Curtis or Jaccard distance can be used
bray
<-
GetBetaDiversity
(mmo,
method =
'bray'
,
normalization =
'Log'
,
filter_feature =
FALSE
,
feature_list =
NULL
)
jaccard
<-
GetBetaDiversity
(mmo,
method =
'jaccard'
,
normalization =
'Log'
,
filter_feature =
FALSE
,
feature_list =
NULL
)
# For weighted beta diversity, Generalized UniFrac can be used
guni
<-
GetBetaDiversity
(mmo,
method =
'Gen.Uni'
,
normalization =
'Log'
,
distance =
'dreams'
,
filter_feature =
FALSE
,
feature_list =
NULL
)
guni
.0
<-
guni[,,
'd_0'
]
# GUniFrac with alpha 0
guni
.05
<-
guni[,,
'd_0.5'
]
# GUniFrac with alpha 0.5
guni
.1
<-
guni[,,
'd_1'
]
# GUniFrac with alpha 1
# 9.2.1. NMDS plots for beta diversity
nmds
<-
metaMDS
(guni
.05
,
k =
2
,
try =
50
,
trymax =
100
)
nmds_coords
<-
as.data.frame
(
scores
(nmds))
groups
<-
c
()
for
(col
in
colnames
(mmo
$
feature_data)[
-
c
(
1
,
2
)]) {
groups
<-
append
(groups, metadata[metadata
$
sample
==
col, ]
$
group)
}
nmds_coords
$
group
<-
groups
ggplot
(nmds_coords,
aes
(
x =
NMDS1,
y =
NMDS2,
color =
group))
+
geom_point
(
size =
3
)
+
#geom_text_repel(aes(label = group), size = 3) +
theme_classic
()
+
stat_ellipse
(
level =
0.90
)
+
labs
(
x =
"NMDS1"
,
y =
"NMDS2"
)
+
theme
(
legend.position =
"right"
)
ggsave
(
'plots/betadiv/NDMS_guni05.pdf'
,
height =
6
,
width =
6
)
# 9.2.2. Quantification of beta diversity
group_distances
<-
CalculateGroupBetaDistance
(mmo,
beta_div =
guni
.05
,
reference_group =
'ctrl'
,
groups =
c
(
'le1'
,
'sl1'
))
ggplot
(group_distances,
aes
(
x =
group,
y =
distance))
+
geom_boxplot
(
outlier.shape =
NA
)
+
geom_beeswarm
(
size =
0.5
)
+
theme_classic
()
+
labs
(
x =
"Group"
,
y =
"Beta Diversity"
)
ggsave
(
'plots/betadiv/group_dist.pdf'
,
height =
6
,
width =
6
)
10. Exporting compounds of interest
ExportFeaturesToCSV(mmo, feature_list = DAMs_up$ctrl_vs_sl1.up, normalization = 'None', output_dir = 'output/sl1_up_features.csv')


============================================================
## Package index
Source: https://phytoecia.github.io/eCOMET/reference/index.html
============================================================

Package index
Core dataset processing
GetMZmineFeature()
Import MZmine feature table and metadata to create a mmo object
AddSiriusAnnot()
Adding annotation from SIRIUS to the mmo object
AddChemDist()
Add chemical distance matrices to the mmo object
AddCustomAnnot()
Add custom annotations to an mmo object
LogNormalization()
Log-normalize the peak area in the mmo object
MassNormalization()
Use sample mass in the metadata file to normalize the peak area
MeancenterNormalization()
Mean-center the peak area in the mmo object
ZNormalization()
Z-normalize the peak area in the mmo object
ReplaceZero()
Replace zero and NA values in the mmo object
ReorderGroups()
Reorder samples in the mmo object based on group order
SwitchGroup()
Switch the group column in the mmo object
FeaturePresence()
Convert feature abundances to presence / absence
Filterng MMO and associated MGF
filter_mmo()
Filter an mmo object by samples, groups, and/or features
filter_mgf_to_mmo()
Filter an MGF file to keep only spectra for features present in mmo$feature_data$id
annotate_feature_info_ms2_from_mgf()
Annotate mmo$feature_info with MS2 presence and MS2 block counts from an MGF
filter_canopus_annotations()
Filter CANOPUS / SIRIUS annotations in an ecomet mmo object by probability threshold
filter_cosmic_structure()
Filter SIRIUS structure (CSI:FingerID) annotations by COSMIC confidence score
Basic statistics and visualization
PairwiseComp()
Perform pairwise comparison between two groups in the mmo object
VolcanoPlot()
Volcano plot for visualizing differential metabolite analysis results
PCAplot()
Plots PCA and performs PERMANOVA
PLSDAplot()
PLS-DA plot with feature loadings
AnovaBarPlot()
Generate barplots for each feature and perform ANOVA
GenerateHeatmapInputs()
Generate input files to be used for pheatmap from the mmo object
GetDAMs()
Generates lists of DAMs (Differentially Accumulated Metabolites) for each comparison in the mmo object
GetGroupMeans()
Calculate group means from the mmo object
GetLog2FoldChange()
Calculate log2 fold change for a given control group
HCplot()
HCplot
Chemical class analysis
CanopusLevelEnrichmentAnal()
Enrichment analysis for Canopus-predicted terms
CanopusListEnrichmentPlot()
Generate a plot for enrichment analysis of Canopus-predicted terms
CanopusListEnrichmentPlot_2()
Generate a plot for enrichment analysis of Canopus-predicted terms across multiple levels
CanopusLevelEnrichmentPlot()
Generate a plot for enrichment analysis of Canopus-predicted terms at a specific level using a list of vectors of features
CanopusAllLevelEnrichmentPlot()
Generate a plot for enrichment analysis of Canopus-predicted terms across all levels
MSEA()
Metabolite Set Enrichment Analysis (MSEA)
Chemical diversity Analysis
GetRichness()
GetRichness
GetAlphaDiversity()
GetAlphaDiversity
GetFunctionalHillNumber()
GetFunctionalHillNumber
GetHillNumbers()
GetHillNumbers
GetBetaDiversity()
GetBetaDiversity
NMDSplot()
NMDSplot
PCoAplot()
PCoAplot
CalculateGroupBetaDistance()
CalculateGroupBetaDistance
GetSpecializationIndex()
GetSpecializationIndex
PlotNPCStackedBar()
PlotNPCStackedBar
BootCumulRichnessAUC()
BootCumulRichnessAUC
BootstrapCumulativeRichness()
BootstrapCumulativeRichness
CalcNormalizedAUC()
CalcNormalizedAUC
CalculateCumulativeRichness()
CalculateCumulativeRichness
CalculateNullCumulativeRichness()
CalculateNullCumulativeRichness
Metadata regression analysis
FeaturePhenotypeCorrelation()
FeaturePhenotypeCorrelation
ScreenFeaturePhenotypeCorrelation()
Screen feature-phenotype correlation
GetPerformanceFeatureCorrelation()
GetPerformanceFeatureCorrelation
GetPerformanceFeatureLMM()
GetPerformanceFeatureLMM
GetPerformanceFeatureRegression()
GetPerformanceFeatureRegression
PlotFoldchangeResistanceQuad()
PlotFoldchangeResistanceQuad
PlotFoldchangeResistanceRegression()
PlotFoldchangeResistanceRegression
PlotFoldchangeResistanceRegression_t()
PlotFoldchangeResistanceRegression_t
Output
ExportFeaturesToCSV()
ExportFeaturesToCSV
SaveMMO()
Save entire mmo object to a file (RDS)
LoadMMO()
Load an mmo object previously saved with SaveMMO
misc
FeatureToID()
Convert feature names to IDs in the mmo object
IDToFeature()
Convert feature IDs to names in the mmo object
anova_tukey_dunnett()
Perform ANOVA and Tukey's HSD test on the mmo object
write_anova()
Write results of anova_tukey_dunnett to a CSV file
permanova_stat()
Perform PERMANOVA and pairwise comparisons
GetDistanceMat()
Get the distance matrix from the mmo object based on the specified distance metric
GetNormFeature()
Retrieve feature data from the mmo object, with normalization options
filter_mmo()
Filter an mmo object by samples, groups, and/or features
print(
<mmo>
)
Print method for mmo objects Provides a clean, human-readable overview of an
mmo
list object instead of dumping the entire list when the object is printed in the console.


============================================================
## Articles
Source: https://phytoecia.github.io/eCOMET/articles/index.html
============================================================

Articles
Tutorials
eCOMET-intro
Treatment-based_study_tutorial


============================================================
## Treatment-based_study_tutorial
Source: https://phytoecia.github.io/eCOMET/articles/Treatment-based_study_tutorial.html
============================================================

Treatment-based_study_tutorial
2026-01-26
Treatment-based_study_tutorial.Rmd
#install.packages("pak")
#pak::pkg_install("Phytoecia/eCOMET", dependencies = TRUE)
#pak::pkg_install("Phytoecia/eCOMET", dependencies = TRUE, upgrade = TRUE)
library
(
ecomet
)
library
(
dplyr
)
#>
#> Attaching package: 'dplyr'
#> The following objects are masked from 'package:stats':
#>
#>     filter, lag
#> The following objects are masked from 'package:base':
#>
#>     intersect, setdiff, setequal, union
library
(
stringr
)
library
(
here
)
#> here() starts at /Users/dlforrister/Library/CloudStorage/OneDrive-SmithsonianInstitution/One_Drive_BackUps_Local_Mac_Files/CODE_GIT_HUB_2017_Aug_31/eCOMET
here
(
)
#> [1] "/Users/dlforrister/Library/CloudStorage/OneDrive-SmithsonianInstitution/One_Drive_BackUps_Local_Mac_Files/CODE_GIT_HUB_2017_Aug_31/eCOMET"
Background
In this tutorial, we will demonstrate how to use the
eCOMET
package for analyzing metabolomics data from a
treatment-based study.
Treatment-based studies involve comparing metabolite profiles
between different treatment groups (e.g., control vs treated).
The tutorial covers data preprocessing, normalization,
statistical analysis, and visualization techniques commonly used in
treatment-based metabolomics studies.
The tutorial files are metabolomics analysis files of
Arabidopsis thaliana
(Col-0) attacked by two different
herbivores (
Spodoptera litura
; sl, and
Lipaphis
erysimi
; le).
Eight replicates were sampled and analyzed for each group. See
metadata.csv for more details.
Tutorial data
eCOMET is distributed with a small set of example data files that are
installed automatically with the package. These files are included
specifically so that the tutorials can be run immediately, without
downloading additional data or setting file paths by hand.
The example datasets represent simplified versions of the feature
tables, metadata, and annotation outputs used in a typical eCOMET
analysis workflow. They are meant for demonstration and testing, not as
complete research datasets.
Step 1: Gathering the paths for MMO object inputs.
To generate an mmo object you need to supply at minimum:
feature abundance table from mzmine. It is best to export the
“full feature table” which provides the maximum amount of information
regarding the abundance in each sample as well as feature information
(i.e mass to charge (m/z) and retention time)
path to sample meta data. You need to identify the two columns in
the metdata:
group column that can be used as the main group for
comparisons
sample column which defines the name or path of the sample
columns.
Optionally you can provide:
sirius outputs
ms/ms similarity based on cosine, ms2deep score OR
dreams.
# Locate tutorial data shipped with the eCOMET package
data_dir
<-
system.file
(
"extdata/tutorials/treatment_based"
,
package
=
"ecomet"
)
stopifnot
(
nzchar
(
data_dir
)
)
# fail loudly if package/data not installed
# Define file paths
demo_feature
<-
file.path
(
data_dir
,
"feature_table_demo.csv"
)
demo_metadata
<-
file.path
(
data_dir
,
"metadata_demo.csv"
)
demo_sirius_formula
<-
file.path
(
data_dir
,
"canopus_formula_summary.tsv"
)
demo_sirius_structure
<-
file.path
(
data_dir
,
"structure_identifications.tsv"
)
demo_dreams
<-
file.path
(
data_dir
,
"dreams_sim_demo.csv"
)
gls_db
<-
file.path
(
data_dir
,
"custom_DB_glucosinolates.csv"
)
1. Create an
mmo
object
Following steps are performed to create an
mmo
object
and add various normalizations and annotations. Inspect the structure of
the ‘mmo’ object using ‘summary(mmo)’’ after each step to see how the
object is updated.
# Initialize eCOMET object
mmo
<-
GetMZmineFeature
(
mzmine_dir
=
demo_feature
, metadata_dir
=
demo_metadata
, group_col
=
'group'
, sample_col
=
'sample'
)
mmo
$
feature_data
mmo
$
feature_info
mmo
$
pairwise
mmo
$
metadata
#MS - I discussed this with Sedio Group and everyone things the
feature table to be appended to list not replace… #Can we adjust to
address this?? At the very least we want to discuss when to apply
this.
#Add explanation of why we would replace zero how it will impact
downstream calculations (i.e valcano plots vs richness calculations)
mmo
<-
ReplaceZero
(
mmo
, method
=
'one'
)
# Replace 0 and NA values by 1
mmo
$
feature_data
#MS-same don’t replace add #annotate exactly how Mass is Normalized
and how it knows what column to use
mmo
<-
MassNormalization
(
mmo
)
# Normalize peak area by sample mass in metadata
mmo
$
feature_data
#Can you add a little more annotation here and in the
help/documentation to explain what meancenter normalization works? Sedio
group had questions.
#ecoMET offers the following types of normalization each will append
a new feature_abundance matrix to the mmo object and can be called when
plotting.
mmo
<-
MeancenterNormalization
(
mmo
)
# Add mean-centered area
mmo
<-
LogNormalization
(
mmo
)
# Add log-transformed area
mmo
<-
ZNormalization
(
mmo
)
# Add Zscore
You can also convert the feature abundance matrix to a presence
absence matrix based on a threshold using the function
FeaturePresence
mmo
<-
FeaturePresence
(
mmo
, threshold
=
1
)
# Add Zscore
MS-I am still getting duplicates and it gives a warning. We should
address this in the tutorial but also did I lose the fix you implemented
to handle the duplicates?
# Add SIRIUS annotation
mmo
<-
AddSiriusAnnot
(
mmo
, canopus_structuredir
=
demo_sirius_structure
, canopus_formuladir
=
demo_sirius_formula
)
mmo
$
sirius_annot
#Need to explain how to handle duplicates!
MS- There are still duplicates. Do you know how to exclude them and
how to handle it? If duplicates appear in the tutorial we need to at
least explain what’s going on here…
We can filter sirius annotations based on confidence score. We can do
this both for the probabilities in the canopus class predictions and/or
to the formula/smiles predictions.
Starting with the class predictions we can use the
filter_canopus_annotations() function
We define what pathway levels we want to filter: i.e. pathway_level =
“NPC#pathway”, “All” or “All_NPC” You can also provide a list of
columns.. c(“NPC#superclass”,“NPC#class”)
Define a threshold cut of i.e. threshold = 0.9
The function will add a new annotation list to the mmo object and a
suffex can be added to note what settings were used - suffix =
“NPC_pathway_0.9”
Sirius provides some info on how to set this threshold -
The relevant warning for this threshold is here:
https://v6.docs.sirius-ms.io/methods-background/#CANOPUS
“Be aware that there is no universally accepted threshold to classify
predictions as “good” or “bad.” The posterior probability estimates
provided do not adhere to a fixed standard, and while a binary
classifier might suggest a threshold of 0.5, this is not always
sufficient in real-world applications. If a user desires more nuanced
classifications, such as “Yes,” “No,” and “Maybe,” thresholds like 0.15
and 0.85 may be helpful, although these are just approximations.
Moreover, for statistical analysis, such as determining the number of
occurrences of a specific compound class in a sample, users can sum up
the probabilities to get an expected count. It’s also important to
consider that when a compound is significantly different from known
compounds, CANOPUS may return lower probabilities for all compound
classes, which means users might need to accept predictions with
probabilities below 0.5 depending on their specific needs. Thus, the
choice of threshold depends on the context and the user’s tolerance for
uncertainty.”
It can be helpful to visialize the distribution of thresholds to see
how much you would be filtering out
hist
(
mmo
$
sirius_annot
$
`NPC#pathway Probability`
)
Here we see that there is a long tail of low confidence values. In
this tutorial we will filter these out just as one example.
mmo
<-
filter_canopus_annotations
(
mmo
, pathway_level
=
"NPC#pathway"
, threshold
=
0.8
,suffix
=
"NPC_pathway_0.8"
,overwrite
=
T
)
mmo
$
sirius_annot_filtered_NPC_pathway_0.8
A similar logic can be applied to filter the smiles confidence
In order to filter sequentially we have to define what
Sirius_annotation filter we want to apply this too setting input
See the documentation for details about this score!
https://v6.docs.sirius-ms.io/methods-background/#CANOPUS
More details in this paper:
https://www.nature.com/articles/s41587-021-01045-9
“Interpretation of COSMIC confidence values: COSMIC confidence scores
should be interpreted with caution. It’s crucial to understand that
these scores are not probabilities and, therefore, do not have a direct
statistical interpretation. When performing large-scale analyses, it’s
advisable to focus on the highest-confidence hits (e.g., the top
1/5/10%), generally independent of their specific confidence value.”
#Replace -Infinity w/ 0
mmo
$
sirius_annot_filtered_NPC_pathway_0.8
$
ConfidenceScoreApproximate
[
which
(
mmo
$
sirius_annot_filtered_NPC_pathway_0.8
$
ConfidenceScoreApproximate
==
"-Infinity"
)
]
<-
0
Cosmic_Scores
<-
as.numeric
(
mmo
$
sirius_annot_filtered_NPC_pathway_0.8
$
ConfidenceScoreApproximate
)
hist
(
Cosmic_Scores
, main
=
"Cosmic Confidence Score for Structures"
)
We can see the distribution of scores very different than in the
class probabilities.
To get the top 10% of hits
quantile
(
x
=
Cosmic_Scores
,probs
=
0.9
,na.rm
=
T
)
mmo
<-
filter_cosmic_structure
(
mmo
,
input
=
"sirius_annot_filtered_NPC_pathway_0.8"
,
cosmic_mode
=
"approx"
,
threshold
=
0.3892
,
suffix
=
"CANOPUS_0.9__COSMIC_Top_10"
)
Make a vector of flavonoids using SIRIUS annotation
FLVs_features
<-
mmo
$
sirius_annot
%>%
filter
(
str_detect
(
mmo
$
sirius_annot
[[
'ClassyFire#most specific class'
]
]
,
"Flavonoid"
)
)
%>%
pull
(
feature
)
FLVs_features
# Add custom annotation using inhouse glucosinolate library
mmo
<-
AddCustomAnnot
(
mmo
, DB
=
gls_db
, mztol
=
5
, rttol
=
0.2
)
# Make a vector of glucosinolates using custom annotation
GLSs
<-
mmo
$
custom_annot
%>%
filter
(
lengths
(
custom_annot
)
>
0
)
%>%
pull
(
feature
)
GLSs
# Add Dreams distance
mmo
<-
AddChemDist
(
mmo
, dreams_dir
=
demo_dreams
)
mmo
$
dreams.dissim
[
1
:
10
,
1
:
10
]
2. Plot dimensionality reduction plots
PCA plot and PERMANOVA
A PCA plot is commonly used to visualize the overall distribution of
groups. Following PERMANOVA test can be performed to check if the groups
are significantly different.
PCAplot()
function use mmo to
perform PCA, plot them, and perform PERMANOVA test.
MS - I think that we should explain the logic of how to either save
the output directly OR how to return the obect. Did you set it up so
that if an outdir is provided it will save otherwise it will just
return? I would start with returning the obect and showing the format of
the output/plot Then showing how you can add your own astetics and
resave…
# Set colors for groups
colors
<-
c
(
"ctrl"
=
"grey"
,
"sl1"
=
"#fdcdac"
,
"le1"
=
"#b3e2cd"
)
# PCA plot
# A plot and permanova output files will be generated in the specified outdir
PCAplot
(
mmo
, color
=
colors
, outdir
=
'plot/PCA'
)
PCAplot
(
mmo
, color
=
colors
, outdir
=
'plot/PCA_log'
, label
=
FALSE
, normalization
=
'Log'
)
# Data normalization option
PCAplot
(
mmo
, color
=
colors
, outdir
=
'plot/PCA_FLV'
, label
=
FALSE
, filter_feature
=
TRUE
, feature_list
=
FLVs
)
# Feature filtering option
Alternatively, you can use the output of PCAplot to generate plot
with your own aesthetics.
# Get PCA plot inputs
pca_res
<-
PCAplot
(
mmo
, color
=
colors
, outdir
=
'plot/PCA'
)
# Generate plot with your own aesthetics
pdf
(
"plot/PCA.pdf"
, width
=
10
, height
=
10
)
ggplot
(
pca_res
$
df
,
aes
(
x
=
PC1
, y
=
PC2
, color
=
group
)
)
+
geom_point
(
size
=
2
)
+
theme_minimal
(
)
+
labs
(
title
=
"PCA plot"
, x
=
"PC1"
, y
=
"PC2"
)
dev.off
(
)
Likewise, all plot-generating functions in eCOMET return a list of
dataframes and other objects that can be used to generate plots with
your own aesthetics. Use
summary(pca_res)
to see the
structure of the output and try this for other plot-generating
functions. ### PLS-DA plot
# Plot PLS-DA
PLSDAplot
(
mmo
, color
=
colors
, outdir
=
'plot/PLSDA.pdf'
)
PLSDAplot
(
mmo
, color
=
colors
, outdir
=
'plot/PLSDA_meancentered.pdf'
, normalization
=
'Meancentered'
)
# Data normalization option
3. Identify differentially accumulated metabolites (DAMs)
Many analyses targets to find
Differentially Accumulated
Metabolites (DAMs)
. DAMs can be defined by thresholds of
log2-fold change and adjusted p-value. Those two metrics are calculated
by following code. Note that the divisor group is at the left. -
PairwiseComp()
function performs pairwise comparison
between two groups using t-test and fold change. The results are stored
in mmo$pairwise_comp. -
GetDAMs()
function extracts DAMs
based on user-defined cutoffs for p-value and fold change. - Here, we
compare each herbivore treatment group (sl1 and le1) to the control
group (ctrl). - Log2(1.5) = 0.5849625 is used as fold change cutoff and
0.1 as p-value cutoff to extract more DAMs
# Run pairwise comparison
mmo
<-
PairwiseComp
(
mmo
, group1
=
'ctrl'
, group2
=
'sl1'
)
mmo
<-
PairwiseComp
(
mmo
, group1
=
'ctrl'
, group2
=
'le1'
)
# Extract DAMs
DAMs
<-
GetDAMs
(
mmo
, fc_cutoff
=
0.5849625
, pval_cutoff
=
0.1
)
# log2(1.5) = 0.5849625
DAMs_up
<-
DAMs
$
DAMs_up
DAMs_down
<-
DAMs
$
DAMs_down
head
(
DAMs_up
)
3.1. Volcano plot
A volcano plot can be used to visualize the overall distribution of
features based on fold change and p-value.
# Volcano plot
VolcanoPlot
(
mmo
, comp
=
'ctrl_vs_sl1'
, outdir
=
'plot/Volcano_ctrl_vs_sl1.pdf'
)
VolcanoPlot
(
mmo
, comp
=
'ctrl_vs_le1'
, outdir
=
'plot/Volcano_ctrl_vs_le1.pdf'
, topk
=
0
)
# Remove label by setting topk = 0
3.2. Venn diagram and upset plot
A Venn diagram or upset plot can be used to visualize the overlap of
DAMs between different comparisons.
# Define input list
VennInput
<-
list
(
sl1.up
=
DAMs_up
$
ctrl_vs_sl1.up
,
le1.up
=
DAMs_up
$
ctrl_vs_le1.up
)
# Venn diagram
require
(
ggvenn
)
library
(
ggvenn
)
ggvenn
(
VennInput
, stroke_size
=
0.5
, set_name_size
=
4
, show_percentage
=
FALSE
)
+
theme
(
legend.position
=
"none"
)
ggsave
(
"plot/Venn_Upreg.pdf"
, height
=
5
, width
=
5
)
# UpSet plot
require
(
UpSetR
)
library
(
UpSetR
)
pdf
(
"plot/Upset_Upreg.pdf"
,
7
,
5
)
upset
(
fromList
(
VennInput
)
, nsets
=
10
, nintersects
=
20
,order.by
=
'freq'
, mainbar.y.label
=
'Features in Set'
, line.size
=
1
, point.size
=
4
, shade.color
=
'white'
, text.scale
=
1
, show.numbers
=
FALSE
)
dev.off
(
)
4. Heatmap
To visualize the relative abundance of features across samples, a
heatmap can be generated. The features can be either clusterd using
hierarchical clustering or by chemical distances (e.g., Dreams
distance), following idea of Qemistree (Tripathi et al., 2021, Nat Chem.
Biol.).
The input matrix for heatmap can be either fold change between each
treatment and control or mean normalized values across samples.
Various normalizations can be used (None, Log, Meancentered, and
Z).
Groups or features can be filtered by setting ‘filter_group’ or
‘filter_feature’ to TRUE and providing a list of groups or
features.
The input data for the heatmap is generated by
‘GenerateHeatmapInputs()’ function, then the heatmap is plotted using
‘pheatmap’ package.
library
(
pheatmap
)
# Generate input for heatmap
# distance is one of the chemical distance (cosine, m2ds, and dreams) for clustering rows
# The values can be either fold_change or mean (use option 'summarize')
heatmap_inputs
<-
GenerateHeatmapInputs
(
mmo
, summarize
=
'fold_change'
, control_group
=
'ctrl'
,
normalization
=
'None'
, distance
=
'dreams'
)
# This generates fold change matrix between each treatment and control
# The resulting list contains FC_matrix, dist_matrix, row_label, and heatmap_data
# A heatmap can be generated using pheatmap
pdf
(
"plot/Heatmap_FC_dreams.pdf"
, width
=
10
, height
=
10
)
pheatmap
(
mat
=
heatmap_inputs
$
FC_matrix
,
clustering_distance_rows
=
heatmap_inputs
$
dist_matrix
,
clustering_method
=
"average"
,
cellwidth
=
100
,
cellheight
=
0.3
,
treeheight_row
=
100
,
fontsize_row
=
3
,
fontsize_col
=
15
,
scale
=
'none'
)
dev.off
(
)
# Either, you can visualize mean normalized values across samples
heatmap_inputs
<-
GenerateHeatmapInputs
(
mmo
, summarize
=
'mean'
, normalization
=
'Z'
, distance
=
'dreams'
)
# 'clustering_distance_rows' option make the dendrogram follows chemical distances of features.
#  -Delete this option to visualize the heatmap following cannonical clustering
pdf
(
"plot/Heatmap_Mean_Z_clustering.pdf"
, width
=
10
, height
=
10
)
pheatmap
(
mat
=
heatmap_inputs
$
FC_matrix
,
#clustering_distance_rows = heatmap_inputs$dist_matrix,  # Delete this option to visualize the heatmap following cannonical clustering
clustering_method
=
"average"
,
#UPGMA
cellwidth
=
100
,
cellheight
=
0.3
,
treeheight_row
=
100
,
fontsize_row
=
3
,
fontsize_col
=
15
,
scale
=
'none'
)
dev.off
(
)
# Feature filtering option
# Visualize only glucosinolates
# As glucosinolate annotations are stored in mmo$custom_annot (by AddCustomAnnot() function),
# the compound names are stored in heatmap_inputs$row_label and can be used as row names
heatmap_inputs_GLS
<-
GenerateHeatmapInputs
(
mmo
, summarize
=
'mean'
, normalization
=
'Z'
, distance
=
'dreams'
,
filter_feature
=
TRUE
, feature_list
=
GLSs
)
pdf
(
"plot/Heatmap_Mean_Z_GLS.pdf"
, width
=
10
, height
=
10
)
pheatmap
(
mat
=
heatmap_inputs_GLS
$
FC_matrix
,
#clustering_distance_rows = heatmap_inputs_GLS$dist_matrix,  # Delete this option to visualize the heatmap following cannonical clustering
clustering_method
=
"average"
,
#UPGMA
cellwidth
=
100
,
cellheight
=
8
,
treeheight_row
=
100
,
fontsize_row
=
8
,
fontsize_col
=
15
,
scale
=
'none'
,
annotation_names_row
=
TRUE
,
labels_row
=
heatmap_inputs_GLS
$
row_label
)
dev.off
(
)
5. CANOPUS class enrichment analysis
Biological questions ask which class of chemical compounds are
enriched in a set of compounds of interest (e.g., DAMs from above). This
is analogue to the Gene Ontology enrichment analysis performed in
transcriptomics. In MMO, NPC and Classyfire terms annotated by Canopus
of SIRIUS are used to perform chemical class enrichment analysis of
given list of features. The enrichment score of each term is calculated
to plot the number of each term and the significance.
# For a single set of features, a detailed enrichment plot can be generated
# There are two plotting styles available
CanopusListEnrichmentPlot
(
mmo
,
DAMs_up
$
ctrl_vs_sl1.up
, pthr
=
0.1
, outdir
=
'plot/sl1_up_enrichment.pdf'
, height
=
6
, width
=
6
)
CanopusListEnrichmentPlot_2
(
mmo
,
DAMs_up
$
ctrl_vs_sl1.up
, pthr
=
0.1
, outdir
=
'plot/sl1_up_enrichment_2.pdf'
, topn
=
10
, height
=
6
, width
=
6
)
# For a list of sets features, a summary enrichment plot can be generated
# The summary enrichment plot can be generated for either a single level of CANOPUS classification (8.2.1) or for all levels (8.2.2)
# For a single level of CANOPUS classification
term_levels
<-
c
(
'NPC_class'
,
'NPC_superclass'
,
'NPC_pathway'
,
'ClassyFire_most_specific'
,
'ClassyFire_level5'
,
'ClassyFire_subclass'
,
'ClassyFire_class'
,
'ClassyFire_superclass'
)
CanopusLevelEnrichmentPlot
(
mmo
,
DAMs_up
, term_level
=
'NPC_class'
, pthr
=
0.1
, prefix
=
'plot/DAMs_up_NPC_class'
)
# For all levels of CANOPUS classification
# All levels, or only NPC or ClassyFire
CanopusAllLevelEnrichmentPlot
(
mmo
,
DAMs_up
, term_level
=
'NPC'
, pthr
=
0.1
, prefix
=
'plot/DAMs_up_all_terms'
, width
=
8
, height
=
12
)
CanopusAllLevelEnrichmentPlot
(
mmo
,
DAMs_up
, term_level
=
'ClassyFire'
, pthr
=
0.1
, prefix
=
'plot/DAMs_up_all_terms'
, width
=
8
, height
=
12
)
6. Correlation analysis
To find phenotype-linked metabolties, we can use correlation
analysis. In this tutorial, we will use correlation between amount of
each feature and herbivore performance in bioassay to find defense
compounds.
# We will first screen for all features to find whether there is any correlation between amount of each feature and herbivore performance in bioassay
sl_cor
<-
ScreenFeaturePhenotypeCorrelation
(
mmo
, phenotype
=
'sl'
, groups
=
c
(
'sl1'
)
, model
=
'spearman'
, normalization
=
'Z'
)
head
(
sl_cor
)
7. Sharing MMO object
MMO object can be shared with other users by saving it to a file and
loading it from a file.
# Save MMO object
SaveMMO
(
mmo
,
'mmo.RData'
)
# Load MMO object
mmo
<-
LoadMMO
(
'mmo.RData'
)


============================================================
## Changelog
Source: https://phytoecia.github.io/eCOMET/news/index.html
============================================================

Changelog
ecomet (development version)
eCOMET 0.0.0.9000
Initial packaged version from custom functions
Roxygen-formated
eCOMET 0.0.0.9001
Vignettes added
NMDS, PCoA added
eCOMET 0.0.0.9002
Importing functions now deal with mzML, mzXML, and thermo raw files
All plot generating functions now returns a list of the plot and raw data. Saving the outputs are optional.