# eCOMET Complete Knowledge Base
# Documentation from: https://phytoecia.github.io/eCOMET
# Source code from: https://github.com/Phytoecia/eCOMET
# Last updated: 2026-02-08T02:11:05.554340


############################################################
# PART 1: DOCUMENTATION
############################################################


============================================================
## eCOMET

Source: https://phytoecia.github.io/eCOMET/index.html
============================================================

eCOMET
The eCOMET package provides tools for processing and analyzing mass spectrometry–based metabolomics data in ecological and evolutionary contexts. It establishes a standardized pipeline that integrates MS1 feature–abundance tables with MS2 spectral similarity to generate common data products, including principal component analyses (PCA), chemical dendrograms where tips represent compounds, principal coordinates analyses (PCoA), and differential expression analyses. Unlike existing metabolomics toolkits that focus primarily on biomedical or cheminformatics applications, ecomet is designed explicitly for ecometabolomics. It emphasizes workflows that link metabolomic variation to ecological data, making it easier to move from raw mass spectrometry files to reproducible, comparative analyses of plant chemical diversity.
Find more details at
our webpage
.
The major toolboxes of eCOMET are as follows:
Installation
You can install the development version of ecomet from
GitHub
with:
# install.packages("pak")
pak
::
pak
(
"phytoecia/eCOMET"
)
This is a basic example which shows you how to solve a common problem:
library
(
ecomet
)
## basic example code
0. Input files requirements
Following input files are required to run eCOMET. See ‘/raw_data’ of demo files. 1. Feature quantification table generated by MZMine4 (
features.csv
) -This file is generated by [Feature list methods → Export feature list → CSV]. See
https://mzmine.github.io/mzmine_documentation/module_docs/io/feat-list-export.html
2. Annotation of features by SIRIUS (
canopus_formula_summary.tsv
and
structure_identification.tsv
) -These are included in the standard output of SIRIUS. Make sure you run all SIRIUS → ZODIAC → CSI:FingerID → CANOPUS. Then export as tsv. 3. Metadata of samples (
metadata.csv
) -Metadata should have three or more columns; the first three being sample, group, and mass. Additional information can be provided (see Part 9. Regression with metadata). 4. (Optional) Custom annotation of features (‘custom_DB_glucosinolates.csv’) -The custom DB includes three columns: compound, mz, rt 5. (Optional) Chemical similarity table from MZMine 4. The metric can be cosine, DreaMS, and MS2DeepScore (cosine.csv, dreams.csv, and ms2deepscore.csv) -To obtain these data, you need to run molecular networking at MZMine4 for each metric. See
https://mzmine.github.io/mzmine_documentation/module_docs/group_spectral_net/molecular_networking.html
-Set the minimal similarity value as 0 to get all pairwise similarity. -These tables are impoted and processed for heatmap visualization and chemical diversity quantification (see 10. Chemical Diversity Measures)
1. Initializing the MMO object
All input files are imported to construct a
mmo
object. The
mmo
object will be used in downstream statistics.
###
# 1.1. Give directories
mzmine_featuredir
<-
'raw_data/250724_features_ms2.csv'
metadatadir
<-
"raw_data/250728_mmo_metadata.csv"
canopus_formuladir
<-
"raw_data/canopus_formula_summary.tsv"
canopus_structuredir
<-
"raw_data/structure_identifications.tsv"
gls_db
<-
'raw_data/250428_GLS_Ath_simplegrad_MMO.csv'
cos_dir
<-
'raw_data/250728_sim_ms2_(modified)_cosine.csv'
dreams_dir
<-
'raw_data/250728_sim_dreams.csv'
m2ds_dir
<-
'raw_data/250728_sim_ms2deepscore.csv'
First import the mzmine feature list and metadata to create a
mmo
object.
mmo <- GetMZmineFeature(mzmine_featuredir, metadatadir) head(mmo$featre_data)
then add annotation generated from sirius to the object
mmo <- AddSiriusAnnot(mmo, canopus_structuredir, canopus_formuladir) head(mmo$sirius_annot)
Custom annotation can be added based on m/z and RT.
mmo <- AddCustomAnnot(mmo, DB = gls_db, mztol = 5, rttol = 0.1) # Add annotation
then process the quantification data
# Normalize data
mmo
<-
ReplaceZero
(mmo,
method =
'one'
)
# Replace 0 and NA values by 1
mmo
<-
MassNormalization
(mmo)
# Normalize peak area by sample mass in metadata
mmo
<-
MeancenterNormalization
(mmo)
# Add mean-centered area
mmo
<-
LogNormalization
(mmo)
# Add log-transformed area
mmo
<-
ZNormalization
(mmo)
# Add Zscore
The chemical similarity tables are imported then transformed into distance matrix
# Import chemical distance data for chemical diversity analyses mmo <- AddChemDist(mmo, cos_dir = cos_dir, dreams_dir = dreams_dir, m2ds_dir = m2ds_dir)
Check every data are imported well
summary(mmo)
mmo object
The
mmo
object contains following information 1) Feature quantification value (
f
e
a
t
u
r
e
d
a
t
a
)
2
)
M
e
t
a
d
a
t
a
(
feature_data)
2) Metadata (
metadata) 3) Pairwise comparison data (
p
a
i
r
w
i
s
e
)
4
)
L
o
g
,
m
e
a
n
−
c
e
n
t
e
r
e
d
,
a
n
d
Z
−
t
r
a
n
s
f
o
r
m
e
d
f
e
a
t
u
r
e
q
u
a
n
t
i
f
i
c
a
t
i
o
n
v
a
l
u
e
(
pairwise)
4) Log, mean-centered, and Z-transformed feature quantification value (
log,
$meancentered, and #zscore)
5) Sirius annotation ($
sirius_annot) 6) cosine distance (
c
o
s
.
d
i
s
s
i
m
)
7
)
D
r
e
a
M
S
d
i
s
t
a
n
c
e
(
cos.dissim)
7) DreaMS distance (
dreams.dissim) 8) MS2DeepScore distance (m2ds.dissim)
All features have id (from mzmine) and feature (mz_rt generated by GetMZmineFeature()). Both can be interchangable by FeatureToID(mmo, features) and IDToFeature(mmo, IDs).
Annotated features by SIRIUS
Some feature groups may deserve particular interest. For the demo file, glucosinolates and flavonoids are. We can briefly annotate those metabolites using annotation from sirius.
features
<-
mmo
$
sirius_annot
# Get list of glucosinolated using custom annoatation DB
gls_hits
<-
mmo
$
custom_annot
%>%
filter
(
lengths
(custom_annot)
>
0
)
GLSs
<-
gls_hits
%>%
pull
(feature)
# Get list of flavonoids using sirius annotation
FLVs
<-
features
%>%
filter
(
str_detect
(features[[
46
]],
"Flavonoid"
))
%>%
pull
(feature)
2. Summarise using PLS-DA
By using PLS-DA plot, the general distribution of metabolic profile of each sample and group can be visualized. For each group give colors
# Define your custom colors for each group
custom_colors
<-
c
(
"ctrl"
=
"#999999"
,
"sl1"
=
"#fdcdac"
,
"le1"
=
"#b3e2cd"
)
#Or automatically give colors
custom_colors
<-
setNames
(
brewer.pal
(
length
(
unique
(mmo
$
metadata
$
group)),
"Set3"
),
unique
(mmo
$
metadata
$
group))
Then plot PLS-DA
PLSDAplot
(mmo,
color =
custom_colors,
outdir =
'plots/plsda/PLSDA_Z.pdf'
,
normalization =
'Z'
)
PLSDAplot
(mmo,
color =
custom_colors,
topk =
0
,
outdir =
'plots/plsda/PLSDA_Z_noLoadings.pdf'
,
normalization =
'Z'
)
The
topk
parameter can be adjusted to plot loadings of top features on the plot. The
normalization
can be
None
,
Log
,
Meancentered
, and
Z
. If a subset of features are to be used for ploting, set
filter_feature = TRUE
then provide the list of features to the
feature_list
If a subset of groups are to be plotted, set ‘filter_group = TRUE’ then provide the list of groups to the group_list.
# Glucosinolates only
PLSDAplot
(mmo, custom_colors,
topk =
0
,
outdir =
'plots/plsda_GLS.pdf'
,
normalization =
'Z'
,
filter_feature =
TRUE
,
feature_list =
GLSs)
3. Pairwise Comparison (DAMs)
Many analyses targets to find
Differentially Accumulated Metabolites (DAMs)
. DAMs can be defined by thresholds of log2-fold change and adjusted p-value. Those two metrics are calculated by following code. Note that the divisor group is at the left.
# 3.1. Add pairwise comparisons mmo <- PairwiseComp(mmo, 'ctrl', 'sl1') mmo <- PairwiseComp(mmo, 'ctrl', 'le1')
Then DAMs of each comparison can be extracted.
# 3.2. Get DAMs from the comparisons
DAMs
<-
GetDAMs
(mmo,
fc_cutoff =
0.5849625
,
pval_cutoff =
0.1
)
# log2(1.5) = 0.5849625
DAMs_up
<-
DAMs
$
DAMs_up
DAMs_down
<-
DAMs
$
DAMs_down
head
(DAMs_up)
The cutoffs for DAMs can be adjusted in the GetDAMs function
4. Upset and Venn Diagram
How many features are overlapping and specific are the common questions following DAM analysis. It can be visualized by UpSet plot and Venn diagram. The inputs for both are identical and can be prepared as following
# 4.1. Define groups
VennInput
<-
list
(
sl1.up =
DAMs_up
$
ctrl_vs_sl1.up,
le1.up =
DAMs_up
$
ctrl_vs_le1.up
)
Then can be plotted as following
# 4.2. Plot
# 4.2.1. Venn Diagram
ggvenn
(VennInput,
stroke_size =
0.5
,
set_name_size =
4
,
show_percentage =
FALSE
)
+
theme
(
legend.position =
"none"
)
ggsave
(
"plots/Venn/Venn_Upreg.pdf"
,
height =
5
,
width =
5
)
# 4.2.2. Upset plot
pdf
(
"plots/Venn/Upset_Upreg.pdf"
,
7
,
5
)
upset
(
fromList
(VennInput),
nsets=
10
,
nintersects=
20
,
order.by=
'freq'
,
mainbar.y.label=
'Features in Set'
,
line.size=
1
,
point.size=
4
,
shade.color=
'white'
,
text.scale=
1
,
show.numbers=
FALSE
)
dev.off
()
5. Volcano plot
The pairwise comparion can be visualized by a volcano plot. Following code generates volcano plots for all comparison made in section 3.
comparison_columns
<-
colnames
(mmo
$
pairwise)
log2FC_columns
<-
grep
(
"log2FC"
, comparison_columns,
value =
TRUE
)
comparisons
<-
sub
(
"_$"
,
""
,
unique
(
sub
(
"log2FC"
,
""
, log2FC_columns)))
# Remove trailing underscore from comparisons
for
(comp
in
comparisons){
VolcanoPlot
(mmo,
comp =
comp,
topk =
10
,
outdir =
paste
(
'plots/volcano/volcano_'
, comp,
'.pdf'
,
sep =
''
))
}
6. Heat Map
A heatmap is a great way to visualize the whole metabolome. Typically the features are clustered by the distribution pattern but alternatively the chemical similarity between features can be visualized. For heatmap, required inputs can be generated from mmo as follows:
# 6.1. Generate inputs for heat map
HMinput
<-
GenerateHeatmapInputs
(mmo,
filter_feature =
FALSE
,
feature_list =
feature_list,
filter_group =
FALSE
,
group_list =
group_list,
summarize =
'mean'
,
control_group =
'ctrl'
,
normalization =
'Z'
,
distance =
'dreams'
)
summary
(HMinput)
Where filter_feature and filter_group can be used on desire. The ‘summarize’ argument can be ‘mean’ or ‘fold_change’. If ‘fold_change’ is used, the ‘control_group’ should be noted. If the chemical similarities are to be plotted, the distance metric to be used should be designated in ‘distance’ as one of dreams, cosine, or m2ds. Then the class-level annotation table is generated.
# 6.2. Generate NPC-based annotation table for heatmap
sirius_annot
<-
mmo
$
sirius_annot
# Get NPC Annotations
NPC_pathway
<-
unique
(sirius_annot[[
32
]])
NPC_pathway
<-
NPC_pathway[
!
is.na
(NPC_pathway)
&
NPC_pathway
!=
""
]
# remove NA and empty
NPC_superclass
<-
unique
(sirius_annot[[
34
]])
NPC_superclass
<-
NPC_superclass[
!
is.na
(NPC_superclass)
&
NPC_superclass
!=
""
]
# remove NA and empty
NPC_class
<-
unique
(sirius_annot[[
36
]])
NPC_class
<-
NPC_class[
!
is.na
(NPC_class)
&
NPC_class
!=
""
]
# remove NA and empty
sirius_annot_filtered
<-
sirius_annot
%>%
# select(id = 1, NPC_pathway = 30, NPC_class = 34) %>%
select
(
id =
1
,
NPC_class =
36
,
NPC_superclass =
34
,
NPC_pathway =
32
)
%>%
# select(id = 1, NPC_pathway = 30, NPC_superclass = 32) %>%
filter
(id
%in%
rownames
(distance_matrix))
# get features with fingerprints
rownames
(sirius_annot_filtered)
<-
sirius_annot_filtered
$
id
sirius_annot_filtered
$
id
<-
NULL
ann_colors
=
list
(
NPC_pathway =
setNames
(
brewer.pal
(
length
(NPC_pathway),
"Set2"
), NPC_pathway),
NPC_class =
setNames
(
viridis
(
length
(NPC_class)), NPC_class),
NPC_superclass =
setNames
(
viridis
(
length
(NPC_superclass)), NPC_superclass)
)
The ann_colors will be plotted along with the heapmap to show which chemical class each features are included in. The heatmap can be visualized as follows:
pdf
(
"plots/heatmap/dreams_total_Z.pdf"
,
width =
15
,
height =
20
)
pheatmap
(
mat =
HMinput
$
FC_matrix,
cluster_rows =
TRUE
,
#do not change
clustering_distance_rows =
HMinput
$
dist_matrix,
# Delete this line for UPGMA clustering of rows
cluster_cols =
FALSE
,
clustering_method =
"average"
,
#UPGMA
show_rownames =
TRUE
,
show_colnames =
TRUE
,
annotation_row =
sirius_annot_filtered,
# Dataframe with the rownames are identical with 'mat' and gives annotation
annotation_colors =
ann_colors,
cellwidth =
25
,
cellheight =
0.05
,
treeheight_row =
100
,
fontsize_row =
3
,
fontsize_col =
15
,
scale =
'none'
,
annotation_names_row =
TRUE
,
#  labels_row = row_label,
border_color =
NA
,
color =
colorRampPalette
(
c
(
"blue"
,
"white"
,
"red"
))(
100
))
dev.off
()
7. Chemical class enrichment analysis
Biological questions ask which class of chemical compounds are enriched in a set of compounds of interest (e.g., DAMs from above). This is analogue to the Gene Ontology enrichment analysis performed in transcriptomics. In MMO, NPC and Classyfire terms annotated by Canopus of SIRIUS are used to perform chemical class enrichment analysis of given list of features. The enrichment score of each term is calculated to plot the number of each term and the significance.
# 7.1. For a single set of features, a detailed enrichment plot can be generated
# There are two plotting styles available
CanopusListEnrichmentPlot
(mmo, DAMs_up
$
ctrl_vs_sl1.up,
pthr =
0.1
,
outdir =
'plots/enrichment/sl1_up.pdf'
,
height =
6
,
width =
6
)
CanopusListEnrichmentPlot_2
(mmo, DAMs_up
$
ctrl_vs_sl1.up,
pthr =
0.1
,
outdir =
'plots/enrichment/sl1_up_2.pdf'
,
topn =
10
,
height =
6
,
width =
6
)
# 7.2. For a list of sets features, a summary enrichment plot can be generated
# The summary enrichment plot can be generated for either a single level of CANOPUS classification (8.2.1) or for all levels (8.2.2)
# 7.2.1. For a single level of CANOPUS classification
term_levels
<-
c
(
'NPC_class'
,
'NPC_superclass'
,
'NPC_pathway'
,
'ClassyFire_most_specific'
,
'ClassyFire_level5'
,
'ClassyFire_subclass'
,
'ClassyFire_class'
,
'ClassyFire_superclass'
)
CanopusLevelEnrichmentPlot
(mmo, DAMs_up,
term_level =
'NPC_class'
,
pthr =
0.1
,
prefix =
'plots/enrichment/DAMs_up_NPC_class.pdf'
)
# 7.2.2. For all levels of CANOPUS classification
# All levels, or onlt NPC or ClassyFire
terms
<-
c
(
'NPC'
,
'ClassyFire'
,
'all_terms'
)
CanopusAllLevelEnrichmentPlot
(mmo, DAMs_up,
term_level =
'all_terms'
,
pthr =
0.1
,
prefix =
'plots/enrichment/DAMs_up_all_terms'
,
width =
8
,
height =
12
)
8. Regression with Metadata
We are interested in finding anti-herbivore resistive compounds from the plant metabolome and testing whether such compounds are upregulated by insect attack. To do so, we first fit linear mixed model to the amount of each feature and the herbivore performance fed on each plant sample (see metadata). The negative effect size of the model represents the resistive value of the feature. We then test whether resistive features are upregulated (log2FC > 1) by plotting the effect size of the LMM and the log2FC as scatter plot. In the demo file, resistive compounds (which have neative effect sizes) were upregulated, which implies plants produce resistive compounds properly in response to sl attack. The analysis can be done as follows:
# To perform regression, the phenotype of interest should be defined in the metadata as a column
# 8.1. Regression of individual feature against a phenotype
# model can be 'lm' or 'pearson' or 'lmm'
# groups can be a vector of group names, or a single group name which has the phenotpye values in the metadata
FeaturePerformanceRegression
(mmo,
target =
'477.0636_7.5687'
,
phenotype =
'sl'
,
groups =
c
(
'sl1'
),
model =
'lm'
,
normalization =
'Z'
,
output =
paste
(
'plots/phenotype_regression/477.0636_7.5687_sl_lm.pdf'
))
# 8.2. Regression of all features against a phenotype and plotting the results
sl.lm
<-
GetPerformanceFeatureRegression
(mmo,
phenotype =
'sl'
,
groups =
c
(
'sl1'
),
DAM.list =
list
(
sl.up =
DAMs_up
$
ctrl_vs_sl1.up,
sl.down =
DAMs_down
$
ctrl_vs_sl1.down),
comparisons =
c
(
'ctrl_vs_sl1'
))
sl.lm.sig
<-
sl.lm
%>%
filter
(p_value
<
0.1
)
head
(sl.lm.sig)
sl.cor
<-
GetPerformanceFeatureCorrelation
(mmo,
phenotype =
'sl'
,
groups =
c
(
'sl1'
),
DAM.list =
list
(
sl.up =
DAMs_up
$
ctrl_vs_sl1.up,
sl.down =
DAMs_down
$
ctrl_vs_sl1.down),
comparisons =
c
(
'ctrl_vs_sl1'
))
sl.cor.sig
<-
sl.cor
%>%
filter
(p_value
<
0.1
)
head
(sl.cor.sig)
# One may want to plot the regression results along with the fold change values
PlotFoldchangeResistanceRegression
(sl.lm.sig,
fold_change =
'ctrl_vs_sl1_log2FC'
,
color =
c
(
'sl.up'
=
'#d42525ff'
,
'sl.down'
=
'#281e99ff'
),
output_dir =
'plots/phenotype_regression/sl_lm_sig.pdf'
)
9. Chemical Diversity Measures
The chemical diversity is one of the key parameters in ecological studies. MMO quantifies the chemical diversity idices using idea from
ChemoDiv
package. The fingerprint distances are treated as phylogenetic diversity as in measuring taxonomic diversity. Alpha diversity can be calculated as following.
# 9.1. Alpha diversity by Hill numbers
# q : Hill number order, 0 for richness, 1 for Shannon, 2 for Simpson
# mode : weighted for the chemical structure (use distance argument), unweighted for no chemical weight
# filter_feature : if TRUE, only features in the feature_list are used
# feature_list : a list of features to filter the alpha diversity calculation
alphadiv
<-
GetAlphaDiversity
(mmo,
q =
3
,
normalization =
'Log'
,
mode =
'weighted'
,
distance =
'dreams'
,
filter_feature =
FALSE
,
feature_list =
NULL
)
# 9.1.1 Plot the alpha diversity
ggplot
(alphadiv,
aes
(
x =
group,
y =
hill_number))
+
geom_boxplot
(
outlier.shape =
NA
)
+
geom_beeswarm
(
size =
0.5
)
+
theme_classic
()
+
labs
(
title =
'Alpha Diversity by Hill Numbers'
,
x =
'Group'
,
y =
'Hill Number'
)
+
theme
(
legend.position =
"none"
,
axis.text.x =
element_text
(
angle =
45
,
vjust =
1
,
hjust=
1
))
ggsave
(
'plots/alphadiv/dreams_q3_log.pdf'
,
width =
5
,
height =
5
)
# Test for significant differences between groups with ANOVA
anova
<-
anova_tukey_dunnett
(alphadiv,
'hill_number ~ group'
)
write_anova
(anova,
'plots/alphadiv/anova_hill_number.csv'
)
# 9.1.2 Plot the feature distribution
# Function to plot histogram of values for each feature for given groups
groups
<-
c
(
'ctrl'
,
'sl1'
,
'le1'
)
group.mean
<-
GetGroupMeans
(mmo,
normalization =
'Z'
,
filter_feature =
FALSE
,
feature_list =
NULL
)[,
-
1
]
long.group.mean
<-
data.frame
(
value =
double
(),
group =
character
())
for
(group
in
groups) {
group_data
<-
data.frame
(
value =
group.mean[, group],
group =
group)
colnames
(group_data)
<-
c
(
'value'
,
'group'
)
long.group.mean
<-
rbind
(long.group.mean, group_data)
}
ggplot
(
data =
long.group.mean,
aes
(
x =
value,
fill =
group,
color =
group))
+
geom_density
(
position =
'identity'
,
alpha =
0
)
+
theme_classic
()
+
labs
(
x =
"Normalized peak intensity"
,
y =
"Density"
)
+
# scale_fill_manual(values = custom_colors) +
theme
(
legend.position =
"right"
)
ggsave
(
'plots/alphadiv/density_function_Z.pdf'
,
height =
6
,
width =
6
)
metadata
<-
mmo
$
metadata
feature
<-
mmo
$
zscore
# The distribution should be shown!
plot_data
<-
data.frame
(
value =
double
(),
rank =
double
(),
sample =
character
(),
group =
character
())
for
(group
in
groups) {
group_samples
<-
metadata
%>%
filter
(group
==
!!
group)
%>%
pull
(sample)
for
(sample
in
group_samples) {
sample_data
<-
unlist
(
as.vector
(feature[, sample]))
sorted_data
<-
sort
(sample_data,
decreasing =
TRUE
)
sample_plot_data
<-
data.frame
(
value =
sorted_data,
rank =
seq_along
(sorted_data),
group =
group,
sample =
sample)
plot_data
<-
rbind
(plot_data, sample_plot_data)
}
}
ggplot
(plot_data,
aes
(
x =
rank,
y =
value,
color =
group))
+
stat_summary
(
fun.data =
mean_se,
geom =
"errorbar"
,
width =
0.2
,
position =
position_dodge
(
width =
0.5
),
alpha =
0.06
)
+
stat_summary
(
fun =
mean,
geom =
"line"
,
position =
position_dodge
(
width =
0.5
))
+
theme_classic
()
+
labs
(
title =
"Sorted Feature"
,
x =
"Rank"
,
y =
"Value"
)
ggsave
(
'plots/alphadiv/sorted_intensity_Z.png'
,
height =
6
,
width =
6
)
# 9.2. Beta diversity
# Calculate beta diversity for different normalizations and methods
# For unweighted beta diversity, Bray-Curtis or Jaccard distance can be used
bray
<-
GetBetaDiversity
(mmo,
method =
'bray'
,
normalization =
'Log'
,
filter_feature =
FALSE
,
feature_list =
NULL
)
jaccard
<-
GetBetaDiversity
(mmo,
method =
'jaccard'
,
normalization =
'Log'
,
filter_feature =
FALSE
,
feature_list =
NULL
)
# For weighted beta diversity, Generalized UniFrac can be used
guni
<-
GetBetaDiversity
(mmo,
method =
'Gen.Uni'
,
normalization =
'Log'
,
distance =
'dreams'
,
filter_feature =
FALSE
,
feature_list =
NULL
)
guni
.0
<-
guni[,,
'd_0'
]
# GUniFrac with alpha 0
guni
.05
<-
guni[,,
'd_0.5'
]
# GUniFrac with alpha 0.5
guni
.1
<-
guni[,,
'd_1'
]
# GUniFrac with alpha 1
# 9.2.1. NMDS plots for beta diversity
nmds
<-
metaMDS
(guni
.05
,
k =
2
,
try =
50
,
trymax =
100
)
nmds_coords
<-
as.data.frame
(
scores
(nmds))
groups
<-
c
()
for
(col
in
colnames
(mmo
$
feature_data)[
-
c
(
1
,
2
)]) {
groups
<-
append
(groups, metadata[metadata
$
sample
==
col, ]
$
group)
}
nmds_coords
$
group
<-
groups
ggplot
(nmds_coords,
aes
(
x =
NMDS1,
y =
NMDS2,
color =
group))
+
geom_point
(
size =
3
)
+
#geom_text_repel(aes(label = group), size = 3) +
theme_classic
()
+
stat_ellipse
(
level =
0.90
)
+
labs
(
x =
"NMDS1"
,
y =
"NMDS2"
)
+
theme
(
legend.position =
"right"
)
ggsave
(
'plots/betadiv/NDMS_guni05.pdf'
,
height =
6
,
width =
6
)
# 9.2.2. Quantification of beta diversity
group_distances
<-
CalculateGroupBetaDistance
(mmo,
beta_div =
guni
.05
,
reference_group =
'ctrl'
,
groups =
c
(
'le1'
,
'sl1'
))
ggplot
(group_distances,
aes
(
x =
group,
y =
distance))
+
geom_boxplot
(
outlier.shape =
NA
)
+
geom_beeswarm
(
size =
0.5
)
+
theme_classic
()
+
labs
(
x =
"Group"
,
y =
"Beta Diversity"
)
ggsave
(
'plots/betadiv/group_dist.pdf'
,
height =
6
,
width =
6
)
10. Exporting compounds of interest
ExportFeaturesToCSV(mmo, feature_list = DAMs_up$ctrl_vs_sl1.up, normalization = 'None', output_dir = 'output/sl1_up_features.csv')


============================================================
## Package index
Source: https://phytoecia.github.io/eCOMET/reference/index.html
============================================================

Package index
Core dataset processing
GetMZmineFeature()
Import MZmine feature table and metadata to create a mmo object
AddSiriusAnnot()
Adding annotation from SIRIUS to the mmo object
AddChemDist()
Add chemical distance matrices to the mmo object
AddCustomAnnot()
Add custom annotations to an mmo object
LogNormalization()
Log-normalize the peak area in the mmo object
MassNormalization()
Use sample mass in the metadata file to normalize the peak area
MeancenterNormalization()
Mean-center the peak area in the mmo object
ZNormalization()
Z-normalize the peak area in the mmo object
ReplaceZero()
Replace zero and NA values in the mmo object
ReorderGroups()
Reorder samples in the mmo object based on group order
SwitchGroup()
Switch the group column in the mmo object
FeaturePresence()
Convert feature abundances to presence / absence
Filterng MMO and associated MGF
filter_mmo()
Filter an mmo object by samples, groups, and/or features
filter_mgf_to_mmo()
Filter an MGF file to keep only spectra for features present in mmo$feature_data$id
annotate_feature_info_ms2_from_mgf()
Annotate mmo$feature_info with MS2 presence and MS2 block counts from an MGF
filter_canopus_annotations()
Filter CANOPUS / SIRIUS annotations in an ecomet mmo object by probability threshold
filter_cosmic_structure()
Filter SIRIUS structure (CSI:FingerID) annotations by COSMIC confidence score
Basic statistics and visualization
PairwiseComp()
Perform pairwise comparison between two groups in the mmo object
VolcanoPlot()
Volcano plot for visualizing differential metabolite analysis results
PCAplot()
Plots PCA and performs PERMANOVA
PLSDAplot()
PLS-DA plot with feature loadings
AnovaBarPlot()
Generate barplots for each feature and perform ANOVA
GenerateHeatmapInputs()
Generate input files to be used for pheatmap from the mmo object
GetDAMs()
Generates lists of DAMs (Differentially Accumulated Metabolites) for each comparison in the mmo object
GetGroupMeans()
Calculate group means from the mmo object
GetLog2FoldChange()
Calculate log2 fold change for a given control group
HCplot()
HCplot
Chemical class analysis
CanopusLevelEnrichmentAnal()
Enrichment analysis for Canopus-predicted terms
CanopusListEnrichmentPlot()
Generate a plot for enrichment analysis of Canopus-predicted terms
CanopusListEnrichmentPlot_2()
Generate a plot for enrichment analysis of Canopus-predicted terms across multiple levels
CanopusLevelEnrichmentPlot()
Generate a plot for enrichment analysis of Canopus-predicted terms at a specific level using a list of vectors of features
CanopusAllLevelEnrichmentPlot()
Generate a plot for enrichment analysis of Canopus-predicted terms across all levels
MSEA()
Metabolite Set Enrichment Analysis (MSEA)
Chemical diversity Analysis
GetRichness()
GetRichness
GetAlphaDiversity()
GetAlphaDiversity
GetFunctionalHillNumber()
GetFunctionalHillNumber
GetHillNumbers()
GetHillNumbers
GetBetaDiversity()
GetBetaDiversity
NMDSplot()
NMDSplot
PCoAplot()
PCoAplot
CalculateGroupBetaDistance()
CalculateGroupBetaDistance
GetSpecializationIndex()
GetSpecializationIndex
PlotNPCStackedBar()
PlotNPCStackedBar
BootCumulRichnessAUC()
BootCumulRichnessAUC
BootstrapCumulativeRichness()
BootstrapCumulativeRichness
CalcNormalizedAUC()
CalcNormalizedAUC
CalculateCumulativeRichness()
CalculateCumulativeRichness
CalculateNullCumulativeRichness()
CalculateNullCumulativeRichness
Metadata regression analysis
FeaturePhenotypeCorrelation()
FeaturePhenotypeCorrelation
ScreenFeaturePhenotypeCorrelation()
Screen feature-phenotype correlation
GetPerformanceFeatureCorrelation()
GetPerformanceFeatureCorrelation
GetPerformanceFeatureLMM()
GetPerformanceFeatureLMM
GetPerformanceFeatureRegression()
GetPerformanceFeatureRegression
PlotFoldchangeResistanceQuad()
PlotFoldchangeResistanceQuad
PlotFoldchangeResistanceRegression()
PlotFoldchangeResistanceRegression
PlotFoldchangeResistanceRegression_t()
PlotFoldchangeResistanceRegression_t
Output
ExportFeaturesToCSV()
ExportFeaturesToCSV
SaveMMO()
Save entire mmo object to a file (RDS)
LoadMMO()
Load an mmo object previously saved with SaveMMO
misc
FeatureToID()
Convert feature names to IDs in the mmo object
IDToFeature()
Convert feature IDs to names in the mmo object
anova_tukey_dunnett()
Perform ANOVA and Tukey's HSD test on the mmo object
write_anova()
Write results of anova_tukey_dunnett to a CSV file
permanova_stat()
Perform PERMANOVA and pairwise comparisons
GetDistanceMat()
Get the distance matrix from the mmo object based on the specified distance metric
GetNormFeature()
Retrieve feature data from the mmo object, with normalization options
filter_mmo()
Filter an mmo object by samples, groups, and/or features
print(
<mmo>
)
Print method for mmo objects Provides a clean, human-readable overview of an
mmo
list object instead of dumping the entire list when the object is printed in the console.


============================================================
## Articles
Source: https://phytoecia.github.io/eCOMET/articles/index.html
============================================================

Articles
Tutorials
eCOMET-intro
Treatment-based_study_tutorial


============================================================
## Treatment-based_study_tutorial
Source: https://phytoecia.github.io/eCOMET/articles/Treatment-based_study_tutorial.html
============================================================

Treatment-based_study_tutorial
2026-01-26
Treatment-based_study_tutorial.Rmd
#install.packages("pak")
#pak::pkg_install("Phytoecia/eCOMET", dependencies = TRUE)
#pak::pkg_install("Phytoecia/eCOMET", dependencies = TRUE, upgrade = TRUE)
library
(
ecomet
)
library
(
dplyr
)
#>
#> Attaching package: 'dplyr'
#> The following objects are masked from 'package:stats':
#>
#>     filter, lag
#> The following objects are masked from 'package:base':
#>
#>     intersect, setdiff, setequal, union
library
(
stringr
)
library
(
here
)
#> here() starts at /Users/dlforrister/Library/CloudStorage/OneDrive-SmithsonianInstitution/One_Drive_BackUps_Local_Mac_Files/CODE_GIT_HUB_2017_Aug_31/eCOMET
here
(
)
#> [1] "/Users/dlforrister/Library/CloudStorage/OneDrive-SmithsonianInstitution/One_Drive_BackUps_Local_Mac_Files/CODE_GIT_HUB_2017_Aug_31/eCOMET"
Background
In this tutorial, we will demonstrate how to use the
eCOMET
package for analyzing metabolomics data from a
treatment-based study.
Treatment-based studies involve comparing metabolite profiles
between different treatment groups (e.g., control vs treated).
The tutorial covers data preprocessing, normalization,
statistical analysis, and visualization techniques commonly used in
treatment-based metabolomics studies.
The tutorial files are metabolomics analysis files of
Arabidopsis thaliana
(Col-0) attacked by two different
herbivores (
Spodoptera litura
; sl, and
Lipaphis
erysimi
; le).
Eight replicates were sampled and analyzed for each group. See
metadata.csv for more details.
Tutorial data
eCOMET is distributed with a small set of example data files that are
installed automatically with the package. These files are included
specifically so that the tutorials can be run immediately, without
downloading additional data or setting file paths by hand.
The example datasets represent simplified versions of the feature
tables, metadata, and annotation outputs used in a typical eCOMET
analysis workflow. They are meant for demonstration and testing, not as
complete research datasets.
Step 1: Gathering the paths for MMO object inputs.
To generate an mmo object you need to supply at minimum:
feature abundance table from mzmine. It is best to export the
“full feature table” which provides the maximum amount of information
regarding the abundance in each sample as well as feature information
(i.e mass to charge (m/z) and retention time)
path to sample meta data. You need to identify the two columns in
the metdata:
group column that can be used as the main group for
comparisons
sample column which defines the name or path of the sample
columns.
Optionally you can provide:
sirius outputs
ms/ms similarity based on cosine, ms2deep score OR
dreams.
# Locate tutorial data shipped with the eCOMET package
data_dir
<-
system.file
(
"extdata/tutorials/treatment_based"
,
package
=
"ecomet"
)
stopifnot
(
nzchar
(
data_dir
)
)
# fail loudly if package/data not installed
# Define file paths
demo_feature
<-
file.path
(
data_dir
,
"feature_table_demo.csv"
)
demo_metadata
<-
file.path
(
data_dir
,
"metadata_demo.csv"
)
demo_sirius_formula
<-
file.path
(
data_dir
,
"canopus_formula_summary.tsv"
)
demo_sirius_structure
<-
file.path
(
data_dir
,
"structure_identifications.tsv"
)
demo_dreams
<-
file.path
(
data_dir
,
"dreams_sim_demo.csv"
)
gls_db
<-
file.path
(
data_dir
,
"custom_DB_glucosinolates.csv"
)
1. Create an
mmo
object
Following steps are performed to create an
mmo
object
and add various normalizations and annotations. Inspect the structure of
the ‘mmo’ object using ‘summary(mmo)’’ after each step to see how the
object is updated.
# Initialize eCOMET object
mmo
<-
GetMZmineFeature
(
mzmine_dir
=
demo_feature
, metadata_dir
=
demo_metadata
, group_col
=
'group'
, sample_col
=
'sample'
)
mmo
$
feature_data
mmo
$
feature_info
mmo
$
pairwise
mmo
$
metadata
#MS - I discussed this with Sedio Group and everyone things the
feature table to be appended to list not replace… #Can we adjust to
address this?? At the very least we want to discuss when to apply
this.
#Add explanation of why we would replace zero how it will impact
downstream calculations (i.e valcano plots vs richness calculations)
mmo
<-
ReplaceZero
(
mmo
, method
=
'one'
)
# Replace 0 and NA values by 1
mmo
$
feature_data
#MS-same don’t replace add #annotate exactly how Mass is Normalized
and how it knows what column to use
mmo
<-
MassNormalization
(
mmo
)
# Normalize peak area by sample mass in metadata
mmo
$
feature_data
#Can you add a little more annotation here and in the
help/documentation to explain what meancenter normalization works? Sedio
group had questions.
#ecoMET offers the following types of normalization each will append
a new feature_abundance matrix to the mmo object and can be called when
plotting.
mmo
<-
MeancenterNormalization
(
mmo
)
# Add mean-centered area
mmo
<-
LogNormalization
(
mmo
)
# Add log-transformed area
mmo
<-
ZNormalization
(
mmo
)
# Add Zscore
You can also convert the feature abundance matrix to a presence
absence matrix based on a threshold using the function
FeaturePresence
mmo
<-
FeaturePresence
(
mmo
, threshold
=
1
)
# Add Zscore
MS-I am still getting duplicates and it gives a warning. We should
address this in the tutorial but also did I lose the fix you implemented
to handle the duplicates?
# Add SIRIUS annotation
mmo
<-
AddSiriusAnnot
(
mmo
, canopus_structuredir
=
demo_sirius_structure
, canopus_formuladir
=
demo_sirius_formula
)
mmo
$
sirius_annot
#Need to explain how to handle duplicates!
MS- There are still duplicates. Do you know how to exclude them and
how to handle it? If duplicates appear in the tutorial we need to at
least explain what’s going on here…
We can filter sirius annotations based on confidence score. We can do
this both for the probabilities in the canopus class predictions and/or
to the formula/smiles predictions.
Starting with the class predictions we can use the
filter_canopus_annotations() function
We define what pathway levels we want to filter: i.e. pathway_level =
“NPC#pathway”, “All” or “All_NPC” You can also provide a list of
columns.. c(“NPC#superclass”,“NPC#class”)
Define a threshold cut of i.e. threshold = 0.9
The function will add a new annotation list to the mmo object and a
suffex can be added to note what settings were used - suffix =
“NPC_pathway_0.9”
Sirius provides some info on how to set this threshold -
The relevant warning for this threshold is here:
https://v6.docs.sirius-ms.io/methods-background/#CANOPUS
“Be aware that there is no universally accepted threshold to classify
predictions as “good” or “bad.” The posterior probability estimates
provided do not adhere to a fixed standard, and while a binary
classifier might suggest a threshold of 0.5, this is not always
sufficient in real-world applications. If a user desires more nuanced
classifications, such as “Yes,” “No,” and “Maybe,” thresholds like 0.15
and 0.85 may be helpful, although these are just approximations.
Moreover, for statistical analysis, such as determining the number of
occurrences of a specific compound class in a sample, users can sum up
the probabilities to get an expected count. It’s also important to
consider that when a compound is significantly different from known
compounds, CANOPUS may return lower probabilities for all compound
classes, which means users might need to accept predictions with
probabilities below 0.5 depending on their specific needs. Thus, the
choice of threshold depends on the context and the user’s tolerance for
uncertainty.”
It can be helpful to visialize the distribution of thresholds to see
how much you would be filtering out
hist
(
mmo
$
sirius_annot
$
`NPC#pathway Probability`
)
Here we see that there is a long tail of low confidence values. In
this tutorial we will filter these out just as one example.
mmo
<-
filter_canopus_annotations
(
mmo
, pathway_level
=
"NPC#pathway"
, threshold
=
0.8
,suffix
=
"NPC_pathway_0.8"
,overwrite
=
T
)
mmo
$
sirius_annot_filtered_NPC_pathway_0.8
A similar logic can be applied to filter the smiles confidence
In order to filter sequentially we have to define what
Sirius_annotation filter we want to apply this too setting input
See the documentation for details about this score!
https://v6.docs.sirius-ms.io/methods-background/#CANOPUS
More details in this paper:
https://www.nature.com/articles/s41587-021-01045-9
“Interpretation of COSMIC confidence values: COSMIC confidence scores
should be interpreted with caution. It’s crucial to understand that
these scores are not probabilities and, therefore, do not have a direct
statistical interpretation. When performing large-scale analyses, it’s
advisable to focus on the highest-confidence hits (e.g., the top
1/5/10%), generally independent of their specific confidence value.”
#Replace -Infinity w/ 0
mmo
$
sirius_annot_filtered_NPC_pathway_0.8
$
ConfidenceScoreApproximate
[
which
(
mmo
$
sirius_annot_filtered_NPC_pathway_0.8
$
ConfidenceScoreApproximate
==
"-Infinity"
)
]
<-
0
Cosmic_Scores
<-
as.numeric
(
mmo
$
sirius_annot_filtered_NPC_pathway_0.8
$
ConfidenceScoreApproximate
)
hist
(
Cosmic_Scores
, main
=
"Cosmic Confidence Score for Structures"
)
We can see the distribution of scores very different than in the
class probabilities.
To get the top 10% of hits
quantile
(
x
=
Cosmic_Scores
,probs
=
0.9
,na.rm
=
T
)
mmo
<-
filter_cosmic_structure
(
mmo
,
input
=
"sirius_annot_filtered_NPC_pathway_0.8"
,
cosmic_mode
=
"approx"
,
threshold
=
0.3892
,
suffix
=
"CANOPUS_0.9__COSMIC_Top_10"
)
Make a vector of flavonoids using SIRIUS annotation
FLVs_features
<-
mmo
$
sirius_annot
%>%
filter
(
str_detect
(
mmo
$
sirius_annot
[[
'ClassyFire#most specific class'
]
]
,
"Flavonoid"
)
)
%>%
pull
(
feature
)
FLVs_features
# Add custom annotation using inhouse glucosinolate library
mmo
<-
AddCustomAnnot
(
mmo
, DB
=
gls_db
, mztol
=
5
, rttol
=
0.2
)
# Make a vector of glucosinolates using custom annotation
GLSs
<-
mmo
$
custom_annot
%>%
filter
(
lengths
(
custom_annot
)
>
0
)
%>%
pull
(
feature
)
GLSs
# Add Dreams distance
mmo
<-
AddChemDist
(
mmo
, dreams_dir
=
demo_dreams
)
mmo
$
dreams.dissim
[
1
:
10
,
1
:
10
]
2. Plot dimensionality reduction plots
PCA plot and PERMANOVA
A PCA plot is commonly used to visualize the overall distribution of
groups. Following PERMANOVA test can be performed to check if the groups
are significantly different.
PCAplot()
function use mmo to
perform PCA, plot them, and perform PERMANOVA test.
MS - I think that we should explain the logic of how to either save
the output directly OR how to return the obect. Did you set it up so
that if an outdir is provided it will save otherwise it will just
return? I would start with returning the obect and showing the format of
the output/plot Then showing how you can add your own astetics and
resave…
# Set colors for groups
colors
<-
c
(
"ctrl"
=
"grey"
,
"sl1"
=
"#fdcdac"
,
"le1"
=
"#b3e2cd"
)
# PCA plot
# A plot and permanova output files will be generated in the specified outdir
PCAplot
(
mmo
, color
=
colors
, outdir
=
'plot/PCA'
)
PCAplot
(
mmo
, color
=
colors
, outdir
=
'plot/PCA_log'
, label
=
FALSE
, normalization
=
'Log'
)
# Data normalization option
PCAplot
(
mmo
, color
=
colors
, outdir
=
'plot/PCA_FLV'
, label
=
FALSE
, filter_feature
=
TRUE
, feature_list
=
FLVs
)
# Feature filtering option
Alternatively, you can use the output of PCAplot to generate plot
with your own aesthetics.
# Get PCA plot inputs
pca_res
<-
PCAplot
(
mmo
, color
=
colors
, outdir
=
'plot/PCA'
)
# Generate plot with your own aesthetics
pdf
(
"plot/PCA.pdf"
, width
=
10
, height
=
10
)
ggplot
(
pca_res
$
df
,
aes
(
x
=
PC1
, y
=
PC2
, color
=
group
)
)
+
geom_point
(
size
=
2
)
+
theme_minimal
(
)
+
labs
(
title
=
"PCA plot"
, x
=
"PC1"
, y
=
"PC2"
)
dev.off
(
)
Likewise, all plot-generating functions in eCOMET return a list of
dataframes and other objects that can be used to generate plots with
your own aesthetics. Use
summary(pca_res)
to see the
structure of the output and try this for other plot-generating
functions. ### PLS-DA plot
# Plot PLS-DA
PLSDAplot
(
mmo
, color
=
colors
, outdir
=
'plot/PLSDA.pdf'
)
PLSDAplot
(
mmo
, color
=
colors
, outdir
=
'plot/PLSDA_meancentered.pdf'
, normalization
=
'Meancentered'
)
# Data normalization option
3. Identify differentially accumulated metabolites (DAMs)
Many analyses targets to find
Differentially Accumulated
Metabolites (DAMs)
. DAMs can be defined by thresholds of
log2-fold change and adjusted p-value. Those two metrics are calculated
by following code. Note that the divisor group is at the left. -
PairwiseComp()
function performs pairwise comparison
between two groups using t-test and fold change. The results are stored
in mmo$pairwise_comp. -
GetDAMs()
function extracts DAMs
based on user-defined cutoffs for p-value and fold change. - Here, we
compare each herbivore treatment group (sl1 and le1) to the control
group (ctrl). - Log2(1.5) = 0.5849625 is used as fold change cutoff and
0.1 as p-value cutoff to extract more DAMs
# Run pairwise comparison
mmo
<-
PairwiseComp
(
mmo
, group1
=
'ctrl'
, group2
=
'sl1'
)
mmo
<-
PairwiseComp
(
mmo
, group1
=
'ctrl'
, group2
=
'le1'
)
# Extract DAMs
DAMs
<-
GetDAMs
(
mmo
, fc_cutoff
=
0.5849625
, pval_cutoff
=
0.1
)
# log2(1.5) = 0.5849625
DAMs_up
<-
DAMs
$
DAMs_up
DAMs_down
<-
DAMs
$
DAMs_down
head
(
DAMs_up
)
3.1. Volcano plot
A volcano plot can be used to visualize the overall distribution of
features based on fold change and p-value.
# Volcano plot
VolcanoPlot
(
mmo
, comp
=
'ctrl_vs_sl1'
, outdir
=
'plot/Volcano_ctrl_vs_sl1.pdf'
)
VolcanoPlot
(
mmo
, comp
=
'ctrl_vs_le1'
, outdir
=
'plot/Volcano_ctrl_vs_le1.pdf'
, topk
=
0
)
# Remove label by setting topk = 0
3.2. Venn diagram and upset plot
A Venn diagram or upset plot can be used to visualize the overlap of
DAMs between different comparisons.
# Define input list
VennInput
<-
list
(
sl1.up
=
DAMs_up
$
ctrl_vs_sl1.up
,
le1.up
=
DAMs_up
$
ctrl_vs_le1.up
)
# Venn diagram
require
(
ggvenn
)
library
(
ggvenn
)
ggvenn
(
VennInput
, stroke_size
=
0.5
, set_name_size
=
4
, show_percentage
=
FALSE
)
+
theme
(
legend.position
=
"none"
)
ggsave
(
"plot/Venn_Upreg.pdf"
, height
=
5
, width
=
5
)
# UpSet plot
require
(
UpSetR
)
library
(
UpSetR
)
pdf
(
"plot/Upset_Upreg.pdf"
,
7
,
5
)
upset
(
fromList
(
VennInput
)
, nsets
=
10
, nintersects
=
20
,order.by
=
'freq'
, mainbar.y.label
=
'Features in Set'
, line.size
=
1
, point.size
=
4
, shade.color
=
'white'
, text.scale
=
1
, show.numbers
=
FALSE
)
dev.off
(
)
4. Heatmap
To visualize the relative abundance of features across samples, a
heatmap can be generated. The features can be either clusterd using
hierarchical clustering or by chemical distances (e.g., Dreams
distance), following idea of Qemistree (Tripathi et al., 2021, Nat Chem.
Biol.).
The input matrix for heatmap can be either fold change between each
treatment and control or mean normalized values across samples.
Various normalizations can be used (None, Log, Meancentered, and
Z).
Groups or features can be filtered by setting ‘filter_group’ or
‘filter_feature’ to TRUE and providing a list of groups or
features.
The input data for the heatmap is generated by
‘GenerateHeatmapInputs()’ function, then the heatmap is plotted using
‘pheatmap’ package.
library
(
pheatmap
)
# Generate input for heatmap
# distance is one of the chemical distance (cosine, m2ds, and dreams) for clustering rows
# The values can be either fold_change or mean (use option 'summarize')
heatmap_inputs
<-
GenerateHeatmapInputs
(
mmo
, summarize
=
'fold_change'
, control_group
=
'ctrl'
,
normalization
=
'None'
, distance
=
'dreams'
)
# This generates fold change matrix between each treatment and control
# The resulting list contains FC_matrix, dist_matrix, row_label, and heatmap_data
# A heatmap can be generated using pheatmap
pdf
(
"plot/Heatmap_FC_dreams.pdf"
, width
=
10
, height
=
10
)
pheatmap
(
mat
=
heatmap_inputs
$
FC_matrix
,
clustering_distance_rows
=
heatmap_inputs
$
dist_matrix
,
clustering_method
=
"average"
,
cellwidth
=
100
,
cellheight
=
0.3
,
treeheight_row
=
100
,
fontsize_row
=
3
,
fontsize_col
=
15
,
scale
=
'none'
)
dev.off
(
)
# Either, you can visualize mean normalized values across samples
heatmap_inputs
<-
GenerateHeatmapInputs
(
mmo
, summarize
=
'mean'
, normalization
=
'Z'
, distance
=
'dreams'
)
# 'clustering_distance_rows' option make the dendrogram follows chemical distances of features.
#  -Delete this option to visualize the heatmap following cannonical clustering
pdf
(
"plot/Heatmap_Mean_Z_clustering.pdf"
, width
=
10
, height
=
10
)
pheatmap
(
mat
=
heatmap_inputs
$
FC_matrix
,
#clustering_distance_rows = heatmap_inputs$dist_matrix,  # Delete this option to visualize the heatmap following cannonical clustering
clustering_method
=
"average"
,
#UPGMA
cellwidth
=
100
,
cellheight
=
0.3
,
treeheight_row
=
100
,
fontsize_row
=
3
,
fontsize_col
=
15
,
scale
=
'none'
)
dev.off
(
)
# Feature filtering option
# Visualize only glucosinolates
# As glucosinolate annotations are stored in mmo$custom_annot (by AddCustomAnnot() function),
# the compound names are stored in heatmap_inputs$row_label and can be used as row names
heatmap_inputs_GLS
<-
GenerateHeatmapInputs
(
mmo
, summarize
=
'mean'
, normalization
=
'Z'
, distance
=
'dreams'
,
filter_feature
=
TRUE
, feature_list
=
GLSs
)
pdf
(
"plot/Heatmap_Mean_Z_GLS.pdf"
, width
=
10
, height
=
10
)
pheatmap
(
mat
=
heatmap_inputs_GLS
$
FC_matrix
,
#clustering_distance_rows = heatmap_inputs_GLS$dist_matrix,  # Delete this option to visualize the heatmap following cannonical clustering
clustering_method
=
"average"
,
#UPGMA
cellwidth
=
100
,
cellheight
=
8
,
treeheight_row
=
100
,
fontsize_row
=
8
,
fontsize_col
=
15
,
scale
=
'none'
,
annotation_names_row
=
TRUE
,
labels_row
=
heatmap_inputs_GLS
$
row_label
)
dev.off
(
)
5. CANOPUS class enrichment analysis
Biological questions ask which class of chemical compounds are
enriched in a set of compounds of interest (e.g., DAMs from above). This
is analogue to the Gene Ontology enrichment analysis performed in
transcriptomics. In MMO, NPC and Classyfire terms annotated by Canopus
of SIRIUS are used to perform chemical class enrichment analysis of
given list of features. The enrichment score of each term is calculated
to plot the number of each term and the significance.
# For a single set of features, a detailed enrichment plot can be generated
# There are two plotting styles available
CanopusListEnrichmentPlot
(
mmo
,
DAMs_up
$
ctrl_vs_sl1.up
, pthr
=
0.1
, outdir
=
'plot/sl1_up_enrichment.pdf'
, height
=
6
, width
=
6
)
CanopusListEnrichmentPlot_2
(
mmo
,
DAMs_up
$
ctrl_vs_sl1.up
, pthr
=
0.1
, outdir
=
'plot/sl1_up_enrichment_2.pdf'
, topn
=
10
, height
=
6
, width
=
6
)
# For a list of sets features, a summary enrichment plot can be generated
# The summary enrichment plot can be generated for either a single level of CANOPUS classification (8.2.1) or for all levels (8.2.2)
# For a single level of CANOPUS classification
term_levels
<-
c
(
'NPC_class'
,
'NPC_superclass'
,
'NPC_pathway'
,
'ClassyFire_most_specific'
,
'ClassyFire_level5'
,
'ClassyFire_subclass'
,
'ClassyFire_class'
,
'ClassyFire_superclass'
)
CanopusLevelEnrichmentPlot
(
mmo
,
DAMs_up
, term_level
=
'NPC_class'
, pthr
=
0.1
, prefix
=
'plot/DAMs_up_NPC_class'
)
# For all levels of CANOPUS classification
# All levels, or only NPC or ClassyFire
CanopusAllLevelEnrichmentPlot
(
mmo
,
DAMs_up
, term_level
=
'NPC'
, pthr
=
0.1
, prefix
=
'plot/DAMs_up_all_terms'
, width
=
8
, height
=
12
)
CanopusAllLevelEnrichmentPlot
(
mmo
,
DAMs_up
, term_level
=
'ClassyFire'
, pthr
=
0.1
, prefix
=
'plot/DAMs_up_all_terms'
, width
=
8
, height
=
12
)
6. Correlation analysis
To find phenotype-linked metabolties, we can use correlation
analysis. In this tutorial, we will use correlation between amount of
each feature and herbivore performance in bioassay to find defense
compounds.
# We will first screen for all features to find whether there is any correlation between amount of each feature and herbivore performance in bioassay
sl_cor
<-
ScreenFeaturePhenotypeCorrelation
(
mmo
, phenotype
=
'sl'
, groups
=
c
(
'sl1'
)
, model
=
'spearman'
, normalization
=
'Z'
)
head
(
sl_cor
)
7. Sharing MMO object
MMO object can be shared with other users by saving it to a file and
loading it from a file.
# Save MMO object
SaveMMO
(
mmo
,
'mmo.RData'
)
# Load MMO object
mmo
<-
LoadMMO
(
'mmo.RData'
)


============================================================
## Changelog
Source: https://phytoecia.github.io/eCOMET/news/index.html
============================================================

Changelog
ecomet (development version)
eCOMET 0.0.0.9000
Initial packaged version from custom functions
Roxygen-formated
eCOMET 0.0.0.9001
Vignettes added
NMDS, PCoA added
eCOMET 0.0.0.9002
Importing functions now deal with mzML, mzXML, and thermo raw files
All plot generating functions now returns a list of the plot and raw data. Saving the outputs are optional.


############################################################
# PART 2: SOURCE CODE
############################################################


============================================================
# eCOMET R PACKAGE SOURCE CODE
# From: https://github.com/Phytoecia/eCOMET
============================================================


## DESCRIPTION
```
Package: ecomet
Title: A Tool for Mass Spectrometry–Based Ecological Metabolomics
Version: 1.0.0
Authors@R: c(
    person("Dale L.", "Forrister", , "dale.forrister@utexas.edu", role = c("aut")),
    person("Min-Soo", "Choi", , "minsoo1012@snu.ac.kr", role = c("aut","cre")))
Description: The ecomet package provides tools for processing and analyzing mass
    spectrometry–based metabolomics data in ecological and evolutionary
    contexts. It establishes a standardized pipeline that integrates MS1
    feature–abundance tables with MS2 spectral similarity to generate
    common data products, including principal component analyses (PCA),
    chemical dendrograms where tips represent compounds, principal
    coordinates analyses (PCoA), and differential expression analyses.
    Unlike existing metabolomics toolkits that focus primarily on
    biomedical or cheminformatics applications, ecomet is designed
    explicitly for ecometabolomics. It emphasizes workflows that link
    metabolomic variation to ecological data, making it easier to move
    from raw mass spectrometry files to reproducible, comparative analyses
    of plant chemical diversity.
License: AGPL-3
Encoding: UTF-8
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.3.3
Imports:
  dplyr,
  tidyr,
  purrr,
  readr,
  ggplot2,
  rlang,
  grid,
  lme4,
  GUniFrac,
  vegan,
  ape,
  ggrepel,
  ggbeeswarm,
  DescTools,
  multcompView,
  caret,
  data.table,
  fgsea,
  pairwiseAdonis,
  ape,
  RColorBrewer,
  colorspace
Suggests:
    testthat (>= 3.0.0),
    knitr,
    rmarkdown,
    here,
    ggvenn,
    pls,
    pheatmap,
    stringr
Remotes:
    pmartinezarbizu/pairwiseAdonis/pairwiseAdonis
URL: https://phytoecia.github.io/eCOMET/
VignetteBuilder: knitr

```


## NAMESPACE
```
# Generated by roxygen2: do not edit by hand

S3method(print,mmo)
export(AddChemDist)
export(AddCustomAnnot)
export(AddSiriusAnnot)
export(AnovaBarPlot)
export(BootCumulRichnessAUC)
export(BootstrapCumulativeRichness)
export(CalcNormalizedAUC)
export(CalculateCumulativeRichness)
export(CalculateGroupBetaDistance)
export(CalculateNullCumulativeRichness)
export(CanopusAllLevelEnrichmentPlot)
export(CanopusLevelEnrichmentAnal)
export(CanopusLevelEnrichmentPlot)
export(CanopusListEnrichmentPlot)
export(CanopusListEnrichmentPlot_2)
export(ExportFeaturesToCSV)
export(FeaturePhenotypeCorrelation)
export(FeaturePresence)
export(FeatureToID)
export(GenerateHeatmapInputs)
export(GetAlphaDiversity)
export(GetBetaDiversity)
export(GetDAMs)
export(GetDistanceMat)
export(GetFunctionalHillNumber)
export(GetGroupMeans)
export(GetHillNumbers)
export(GetLog2FoldChange)
export(GetMZmineFeature)
export(GetNormFeature)
export(GetPerformanceFeatureCorrelation)
export(GetPerformanceFeatureLMM)
export(GetPerformanceFeatureRegression)
export(GetRichness)
export(GetSpecializationIndex)
export(HCplot)
export(IDToFeature)
export(LoadMMO)
export(LogNormalization)
export(MSEA)
export(MassNormalization)
export(MeancenterNormalization)
export(NMDSplot)
export(PCAplot)
export(PCoAplot)
export(PLSDAplot)
export(PairwiseComp)
export(PlotFoldchangeResistanceQuad)
export(PlotFoldchangeResistanceRegression)
export(PlotFoldchangeResistanceRegression_t)
export(PlotNPCStackedBar)
export(ReorderGroups)
export(ReplaceZero)
export(SaveMMO)
export(ScreenFeaturePhenotypeCorrelation)
export(SwitchGroup)
export(VolcanoPlot)
export(ZNormalization)
export(annotate_feature_info_ms2_from_mgf)
export(anova_tukey_dunnett)
export(filter_canopus_annotations)
export(filter_cosmic_structure)
export(filter_mgf_to_mmo)
export(filter_mmo)
export(permanova_stat)
export(write_anova)
importFrom(RColorBrewer,brewer.pal)
importFrom(ape,pcoa)
importFrom(dplyr,across)
importFrom(dplyr,all_of)
importFrom(dplyr,arrange)
importFrom(dplyr,filter)
importFrom(dplyr,group_by)
importFrom(dplyr,left_join)
importFrom(dplyr,mutate)
importFrom(dplyr,n)
importFrom(dplyr,pull)
importFrom(dplyr,select)
importFrom(dplyr,summarise)
importFrom(dplyr,ungroup)
importFrom(ggplot2,aes)
importFrom(ggplot2,annotate)
importFrom(ggplot2,coord_flip)
importFrom(ggplot2,element_text)
importFrom(ggplot2,facet_grid)
importFrom(ggplot2,geom_bar)
importFrom(ggplot2,geom_boxplot)
importFrom(ggplot2,geom_errorbar)
importFrom(ggplot2,geom_hline)
importFrom(ggplot2,geom_point)
importFrom(ggplot2,geom_segment)
importFrom(ggplot2,geom_smooth)
importFrom(ggplot2,geom_text)
importFrom(ggplot2,geom_vline)
importFrom(ggplot2,ggplot)
importFrom(ggplot2,ggsave)
importFrom(ggplot2,ggtitle)
importFrom(ggplot2,guide_legend)
importFrom(ggplot2,guides)
importFrom(ggplot2,labs)
importFrom(ggplot2,position_dodge)
importFrom(ggplot2,position_stack)
importFrom(ggplot2,scale_color_gradient)
importFrom(ggplot2,scale_color_gradient2)
importFrom(ggplot2,scale_color_manual)
importFrom(ggplot2,scale_fill_gradient)
importFrom(ggplot2,scale_fill_manual)
importFrom(ggplot2,scale_size_area)
importFrom(ggplot2,stat_ellipse)
importFrom(ggplot2,theme)
importFrom(ggplot2,theme_classic)
importFrom(ggplot2,theme_minimal)
importFrom(ggplot2,xlab)
importFrom(ggplot2,xlim)
importFrom(ggplot2,ylab)
importFrom(rlang,.data)
importFrom(rlang,sym)
importFrom(stats,TukeyHSD)
importFrom(stats,aov)
importFrom(stats,as.dist)
importFrom(stats,as.formula)
importFrom(stats,binom.test)
importFrom(stats,coef)
importFrom(stats,cor.test)
importFrom(stats,dist)
importFrom(stats,fisher.test)
importFrom(stats,hclust)
importFrom(stats,lm)
importFrom(stats,p.adjust)
importFrom(stats,prcomp)
importFrom(stats,reorder)
importFrom(stats,sd)
importFrom(stats,setNames)
importFrom(stats,t.test)
importFrom(utils,head)
importFrom(utils,read.csv)
importFrom(utils,tail)
importFrom(utils,write.csv)
importFrom(vegan,metaMDS)
importFrom(vegan,scores)

```


## R/250813_eCOMET_build_V2_MC.R
```r
########################################################################################
# Define functions for data import and normalization
########################################################################################
# When this file is sourced directly (outside the package build), make sure the
# internal dependency checker exists so downstream calls to .require_pkg succeed.
if (!exists(".require_pkg", mode = "function")) {
  .require_pkg <- function(pkg) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      stop(pkg, " is required for this function. Install it with install.packages('", pkg, "').", call. = FALSE)
    }
  }
}
#' Import mzmine feature data and metadata to create a mmo object
#' @description
#' This function reads mzmine feature data and metadata from specified directories,
#' to initiate a mmo object containing feature data and metadata
#'
#' Import mzmine feature data and metadata to create a mmo object
#'
#' @param mzmine_dir Path to the mzmine feature data CSV file
#' @param metadata_dir Path to the metadata CSV file (must include sample_col and group_col)
#' @param group_col Column name in the metadata file used for grouping samples together i.e into treatments or species.
#' @param sample_col Column in metadata file used to identify and match individual samples
#' @param mz_col Optional m/z column name (defaults to "mz" or "row m/z")
#' @param rt_col Optional RT column name (defaults to "rt" or "row retention time")
#' @return A mmo object containing the feature data and metadata
#' @export
GetMZmineFeature <- function(mzmine_dir, metadata_dir, group_col, sample_col,
                             mz_col = NULL, rt_col = NULL) {
  mmo <- list()
  data <- read.csv(mzmine_dir, check.names = F,stringsAsFactors = FALSE, na.strings = c("", "NA"))

  metadata <- read.csv(metadata_dir, check.names = F)

  if (missing(group_col) || !(group_col %in% names(metadata)))
    stop("group_col must be provided and exist in the metadata file.")
  if (missing(sample_col) || !(sample_col %in% names(metadata)))
    stop("sample_col must be provided and exist in the metadata file.")

  # --- detect mz / rt (or use overrides) ---
  if (is.null(mz_col))
    mz_col <- if ("mz" %in% names(data)) "mz" else if ("row m/z" %in% names(data)) "row m/z" else stop("No m/z column found.")
  if (is.null(rt_col))
    rt_col <- if ("rt" %in% names(data)) "rt" else if ("row retention time" %in% names(data)) "row retention time" else stop("No RT column found.")

  # --- feature column ---
  data <- data |> dplyr::mutate(feature = paste(.data[[mz_col]], .data[[rt_col]], sep = "_"))

  # --- area columns from EXACT metadata filenames ---
  samples <- trimws(metadata[[sample_col]])                     # e.g., "I1_C1_1.mzML"
  samples_core <- sub("\\.(mzML|mzXML|raw)$", "", samples, ignore.case = TRUE)

  #might need to move this outside the function...
  find_area_columns <- function(data, samples_core, max_distance = 5) {
    colnames_all <- names(data)
    # 1) Core sample names: drop .mzML / .mzXML (case-insensitive)

    # 2) Restrict candidate columns to those that contain "area" (if requested)
    area_idx <- grepl("area", colnames_all, ignore.case = TRUE)
    if (!any(area_idx)) {
      stop("No columns in `data` contain the word 'area' (case-insensitive).")
      }
      candidates <- colnames_all[area_idx]

    # 3) For each sample_core, pick the best fuzzy match among candidates
      strip_wrappers <- function(x) {
        x <- sub("^datafile[:.]", "", x)                               # datafile: or datafile.
        x <- sub("(?i)( Peak area|:area|\\.area)$", "", x, perl = TRUE) # ' Peak area', ':area', '.area'
        x <- sub("(?i)\\.(mzml|mzxml|raw)$", "", x, perl = TRUE)           # trailing .mzML/.mzXML if present
        x
      }
      cand_core <- strip_wrappers(candidates)

      # 4) Fuzzy distances: one big matrix, not a for-loop
      #    rows = samples_core, cols = cand_core
      D <- adist(samples_core, cand_core, ignore.case = TRUE)

      best_idx <- apply(D, 1L, which.min)
      best_d   <- D[cbind(seq_along(samples_core), best_idx)]

      # 5) Enforce a max edit distance to avoid insane matches
      if (any(!is.finite(best_d) | best_d > max_distance)) {
        bad <- samples[!is.finite(best_d) | best_d > max_distance]
        stop(
          "No suitable fuzzy match (within max_distance = ", max_distance,
          ") for these samples: ", paste(bad, collapse = ", ")
        )
      }

      area_cols <- candidates[best_idx]

      # 6) Sanity checks: 1–1 mapping and length match
      if (any(duplicated(area_cols))) {
        dup <- unique(area_cols[duplicated(area_cols)])
        stop(
          "Multiple samples matched the same area column(s): ",
          paste(dup, collapse = ", ")
        )
      }

      if (length(area_cols) != length(samples_core)) {
        stop(
          "Length mismatch: length(samples) = ", length(samples_core),
          " but matched ", length(area_cols), " area columns."
        )
      }
      return(area_cols)
      }

  area_columns <- find_area_columns(data, samples_core, max_distance = 5)
  if (length(area_columns) == 0)
      stop("No area columns matched the EXACT names from metadata[[sample_col]].")

  #make sure areas are treated numerically
  data[area_columns] <- lapply(data[area_columns], function(x) as.numeric(gsub(",", "", x)))

  # --- build feature_df (keep your original layout) ---
  if (!("id" %in% names(data))) {"Stop no feature id column iddentified in the mzmine output"}
  #if (!("id" %in% names(data))) data$id <- seq_len(nrow(data))  # minimal safety
  feature_df <- data |>
    dplyr::select(id, feature, all_of(area_columns)) |>
    dplyr::rename_with(~ samples_core, .cols = all_of(area_columns))
  feature_df$id <- gsub(" ", "", feature_df$id)

  # --- finalize metadata and output ---
  metadata$sample <- samples_core
  metadata$sample_full_exact <- samples
  mmo$feature_data <- feature_df
  mmo$metadata <- metadata
  mmo$pairwise <- data.frame(feature = mmo$feature_data$feature, id = mmo$feature_data$id)
  mmo$metadata$group <- as.factor(mmo$metadata[[group_col]])

  class(mmo) <- "mmo"
  print("MMO object created.")
  print(paste0("Feature number: ", nrow(mmo$feature_data)))
  print(paste0(nrow(mmo$metadata), " samples in ", length(unique(mmo$metadata$group)), " groups"))
  return(mmo)
}

#' Add feature_info to an existing mmo from a full_feature CSV
#'
#' @param mmo An existing mmo list (will be returned with $feature_info added)
#' @param full_feature_csv Path to the MZmine full feature table (CSV)
#' @return The same mmo with mmo$feature_info set
#' @export
AddFeatureInfo <- function(mmo, full_feature_csv) {
  required <- c(
    "id","rt","rt_range:min","rt_range:max","mz","mz_range:min","mz_range:max",
    "feature_group","ion_identities:iin_id","ion_identities:ion_identities"
  )

  ff <- read.csv(full_feature_csv, check.names = FALSE, stringsAsFactors = FALSE)

  missing <- setdiff(required, names(ff))
  if (length(missing)) {
    stop("Missing required columns in full_feature_csv: ",
         paste(missing, collapse = ", "))
  }

  # Keep only the required columns, in order
  mmo$feature_info <- ff[required]
  rownames(mmo$feature_info) <- NULL
  return(mmo)
}



#' Switch the group column in the mmo object
#'
#' @description
#' This function switches the group column in the metadata of the mmo object to a new specified column.
#' The new group column must exist in the metadata file.
#' @param mmo The mmo object
#' @param new_group_col The name of the new group column in the metadata file
#' @return The mmo object with the updated group column
#' @export
#' @examplesIf FALSE
#' mmo <- SwitchGroup(mmo, new_group_col = "genotype")
SwitchGroup <- function(mmo, new_group_col) {
  if (missing(new_group_col) || !(new_group_col %in% colnames(mmo$metadata))) {
    stop("new_group_col must be provided and must exist in the metadata file.")
  }
  mmo$metadata$group <- as.factor(mmo$metadata[[new_group_col]])
  print(paste0('Group column switched to ', new_group_col))
  print(paste0(length(unique(mmo$metadata$group)), ' groups in total'))
  print(paste0('The list of groups are: ', paste(levels(mmo$metadata$group), collapse = ', ')))
  return(mmo)
}

#' Adding annotation from SIRIUS to the mmo object
#'
#' @description
#' This function reads SIRIUS structure identification and formula summary files,
#' and adds the annotations to the mmo object.
#' @param mmo The mmo object
#' @param canopus_structuredir Path to the SIRIUS structure_identification.tsv file
#' @param canopus_formuladir Path to the SIRIUS canopus_formula_summary.tsv file
#' @return The mmo object with SIRIUS annotations added
#' @export
#' @examplesIf FALSE
#' mmo <- AddSiriusAnnot(mmo,
#'  canopus_structuredir = "path/to/structure_identification.tsv",
#'  canopus_formuladir = "path/to/canopus_formula_summary.tsv"
#' )
AddSiriusAnnot <- function(mmo, canopus_structuredir, canopus_formuladir){
  structure_identifications <- readr::read_tsv(canopus_structuredir, show_col_types = FALSE)
  structure_identifications$mappingFeatureId <- gsub(" ", "", structure_identifications$mappingFeatureId)
  canopus_formula_summary <- readr::read_tsv(canopus_formuladir, show_col_types = FALSE)
  canopus_formula_summary$mappingFeatureId <- gsub(" ", "", canopus_formula_summary$mappingFeatureId)
  siriused_ids <- unique(union(structure_identifications$mappingFeatureId, canopus_formula_summary$mappingFeatureId))
  sirius_df <- mmo$feature_data |> dplyr::select(id, feature)
  sirius_df <- sirius_df |>
  left_join(structure_identifications, by = c("id" = "mappingFeatureId"), multiple = "last") |>
  left_join(canopus_formula_summary, by = c("id" = "mappingFeatureId"), multiple = "last")
  mmo$sirius_annot <- sirius_df
  print('SIRIUS annotation added to mmo$sirius_annot')
  print("Duplicated annotation might be occurred in SIRIUS. Inspect the raw data to check the annotation")
  return(mmo)
}

#' Add custom annotations to an mmo object
#'
#' @description
#' Match features to a custom DB by m/z (ppm) and RT (minutes) tolerances and
#' attach a list-column of candidate compound IDs per feature.
#'
#' @param mmo An `mmo` object created by `GetMZmineFeature()`.
#' @param DB_file CSV path with at least columns `compound`, `mz`, `rt`.
#' @param mztol m/z tolerance in ppm (default 5).
#' @param rttol RT tolerance in minutes (default 0.5).
#' @return The same `mmo` object with `mmo$custom_annot` (id, feature, custom_annot).
#' @export
#' @examplesIf FALSE
#' mmo <- AddCustomAnnot(mmo, DB_file = "path/to/custom_db.csv", mztol = 5, rttol = 0.5)
AddCustomAnnot <- function(mmo, DB_file, mztol = 5, rttol = 0.5) {
  DB <- read.csv(DB_file, stringsAsFactors = FALSE)

  DB <- dplyr::mutate(
    DB,
    mz = as.numeric(.data$mz),
    rt = as.numeric(.data$rt)
  )

  # Parse "feature" (formatted like "mz_rt") into numeric mz/rt columns
  feature_annot <- mmo$feature_data |>
    tidyr::separate(
      col = "feature",
      into = c("mz", "rt"),
      sep = "_",
      remove = FALSE,
      convert = TRUE
    )

  # For each feature, collect matching DB compounds within tolerances
  annotated_features <- dplyr::mutate(
    feature_annot,
    custom_annot = purrr::map2(.data$mz, .data$rt, function(mzi, rti) {
      dplyr::filter(
        DB,
        abs(mzi - .data$mz) / mzi * 1e6 <= mztol,
        abs(rti - .data$rt) <= rttol
      ) |>
        dplyr::pull(.data$compound)
    })
  )

  mmo$custom_annot <- dplyr::select(
    annotated_features,
    id, feature, custom_annot
  )

  message("Custom annotation added to mmo$custom_annot using ", DB_file)
  mmo
}


#' Replace zero and NA values in the mmo object
#'
#' This function replaces zero and NA values in the feature data of the mmo object.
#' Run this function before MassNormalization(), LogNormalization(), MeancenterNormalization(), or ZNormalization().
#'
#' @param mmo The mmo object
#' @param method The method to use for replacement. Options are 'one' (replace with 1) or 'half_mean' (replace with half of the smallest non-zero value in the row)
#' @return The mmo object with replaced values in the feature data (mmo$feature_data)
#' @export
#' @examplesIf FALSE
#' mmo <- ReplaceZero(mmo, method = 'one')
# ReplaceZero <- function(mmo, method = 'one') {
#   df <- mmo$feature_data
#   df[] <- apply(df, 1, function(row) {
#     # Convert the row to numeric, ignoring non-numeric columns
#     numeric_row <- as.numeric(row[-c(1, 2)])  # Skip 'id' and 'feature' columns
#     # Get the smallest non-zero, non-NA value in the row
#     smallest_value <- min(numeric_row[numeric_row > 0], na.rm = TRUE)
#     # Replace 0 and NA with half of the smallest_value
#     row[-c(1, 2)] <- sapply(numeric_row, function(x) {
#       if (is.na(x) || x == 0) {
#         if (method == 'one') {
#           return(1)
#         } else if (method == 'half_mean') {
#           return(smallest_value / 2)
#         }
#       } else {
#         return(x)
#       }
#     })
#
#     return(row)
#   }) |>
#     t() |>
#     as.data.frame()  # Convert back to dataframe
#   mmo$feature_data <- df
#   print(paste('Missing values were filled with', method))
#   return(mmo)
# }
ReplaceZero <- function(mmo, method = "one") {
  df <- mmo$feature_data

  # assume first two cols are id, feature; everything else is numeric-ish
  id_feat <- df[, 1:2]
  num_df  <- df[, -(1:2), drop = FALSE]

  # force numeric matrix (without dragging id/feature in)
  num_mat <- as.matrix(sapply(num_df, as.numeric))

  new_mat <- t(apply(num_mat, 1, function(numeric_row) {
    # smallest non-zero, non-NA
    smallest_value <- suppressWarnings(
      min(numeric_row[numeric_row > 0], na.rm = TRUE)
    )

    # replace per element
    vapply(numeric_row, function(x) {
      if (is.na(x) || x == 0) {
        if (method == "one") {
          1
        } else if (method == "half_mean") {
          smallest_value / 2
        } else {
          x
        }
      } else {
        x
      }
    }, numeric(1))
  }))

  # rebuild data.frame with original id/feature + numeric matrix
  num_df_out <- as.data.frame(new_mat, stringsAsFactors = FALSE)
  names(num_df_out) <- names(num_df)

  df_out <- cbind(id_feat, num_df_out)

  mmo$feature_data <- df_out
  message(sprintf("Missing values were filled with %s", method))
  mmo
}
#' Convert feature abundances to presence / absence
#'
#' This function converts the feature abundance matrix in an mmo object
#' into a binary presence/absence matrix and stores it as a new component
#' of the mmo object (mmo$feature_presence).
#'
#' A feature is considered present (1) if its abundance is greater than
#' a specified threshold, and absent (0) otherwise.
#'
#' This function does NOT overwrite mmo$feature_data.
#'
#' @param mmo The mmo object
#' @param threshold Numeric threshold for presence (default = 1).
#'   Values > threshold are set to 1, values <= threshold or NA are set to 0.
#'
#' @return The mmo object with a new presence/absence table
#'   stored in mmo$feature_presence
#'
#' @export
#'
#' @examplesIf FALSE
#' mmo <- FeaturePresence(mmo, threshold = 1)
FeaturePresence <- function(mmo, threshold = 1) {

  df <- mmo$feature_data

  # assume first two columns are id and feature
  id_feat <- df[, 1:2]
  num_df  <- df[, -(1:2), drop = FALSE]

  # force numeric matrix
  num_mat <- as.matrix(sapply(num_df, as.numeric))

  # convert to presence / absence
  pa_mat <- ifelse(num_mat > threshold, 1, 0)

  # rebuild data.frame
  pa_df <- as.data.frame(pa_mat, stringsAsFactors = FALSE)
  names(pa_df) <- names(num_df)

  df_out <- cbind(id_feat, pa_df)

  # store as new slot
  mmo$feature_presence <- df_out

  message(
    sprintf(
      "Feature presence/absence matrix created using threshold > %s",
      threshold
    )
  )

  return(mmo)
}



#' Use sample mass in the metadata file to normalize the peak area
#'
#' This function normalizes the peak area in the feature data of the mmo object by the mass of each sample, provided in the metadata.
#' The feature data is replaced by (original value * mean mass) / sample mass.
#'
#' @param mmo The mmo object
#' @return The mmo object with normalized feature data (mmo$feature_data)
#' @export
#' @examplesIf FALSE
#' mmo <- MassNormalization(mmo)
MassNormalization <- function(mmo){
  normalized_df <- mmo$feature_data
  metadata <- mmo$metadata
  mean_mass <- mean(mmo$metadata$mass)
  for (sample_col in colnames(mmo$feature_data)[-c(1,2)]) {
    sample_metadata <- metadata[metadata$sample == sample_col, ]
    mass <- sample_metadata$mass
    normalized_df[[sample_col]] <- as.numeric(mmo$feature_data[[sample_col]])*mean_mass/mass
  }
  mmo$feature_data <- normalized_df
  print("Peak area are normalized by sample mass")
  return(mmo)
}

#' Log-normalize the peak area in the mmo object
#'
#' This function applies log2 transformation to the peak area in the feature data of the mmo object.
#' Run ReplaceZero() before this function to avoid -Inf values.
#'
#' @param mmo The mmo object
#' @return The mmo object with log-normalized feature data (mmo$log)
#' @export
#' @examplesIf FALSE
#' mmo <- LogNormalization(mmo)
LogNormalization <- function(mmo){
  feature_data_only <- mmo$feature_data[,-(1:2)]
  log_data <- log2(feature_data_only)
  log_df <- cbind(mmo$feature_data[, 1:2], log_data)
  mmo$log <- log_df
  print('Log-normalized values were added to mmo$log')
  return(mmo)
}

#' Mean-center the peak area in the mmo object
#'
#' This function applies mean-centering to the peak area in the feature data of the mmo object.
#'
#' @param mmo The mmo object
#' @return The mmo object with mean-centered feature data (mmo$meancentered)
#' @export
#' @examplesIf FALSE
#' mmo <- MeancenterNormalization(mmo)
MeancenterNormalization <- function(mmo){
  feature_data_only <- mmo$feature_data[,-(1:2)]
  mean_centered_data <- t(apply(feature_data_only, 1, function(x) x - mean(x, na.rm = TRUE)))
  mean_centered_df <- cbind(mmo$feature_data[, 1:2], mean_centered_data)
  mmo$meancentered <- mean_centered_df
  print('Meancentered values were added to mmo$meancentered')
  return(mmo)
}

#' Z-normalize the peak area in the mmo object
#'
#' This function applies Z-score normalization to the peak area in the feature data of the mmo object.
#'
#' @param mmo The mmo object
#' @return The mmo object with Z-normalized feature data (mmo$zscore)
#' @export
#' @examplesIf FALSE
#' mmo <- ZNormalization(mmo)
ZNormalization <- function(mmo){
  feature_data_only <- mmo$feature_data[,-(1:2)]
  zscore_df <- t(apply(feature_data_only, 1, function(x) {
    (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
  }))
  zscore_df <- cbind(mmo$feature_data[, 1:2], zscore_df)
  mmo$zscore <- zscore_df
  print('Z-score values were added to mmo$zscore')
  return(mmo)
}


#' Add chemical distance matrices to the mmo object
#'
#' This function reads cosine, DREAMS, and MS2DeepScore molecular networking outputs from MZmine,
#' then transform the similarity to distance and adds the dissimilarity matrices to the mmo object.
#'
#' @param mmo The mmo object
#' @param cos_dir Path to the cosine similarity CSV file from MZMine (molecular networking)
#' @param dreams_dir Path to the DREAMS similarity CSV file from MZMine (molecular networking)
#' @param m2ds_dir Path to the MS2DeepScore similarity CSV file from MZMine (molecular networking)
#' @return The mmo object with dissimilarity matrices added (mmo$cos.dissim, mmo$dreams.dissim, mmo$m2ds.dissim)
#' @export
#' @examplesIf FALSE
#' mmo <- AddChemDist(mmo,
#'  cos_dir = "path/to/cosine_similarity.csv",
#'  dreams_dir = "path/to/dreams_similarity.csv",
#'  m2ds_dir = "path/to/ms2deepscore_similarity.csv"
#' )
AddChemDist <- function(mmo, cos_dir = NULL, dreams_dir = NULL, m2ds_dir = NULL) {
  .require_pkg("data.table")
  add_dissim_matrix <- function(mmo, sim_dir, slot_name) {
    # Fast read
    sim <- data.table::fread(sim_dir, col.names = c("cluster1", "cluster2", "metric", "similarity", "etc"))
    sim$dissimilarity <- 1 - sim$similarity

    # Ensure cluster IDs are clean characters
    sim$cluster1 <- trimws(as.character(sim$cluster1))
    sim$cluster2 <- trimws(as.character(sim$cluster2))

    # Build mapping
    clusters <- unique(c(sim$cluster1, sim$cluster2))
    cluster_index <- stats::setNames(seq_along(clusters), clusters)

    # Map clusters to integer indices
    i <- cluster_index[sim$cluster1]
    j <- cluster_index[sim$cluster2]

    # Check for problems
    if (anyNA(i) || anyNA(j)) {
      bad <- unique(c(sim$cluster1[is.na(i)], sim$cluster2[is.na(j)]))
      stop("Cluster IDs not found in mapping: ", paste(bad, collapse = ", "))
    }

    # Preallocate full dense matrix
    n <- length(clusters)
    dissim_mat <- matrix(1, nrow = n, ncol = n)
    diag(dissim_mat) <- 0

    # Fill dissimilarities
    dissim_mat[cbind(i, j)] <- sim$dissimilarity
    dissim_mat[cbind(j, i)] <- sim$dissimilarity

    # Add names
    dimnames(dissim_mat) <- list(clusters, clusters)

    # Reduce memory footprint
    mode(dissim_mat) <- "single"

    mmo[[slot_name]] <- dissim_mat
    message(slot_name, " added to mmo")
    return(mmo)
  }

  if (!is.null(cos_dir))    mmo <- add_dissim_matrix(mmo, cos_dir,    "cos.dissim")
  if (!is.null(dreams_dir)) mmo <- add_dissim_matrix(mmo, dreams_dir, "dreams.dissim")
  if (!is.null(m2ds_dir))   mmo <- add_dissim_matrix(mmo, m2ds_dir,   "m2ds.dissim")

  if (is.null(cos_dir) && is.null(dreams_dir) && is.null(m2ds_dir)) {
    stop("Please provide at least one valid directory.")
  }

  return(mmo)
}


#' Reorder samples in the mmo object based on group order
#'
#' This function reorders the samples in the mmo object based on a specified group order.
#' The function updates the order of samples in the feature data, log-normalized data, z-score data, and mean-centered data.
#' Use this function before plotting heatmaps or other visualizations to ensure consistent group ordering.
#'
#' @param mmo The mmo object
#' @param group_order A vector specifying the desired order of groups
#' @return The mmo object with reordered samples
#' @export
#' @examplesIf FALSE
#' mmo <- ReorderGroups(mmo, group_order = c("Control", "Treatment1", "Treatment2"))
ReorderGroups <- function(mmo, group_order) {
  metadata <- mmo$metadata
  # Get sample names in the specified group order
  ordered_samples <- unlist(lapply(group_order, function(g) metadata$sample[metadata$group == g]))
  # Reorder columns: id, feature, then ordered samples
  mmo$feature_data <- mmo$feature_data |>
    dplyr::select(id, feature, all_of(ordered_samples))
  mmo$log <- mmo$log |>
    dplyr::select(id, feature, all_of(ordered_samples))
  mmo$zscore <- mmo$zscore |>
    dplyr::select(id, feature, all_of(ordered_samples))
  mmo$meancentered <- mmo$meancentered |>
    dplyr::select(id, feature, all_of(ordered_samples))
  return(mmo)
}

#' Filter an mmo object by samples, groups, and/or features
#'
#' @description
#' Subset all components of an mmo object (feature tables, metadata, distance
#' matrices, and annotations) to a given set of samples, groups, and/or
#' feature IDs. Filtering is applied consistently across all slots present
#' in `mmo`.
#'
#' @param mmo A list-like mmo object as returned by `GetMZmineFeature()`.
#' @param sample_list Optional character vector of sample IDs (matching
#'   `sample_col` in `mmo$metadata`) to retain.
#' @param group_list Optional character vector of group labels (matching
#'   `group_col` in `mmo$metadata`) to retain. Mutually exclusive with
#'   `sample_list`.
#' @param feature_list Optional character vector of feature IDs to retain.
#'   If `NULL`, features are determined from `feature_data` and optionally
#'   filtered by `drop_empty_feat`.
#' @param sample_col Column name in `mmo$metadata` containing sample IDs.
#'   Default is `"sample"`.
#' @param group_col Column name in `mmo$metadata` containing group labels.
#'   Default is `"group"`.
#' @param drop_empty_feat Logical; if `TRUE` (default) drop features with no
#'   non-zero values in the retained samples.
#' @param empty_threshold Optional numeric threshold used to define “empty”
#'   features. If `NULL` (default), the smallest positive, non-NA intensity
#'   in the retained samples (`min_val`) is used. Features are kept if they
#'   have at least one value > threshold across retained samples.
#' @return A filtered mmo object with the same structure as `mmo`, but
#'   restricted to the requested samples / groups / features.
#' @export
#'
#' @examples
#' \dontrun{
#' mmo_sub <- filter_mmo(mmo, group_list = c("Species1", "Species2"))
#' }
filter_mmo <- function(mmo,
                       sample_list  = NULL,
                       group_list   = NULL,
                       feature_list = NULL,
                       sample_col   = "sample",
                       group_col    = "group",
                       drop_empty_feat = TRUE,
                       empty_threshold   = NULL) {
  # ------------------------------------------------------------------
  # 0. Basic checks on arguments
  # ------------------------------------------------------------------
  if (is.null(sample_list) && is.null(group_list) && is.null(feature_list)) {
    stop("Must provide at least one of 'sample_list', 'group_list', or 'feature_list'.")
  }
  if (!is.null(sample_list) && !is.null(group_list)) {
    stop("Provide exactly one of 'sample_list' or 'group_list', not both.")
  }
  if (!"metadata" %in% names(mmo)) {
    stop("mmo$metadata must be present.")
  }
  if (!"feature_data" %in% names(mmo)) {
    stop("mmo$feature_data must be present.")
  }
  meta <- mmo$metadata
  if (!is.data.frame(meta)) {
    stop("mmo$metadata must be a data.frame.")
  }
  if (!sample_col %in% names(meta)) {
    stop(sprintf("sample_col '%s' not present in metadata.", sample_col))
  }
  if (!is.null(group_list) && !group_col %in% names(meta)) {
    stop(sprintf("group_col '%s' not present in metadata.", group_col))
  }
  # ------------------------------------------------------------------
  # 1. Determine which samples to keep
  # ------------------------------------------------------------------
  all_samples <- as.character(meta[[sample_col]])
  if (!is.null(sample_list)) {
    keep_samples <- intersect(all_samples, as.character(sample_list))
    if (length(keep_samples) == 0L) {
      stop("None of the supplied sample IDs in 'sample_list' are present in the mmo object.")
    }
  } else if (!is.null(group_list)) {
    idx <- meta[[group_col]] %in% group_list
    keep_samples <- as.character(meta[[sample_col]][idx])
    if (length(keep_samples) == 0L) {
      stop("No samples found for the requested 'group_list'.")
    }
  } else {
    # no sample_list or group_list -> keep all samples, only restrict by feature_list
    keep_samples <- all_samples
  }
  # ------------------------------------------------------------------
  # 2. Filter feature_data and decide which features to keep
  # ------------------------------------------------------------------
  feat_abund <- mmo[["feature_data"]]
  if (!all(c("id", "feature") %in% names(feat_abund))) {
    stop("mmo$feature_data must contain columns 'id' and 'feature'.")
  }
  # keep id, feature, and any sample columns that match keep_samples
  sample_cols_present <- intersect(keep_samples, names(feat_abund))
  col_keep <- c("id", "feature", sample_cols_present)
  feat_abund_filtered <- feat_abund[, col_keep, drop = FALSE]
  # automatic feature set from feature_data
  auto_features <- as.character(feat_abund_filtered$id)
  # Optionally drop features that are completely empty across retained samples
  if (drop_empty_feat && length(sample_cols_present) > 0L) {
    num_mat <- as.matrix(
      suppressWarnings(
        sapply(
          feat_abund_filtered[, sample_cols_present, drop = FALSE],
          as.numeric
        )
      )
    )
    if (!is.matrix(num_mat)) {
      num_mat <- matrix(num_mat, nrow = nrow(feat_abund_filtered))
    }

    # all positive, non-NA intensities across retained samples
    positive_vals <- num_mat[num_mat > 0 & !is.na(num_mat)]

    if (is.null(empty_threshold)) {
      # default: use min_val if there is at least one positive value
      if (length(positive_vals) == 0L) {
        # everything is 0/NA → all features considered empty
        threshold <- Inf
        message("drop_empty_feat = TRUE, but no positive intensities found; ",
                "all features are treated as empty.")
        nonempty_idx <- rep(FALSE, nrow(num_mat))
      } else {
        min_val   <- min(positive_vals)
        threshold <- min_val
        message(sprintf("Removing empty features based on min_val = %g", min_val))
        nonempty_idx <- apply(num_mat, 1, function(x) any(x > threshold, na.rm = TRUE))
      }
    } else {
      # user-specified threshold wins
      threshold <- empty_threshold
      message(sprintf("Removing empty features using user threshold = %g", threshold))
      nonempty_idx <- apply(num_mat, 1, function(x) any(x > threshold, na.rm = TRUE))
    }

    auto_features       <- auto_features[nonempty_idx]
    feat_abund_filtered <- feat_abund_filtered[nonempty_idx, , drop = FALSE]
  }
  # If user supplies a feature_list, intersect with auto_features
  if (!is.null(feature_list)) {
    feature_list <- as.character(feature_list)
    features_keep <- intersect(auto_features, feature_list)
    if (length(features_keep) == 0L) {
      stop("No overlap between 'feature_list' and features present in mmo$feature_data.")
    }
    feat_abund_filtered <- feat_abund_filtered[feat_abund_filtered$id %in% features_keep, , drop = FALSE]
  } else {
    features_keep <- auto_features
  }
  # ------------------------------------------------------------------
  # 3. Build filtered mmo
  # ------------------------------------------------------------------
  mmo_filtered <- list()
  # feature_data
  mmo_filtered$feature_data <- feat_abund_filtered
  # metadata
  mmo_filtered$metadata <- meta[meta[[sample_col]] %in% keep_samples, , drop = FALSE]
  # feature_info
  if ("feature_info" %in% names(mmo)) {
    fi <- mmo[["feature_info"]]
    if ("id" %in% names(fi)) {
      mmo_filtered$feature_info <- fi[fi$id %in% features_keep, , drop = FALSE]
    }
  }
  # log
  if ("log" %in% names(mmo)) {
    log_mat <- mmo[["log"]]
    sample_cols_present <- intersect(keep_samples, names(log_mat))
    col_keep <- c("id", "feature", sample_cols_present)
    log_filt <- log_mat[, col_keep, drop = FALSE]
    mmo_filtered$log <- log_filt[log_filt$id %in% features_keep, , drop = FALSE]
  }
  # zscore
  if ("zscore" %in% names(mmo)) {
    z_mat <- mmo[["zscore"]]
    sample_cols_present <- intersect(keep_samples, names(z_mat))
    col_keep <- c("id", "feature", sample_cols_present)
    z_filt <- z_mat[, col_keep, drop = FALSE]
    mmo_filtered$zscore <- z_filt[z_filt$id %in% features_keep, , drop = FALSE]
  }
  # meancentered
  if ("meancentered" %in% names(mmo)) {
    mc_mat <- mmo[["meancentered"]]
    sample_cols_present <- intersect(keep_samples, names(mc_mat))
    col_keep <- c("id", "feature", sample_cols_present)
    mc_filt <- mc_mat[, col_keep, drop = FALSE]
    mmo_filtered$meancentered <- mc_filt[mc_filt$id %in% features_keep, , drop = FALSE]
  }
  # pairwise (assumed feature-level, with 'id' column)
  if ("pairwise" %in% names(mmo)) {
    pw <- mmo[["pairwise"]]
    if ("id" %in% names(pw)) {
      mmo_filtered$pairwise <- pw[pw$id %in% features_keep, , drop = FALSE]
    }
  }
  # dissimilarity matrices (features x features, row/col names = feature IDs)
  for (mat_name in c("cos.dissim", "dreams.dissim", "m2ds.dissim")) {
    if (mat_name %in% names(mmo)) {
      d <- mmo[[mat_name]]
      if (!is.null(rownames(d))) {
        keep_idx <- rownames(d) %in% features_keep
        mmo_filtered[[mat_name]] <- d[keep_idx, keep_idx, drop = FALSE]
      }
    }
  }
  # annotations
  if ("sirius_annot" %in% names(mmo)) {
    sa <- mmo[["sirius_annot"]]
    if ("id" %in% names(sa)) {
      mmo_filtered$sirius_annot <- sa[sa$id %in% features_keep, , drop = FALSE]
    }
  }
  if ("custom_annot" %in% names(mmo)) {
    ca <- mmo[["custom_annot"]]
    if ("id" %in% names(ca)) {
      mmo_filtered$custom_annot <- ca[ca$id %in% features_keep, , drop = FALSE]
    }
  }
  # Preserve class if mmo had one
  class(mmo_filtered) <- class(mmo)
  print("MMO object was subset")
  print(paste0("Feature number: ", nrow(mmo_filtered$feature_data)))
  print(paste0(nrow(mmo_filtered$metadata), " samples in ", length(unique(mmo_filtered$metadata$group)), " groups"))
  return(mmo_filtered)
}


########################################################################################
# Define functions for supporting analysis
########################################################################################

#' Retrieve feature data from the mmo object, with normalization options
#'
#' This function retrieves the feature data from the mmo object based on the specified normalization method.
#'
#' @param mmo The mmo object
#' @param normalization The normalization method to use. Options are 'None', 'Log', 'Meancentered', or 'Z'
#' @return The feature data corresponding to the specified normalization method
#' @export
#' @examplesIf FALSE
#' feature_data <- GetNormFeature(mmo, normalization = 'Log')
GetNormFeature <- function(mmo, normalization){
  if (normalization == 'None'){
    feature <- mmo$feature_data
  } else if (normalization == 'Log'){
    feature <- mmo$log
  } else if (normalization == 'Meancentered'){
    feature <- mmo$meancentered
  } else if (normalization == 'Z'){
    feature <- mmo$zscore
  } else {
    print('The normalization should be None, Log, Meancentered, or Z')
  }
  return(feature)
}


#' Get the distance matrix from the mmo object based on the specified distance metric
#'
#' This function retrieves the distance matrix from the mmo object based on the specified distance metric.
#'
#' @param mmo The mmo object
#' @param distance The distance metric to use. Options are 'dreams', 'cosine', or 'm2ds'
#' @return The distance matrix corresponding to the specified distance metric
#' @export
#' @examplesIf FALSE
#' distance_matrix <- GetDistanceMat(mmo, distance = 'dreams')
GetDistanceMat <- function(mmo, distance = 'dreams'){
  if (distance == 'dreams'){
    distance_matrix <- mmo$dreams.dissim
  } else if (distance == 'cosine'){
    distance_matrix <- mmo$cos.dissim
  } else if (distance == 'm2ds'){
    distance_matrix <- mmo$m2ds.dissim
  }
  return(distance_matrix)
}

#' Convert feature names to IDs in the mmo object
#'
#' This function converts feature names to their corresponding IDs in the mmo object.
#'
#' @param mmo The mmo object
#' @param feature_names A vector of feature names to convert
#' @return A vector of feature IDs corresponding to the input feature names
#' @export
#' @examplesIf FALSE
#' feature_ids <- FeatureToID(mmo, feature_names = c("100.0_5.0", "150.0_10.0"))
#' feature_ids <- FeatureToID(mmo, feature_names = mmo$feature_data$feature[1:10])
#' feature_ids <- FeatureToID(mmo,
#'  feature_names = Glucosinolates
#' ) # if Glucosinolates is a vector of feature names
FeatureToID <- function(mmo, feature_names) {
  feature_data <- mmo$feature_data
  feature_ids <- feature_data |>
    filter(.data$feature %in% feature_names) |>
    dplyr::select(feature, id)
  # Match the order of feature_names
  feature_ids <- feature_ids$id[match(feature_names, feature_ids$feature)]
  return(feature_ids)
}

#' Convert feature IDs to names in the mmo object
#'
#' This function converts feature IDs to their corresponding names in the mmo object.
#'
#' @param mmo The mmo object
#' @param feature_ids A vector of feature IDs to convert
#' @return A vector of feature names corresponding to the input feature IDs
#' @export
#' @examplesIf FALSE
#' feature_names <- IDToFeature(mmo, feature_ids = c("1219", "2250", "3360"))
#' feature_names <- IDToFeature(mmo, feature_ids = mmo$feature_data$id[1:10])
#' feature_names <- IDToFeature(mmo,
#'  feature_ids = FeatureToID(mmo, feature_names = Glucosinolates)
#' ) # if Glucosinolates is a vector of feature names
IDToFeature <- function(mmo, feature_ids) {
  feature_data <- mmo$feature_data
  feature_names <- feature_data |>
    filter(.data$id %in% feature_ids) |>
    dplyr::select(id, feature)
  # Match the order of feature_ids
  feature_names <- feature_names$feature[match(feature_ids, feature_names$id)]
  return(feature_names)
}

#' Calculate group means from the mmo object
#'
#' This function calculates and returns a dataframe of mean feature values for each group in the mmo object, with options for normalization and filtering.
#' Use SwitchGroup() to change the grouping variable before running this function.
#'
#' @param mmo The mmo object
#' @param normalization The normalization method to use. Options are 'None', 'Log', 'Meancentered', or 'Z'
#' @param filter_feature Boolean to filter features based on a provided list (default: FALSE)
#' @param feature_list A vector of feature names to filter (default: NULL)
#' @param filter_group Boolean to filter groups based on a provided list (default: FALSE)
#' @param group_list A vector of group names to filter (default: NULL)
#' @return A data frame containing the mean feature values for each group
#' @export
#' @examplesIf FALSE
#' group_means <- GetGroupMeans(mmo, normalization = 'Log')
#' group_means <- GetGroupMeans(mmo,
#'  normalization = 'None',
#'  filter_feature = TRUE, feature_list = Glucosinolates
#' ) # if Glucosinolates is a vector of feature names
#' group_means <- GetGroupMeans(mmo,
#'  normalization = 'Z',
#'  filter_group = TRUE,
#'  group_list = c("Control", "Treatment1")
#' )
#' group_means <- GetGroupMeans(mmo,
#'  normalization = 'Meancentered',
#'  filter_feature = TRUE, feature_list = Glucosinolates,
#'  filter_group = TRUE, group_list = c("Control", "Treatment1")
#' ) # if Glucosinolates is a vector of feature names
GetGroupMeans <- function(mmo, normalization = 'None', filter_feature = FALSE, feature_list = NULL, filter_group = FALSE, group_list = NULL) {
  feature_data <- GetNormFeature(mmo, normalization = normalization)
  metadata <- mmo$metadata

  # Melt the feature data to long format
  long_feature_data <- feature_data |>
    tidyr::pivot_longer(
      cols = -c(.data$id, .data$feature),                 # all columns except id and feature
      names_to = "sample",                    # old column names go here
      values_to = "feature_value"             # values go here
    )

  colnames(long_feature_data) <- c('id', 'feature', 'sample', 'feature_value')

  # Merge with metadata to get group information
  merged_data <- merge(long_feature_data, metadata[, c('sample', 'group')], by = 'sample')
  if (filter_group == TRUE){
    merged_data <- merged_data |> filter(.data$group %in% group_list)
  }
  # Calculate group means
  group_means <- merged_data |>
    dplyr::group_by(group, id) |>
    dplyr::summarise(mean_value = mean(.data$feature_value, na.rm = TRUE), .groups = "drop") |>
    tidyr::pivot_wider(
      names_from = .data$group,
      values_from = .data$mean_value
    )

  if (filter_feature) {
    group_means <- group_means |>
      dplyr::filter(.data$id %in% FeatureToID(mmo, feature_list))
  }
  return(group_means)
}

#' Calculate log2 fold change for a given control group
#'
#' This function calculates and returns a dataframe of log2 fold change values for each group compared to a specified control group.
#' Takes inputs from GetGroupMeans() function.
#'
#' @param group_means A data frame containing the mean feature values for each group
#' @param control_group The name of the control group to compare against
#' @return A data frame with log2 fold change values for each group compared to the control group
#' @export
#' @examplesIf FALSE
#' fold_change <- GetLog2FoldChange(GetGroupMeans(mmo, normalization = 'Log'), control_group = 'Control')
GetLog2FoldChange <- function(group_means, control_group) {
  control_means <- group_means[[control_group]]
  fold_change <- group_means |>
    mutate(across(-id, ~ log2(. / control_means)))

  return(fold_change)
}


#' Perform ANOVA and Tukey's HSD test on the mmo object
#'
#' This function performs ANOVA and Tukey's HSD test on the feature data of the mmo object,
#' Returns a list of ANOVA results, Tukey's HSD results, Tukey's significance letters, and Dunnett's test results.
#'
#' @param df The data frame containing the feature data and metadata
#' @param formula The formula for the ANOVA test, e.g., "feature ~ group"
#' @return A list containing the ANOVA results, Tukey's HSD results, Tukey's significance letters, and Dunnett's test results
#' @export
#' @examplesIf FALSE
#' anova_results <- anova_tukey_dunnett(df = merged_data, formula = "feature_value ~ group")
anova_tukey_dunnett <- function(df, formula) {
  .require_pkg("DescTools")
  .require_pkg("multcompView")
  aov_res <- aov(as.formula(formula), data = df)
  tukey_res <- TukeyHSD(aov_res)
  tukey_sig <- multcompView::multcompLetters4(aov_res, tukey_res)
  dunnett_res <- DescTools::DunnettTest(as.formula(formula), data = df)
  return(list(aov_res = aov_res, tukey_res = tukey_res, tukey_sig = tukey_sig, dunnett_res = dunnett_res))
}

#' Write results of anova_tukey_dunnett to a CSV file
#'
#' This function writes the results of ANOVA and Tukey's HSD test to a CSV file.
#'
#' @param anova_data A list containing the results of ANOVA and Tukey's HSD test
#' @param outdir The output directory where the results will be saved
#' @param way The type of ANOVA test to perform. Options are 'oneway' or 'twoway'
#' @export
#' @examplesIf FALSE
#' write_anova(anova_data = anova_results, outdir = "anova_tukey_results.csv", way = 'oneway')
#'
write_anova <- function(anova_data, outdir, way='oneway'){
  way_num <- switch(way, oneway = 1, twoway = 3)
  # Perform ANOVA and Tukey HSD
  aov_res <- anova_data$aov_res
  tukey_res <- anova_data$tukey_res
  tukey_sig <- anova_data$tukey_sig[way_num]
  dunnett_res <- anova_data$dunnett_res

  # Save ANOVA and Tukey HSD results
  anova_df <- as.data.frame(summary(aov_res)[[1]])
  anova_df$Comparison <- rownames(anova_df)
  tukey_df <- as.data.frame(tukey_res[way_num])
  tukey_df$Comparison <- rownames(tukey_df)
  sig_letter <- as.data.frame(unlist(tukey_sig))
  sig_letter$Comparison <- rownames(sig_letter)
  dunnett_df <- as.data.frame(dunnett_res[[1]])
  dunnett_df$comp <- rownames(dunnett_df)

  # Create a combined results data frame
  combined_df <- dplyr::bind_rows(
    dplyr::tibble(Test = "ANOVA", anova_df),
    dplyr::tibble(Test = "Tukey", tukey_df),
    dplyr::tibble(Test = 'sig', sig_letter),
    dplyr::tibble(Test = 'Dunnett', dunnett_df)
  )
  readr::write_csv(combined_df, file = outdir)
}

#' Perform PERMANOVA and pairwise comparisons
#'
#' This function performs PERMANOVA on the given data and metadata, with options for filtering groups.
#' It also conducts post-hoc pairwise comparisons and adjusts p-values for multiple testing.
#' The function returns the PERMANOVA results, raw pairwise comparison results, and matrices of adjusted p-values, F values, and R square for pairwise comparisons
#'
#' @param data A data frame or distance matrix for PERMANOVA
#' @param metadata A data frame containing sample metadata, including a 'group' column
#' @param mode The mode of the input data: 'data' for raw data or 'distance' for a distance matrix
#' @param filter_group Boolean to filter groups based on a provided list (default: FALSE)
#' @param group_list A vector of group names to filter (default: NULL)
#' @param permutations The number of permutations for the PERMANOVA test (default: 5000)
#' @return A list containing the PERMANOVA results, raw pairwise comparison results, and matrices of adjusted p-values, F values, and R square for pairwise comparisons
#' @export
#' @examplesIf FALSE
#' permanova_results <- permanova_stat(
#'  data = feature_data, metadata = mmo$metadata,
#'  mode = 'data', filter_group = TRUE, group_list = c("Control", "Treatment1"),
#'  permutations = 5000
#' )
#' permanova_results <- permanova_stat(
#'  data = betadiv, metadata = mmo$metadata,
#'  mode = 'distance', permutations = 10000
#' )
permanova_stat <- function(data, metadata, mode, filter_group = FALSE, group_list = NULL, permutations = 5000){
  .require_pkg("vegan")
  .require_pkg("stringr")
  .require_pkg("pairwiseAdonis")
  #Perform PERMANOVA
  if (mode == 'data'){
    dist_mat <- stats::dist(data)
  } else if (mode == 'distance'){
    dist_mat <- as.dist(data)
  } else {
    stop("Invalid mode for adonis2. Please use 'data' or 'distance'")
  }
  dist_mat <- dist(data)
  metadata <- metadata[match(rownames(data), metadata$sample), ]
  if (filter_group == TRUE){
    metadata <- metadata |> filter(.data$group %in% group_list)
    dist_mat <- as.dist(as.matrix(dist_mat)[metadata$sample, metadata$sample])
  }
  permanova_res <- vegan::adonis2(dist_mat ~ group, data = metadata, permutations = permutations)
  #Post-hoc
  pairwise_permanova <- pairwiseAdonis::pairwise.adonis2(dist_mat ~ group, data = metadata, permutations = permutations)
  # Multiple test correction for pairwise p-values
  pvals <- sapply(pairwise_permanova[-1], function(x) x[1,5])
  pvals_adj <- p.adjust(pvals, method = "BH")
  # Add adjusted p-values to pairwise_permanova
  for (i in seq_along(pvals_adj)) {
    pairwise_permanova[[i+1]]$padj <- pvals_adj[i]
  }
  #Organize posthoc results for visual
  pairwise_p_matrix <- matrix(NA, nrow = length(unique(metadata$group)), ncol = length(unique(metadata$group)))
  rownames(pairwise_p_matrix) <- unique(metadata$group)
  colnames(pairwise_p_matrix) <- unique(metadata$group)
  for (i in 2:length(pairwise_permanova)){
    group1 <- stringr::str_split(names(pairwise_permanova)[i], '_vs_')[[1]][1]
    group2 <- stringr::str_split(names(pairwise_permanova)[i], '_vs_')[[1]][2]
    pval <- pairwise_permanova[[i]][1,6]
    pairwise_p_matrix[group2, group1] <- pval
  }
  # Organize posthoc F values for visualization
  pairwise_F_matrix <- matrix(NA, nrow = length(unique(metadata$group)), ncol = length(unique(metadata$group)))
  rownames(pairwise_F_matrix) <- unique(metadata$group)
  colnames(pairwise_F_matrix) <- unique(metadata$group)
  for (i in 2:length(pairwise_permanova)){
    group1 <- stringr::str_split(names(pairwise_permanova)[i], '_vs_')[[1]][1]
    group2 <- stringr::str_split(names(pairwise_permanova)[i], '_vs_')[[1]][2]
    Fval <- pairwise_permanova[[i]][1,4]
    pairwise_F_matrix[group2, group1] <- Fval
  }
  # Organize posthoc R^2 values for visualization
  pairwise_R2_matrix <- matrix(NA, nrow = length(unique(metadata$group)), ncol = length(unique(metadata$group)))
  rownames(pairwise_R2_matrix) <- unique(metadata$group)
  colnames(pairwise_R2_matrix) <- unique(metadata$group)
  for (i in 2:length(pairwise_permanova)){
    group1 <- stringr::str_split(names(pairwise_permanova)[i], '_vs_')[[1]][1]
    group2 <- stringr::str_split(names(pairwise_permanova)[i], '_vs_')[[1]][2]
    R2val <- pairwise_permanova[[i]][1,3]
    pairwise_R2_matrix[group2, group1] <- R2val
  }
  return(list(permanova_res = permanova_res, pairwise_raw = pairwise_permanova, pairwise_p_matrix = pairwise_p_matrix, pairwise_F_matrix = pairwise_F_matrix, pairwise_R2_matrix = pairwise_R2_matrix))
}

########################################################################################
# Define functions for pairwise comparison and visualization
########################################################################################

#' Perform pairwise comparison between two groups in the mmo object
#'
#' This function performs pairwise comparison between two groups in the mmo object,
#' calculating log2 fold change and adjusted p-values for given comparison of two groups.
#' The function adds the results to the mmo$pairwise data frame.
#'
#' @param mmo The mmo object
#' @param group1 The name of the nominator group
#' @param group2 The name of the denominator group
#' @param correction The method for multiple comparison correction. Options are 'BH', 'holm', 'bonferroni', etc. Inherits from p.adjust() (default: 'BH')
#' @return The mmo object with pairwise comparison results added to mmo$pairwise
#' @export
#' @examplesIf FALSE
#' mmo <- PairwiseComp(mmo, group1 = 'Control', group2 = 'Treatment1')
PairwiseComp <- function(mmo, group1, group2, correction = 'BH'){
  feature <- mmo$feature_data
  metadata <- mmo$metadata
  #Get sample names
  group1_samples <- metadata |> filter(.data$group == group1) |> pull(sample)
  group2_samples <- metadata |> filter(.data$group == group2) |> pull(sample)
  #Get data from the samples
  group1_data <- feature |> dplyr::select(id, feature, all_of(group1_samples))
  group2_data <- feature |> dplyr::select(id, feature, all_of(group2_samples))
  #Make empty column
  log2FC <- numeric(nrow(feature))
  pval <- numeric(nrow(feature))
  #Pairwise comparison
  for (i in 1:nrow(feature)){
    group1_value <- as.numeric(group1_data[i, -c(1,2)])
    group2_value <- as.numeric(group2_data[i, -c(1,2)])

    group1_mean <- mean(group1_value, na.rm = TRUE)
    group2_mean <- mean(group2_value, na.rm = TRUE)
    log2FC[i] <- log2(group2_mean/group1_mean)

    pval[i] <- tryCatch(
      expr = {
        p <- t.test(group1_value, group2_value, na.rm = TRUE)$p.value
        p
      },
      error = function(e)
      {
        return(1)
      }
    )

    # ttest <- t.test(group1_value, group2_value, na.rm = TRUE)

    # pval[i] <- ttest$p.value
  }
  padj <- p.adjust(pval, method = correction)
  #Store in results
  results <- data.frame(
    log2FC= log2FC,
    padj = padj
  )
  names(results) <- c(paste(group1, "vs", group2, "log2FC", sep = "_"), paste(group1, "vs", group2, "padj", sep = "_"))
  #Add pairwise results to the mmo object
  mmo$pairwise <- cbind(mmo$pairwise, results)
  print(paste(group2, '/', group1, 'comparison was completed'))
  return(mmo)
}


#' Generates lists of DAMs (Differentially Accumulated Metabolites) for each comparison in the mmo object
#'
#' This function generates lists of upregulated and downregulated DAMs for each pairwise comparison in the mmo object.
#' It uses log2 fold change and adjusted p-value thresholds to determine significance.
#' Make sure to run PairwiseComp() for all desired comparisons before using this function.
#'
#' @param mmo The mmo object with pairwise comparison matrix
#' @param fc_cutoff The threshold of log2 fold change to be considered significant (default: 0.5849625, which is log2(1.5))
#' @param pval_cutoff The threshold of adjusted p-value to be considered significant (default: 0.05)
#' @return A list containing two lists: DAMs_up and DAMs_down
#' @export
#' @examplesIf FALSE
#' dams <- GetDAMs(mmo, fc_cutoff = 0.5849625, pval_cutoff = 0.05)
#' dams_up <- dams$DAMs_up
#' dams_down <- dams$DAMs_down
GetDAMs <- function(mmo, fc_cutoff = 0.5849625, pval_cutoff = 0.05) {
  # Generate the list of comparisons automatically by looking up mmo$pairwise
  comparison_columns <- colnames(mmo$pairwise)
  log2FC_columns <- grep("log2FC", comparison_columns, value = TRUE)
  comparisons <- unique(sub("log2FC", "", log2FC_columns))
  comparisons <- sub("_$", "", comparisons)  # Remove trailing underscore from comparisons
  # Make list of DAMs for up and downregulation for each comparison
  DAMs_up <- list()
  DAMs_down <- list()
  for (comp in comparisons) {
    group1 <- strsplit(comp, "_vs_")[[1]][1]
    group2 <- strsplit(comp, "_vs_")[[1]][2]
    DAMs_up[[paste(comp, "up", sep = ".")]] <- filter(mmo$pairwise, get(paste(comp, "log2FC", sep = "_")) > fc_cutoff & get(paste(comp, "padj", sep = "_")) < pval_cutoff)$feature
    DAMs_down[[paste(comp, "down", sep = ".")]] <- filter(mmo$pairwise, get(paste(comp, "log2FC", sep = "_")) < -fc_cutoff & get(paste(comp, "padj", sep = "_")) < pval_cutoff)$feature
  }
  names(DAMs_up) <- paste(comparisons, "up", sep = ".")
  names(DAMs_down) <- paste(comparisons, "down", sep = ".")
  return(list(DAMs_up = DAMs_up, DAMs_down = DAMs_down))
}



#' Volcano plot for visualizing differential metabolite analysis results
#'
#' This function generates a volcano plot using data from mmo$pairwise (PairwiseComp(mmo, 'group1', 'group2') should be precended),
#' highlighting upregulated and downregulated features based on log2 fold change and adjusted p-value
#'
#' @param mmo The mmo object with pairwise comparison matrix
#' @param comp The comparison to visualize, e.g., 'group1_vs_group2
#' @param topk The number of top features to label in the plot (default: 10)
#' @param pthr The threshold of adjusted p-value to be considered significant (default: 0.05)
#' @param outdir The output file path for the volcano plot (default: 'volcano.png')
#' @param height The height of the output plot in inches (default: 5)
#' @param width The width of the output plot in inches (default: 5)
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @return A list containing the volcano plot and the data used to generate it
#' @export
#' @examplesIf FALSE
#' VolcanoPlot(
#'  mmo, comp = 'Control_vs_Treatment1',
#'  topk = 10, pthr = 0.05,
#'  outdir = 'volcano_con_tre1.png', height = 5, width = 5
#' )
VolcanoPlot <- function(mmo, comp, topk = 10, pthr = 0.05, outdir = 'volcano.png', height = 5, width = 5, save_output = TRUE){
  .require_pkg("ggrepel")
  VolData <- mmo$pairwise |> dplyr::select(feature,all_of(c(paste(comp, 'log2FC', sep = '_'), paste(comp, 'padj', sep = '_'))))
  colnames(VolData) <- c('feature', 'log2FC', 'padj')
  VolData <- VolData |>
    mutate(
      Expression = dplyr::case_when(log2FC >= 1 & padj <= pthr ~ "Up-regulated",
                            log2FC <= -1 & padj <= pthr ~ "Down-regulated",
                            TRUE ~ "Not significant")
      )

  top_features <- dplyr::bind_rows(
    VolData |>
      filter(.data$Expression =='Up-regulated')  |>
      arrange(dplyr::desc(abs(.data$log2FC)), .data$padj) |>
      head(topk),
    VolData |>
      filter(.data$Expression == 'Down-regulated') |>
      arrange(dplyr::desc(abs(.data$log2FC)), .data$padj) |>
      head(topk)
  )

  plot <- ggplot(VolData, aes(x = .data$log2FC, y = -log(.data$padj, 10))) +
    geom_point(aes(color = .data$Expression), size = 0.4)+
    xlab(expression("log"[2]*"FC")) +
    ylab(expression("-log"[10]*"FDR"))+
    scale_color_manual(values = c("dodgerblue3", "gray50", "firebrick3")) +
    guides(colour = guide_legend(override.aes = list(size=1.5))) +
    theme_classic()+
    ggrepel::geom_label_repel(data = top_features,
                    mapping = aes(.data$log2FC, -log(.data$padj,10), label = .data$feature),
                    size = 2)

  plot
  if (save_output){
    ggsave(outdir, height = height, width = width)
    readr::write_csv(VolData, paste0(outdir, '_volcano_data.csv'))
  }
  return(list(plot = plot, df = VolData))
}

########################################################################################
# Define functions for multivariate analysis
########################################################################################


#' Plots PCA and performs PERMANOVA
#'
#' This function performs PCA analysis and generates a PCA plot with optional filtering of features and groups.
#' It also conducts PERMANOVA and saves the results to CSV files.
#'
#' @param mmo The mmo object with feature data and metadata
#' @param color A vector of colors for the groups in the plot. Make sure the names correspond to the group names in metadata
#' @param outdir The output file path for the PCA plot (default: 'PCA')
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'Z')
#' @param filter_feature Boolean to filter features by feature_list (default: FALSE)
#' @param feature_list A vector of feature names to filter (default: NULL)
#' @param filter_group Boolean to filter groups by group_list (default: FALSE)
#' @param group_list A vector of group names to filter (default: NULL)
#' @param label Boolean to indicate whether to label points with sample names (default: TRUE)
#' @param save_output Boolean; if TRUE (default) write plot (.pdf) and PERMANOVA
#'   tables using `outdir` as prefix. If FALSE, nothing is written.
#' @return A list with elements `plot` (ggplot), `df` (raw data to generate plots),
#'   and `permanova` (results from `permanova_stat`).
#' @export
#' @examplesIf FALSE
#' PCAplot(
#'  mmo, color = c("Control" = "blue", "Treatment1" = "red", "Treatment2" = "green"),
#'  outdir = 'PCA_plot', normalization = 'None',
#'  filter_feature = FALSE, filter_group = FALSE, label = FALSE
#' )
#' PCAplot(
#'  mmo, color = c("Control" = "blue", "Treatment1" = "red"),
#'  outdir = 'PCA_plot', normalization = 'Z',
#'  filter_feature = TRUE, feature_list = Glucosinolates,
#'  filter_group = TRUE, group_list = c("Control", "Treatment1"), label = TRUE
#' )
PCAplot <- function(mmo, color, outdir = 'PCA', normalization = 'Z', filter_feature = FALSE, feature_list = NULL, filter_group = FALSE, group_list = NULL, label = TRUE, save_output = TRUE){
  .require_pkg("ggrepel")
  .require_pkg("stats")
  metadata <- mmo$metadata
  feature <- GetNormFeature(mmo, normalization)
  if (filter_feature == TRUE){
    feature <- feature |> filter(.data$feature %in% feature_list)
  }
  # Perform PCA on normalized feature data
  feature_data_pca <- feature[, -(1:2)]
  feature_data_pca <- t(feature_data_pca) # samples as rows, features as columns
  pca_res <- stats::prcomp(feature_data_pca, scale. = TRUE)
  pca_df <- as.data.frame(pca_res$x)
  pca_df$group <- metadata$group[match(rownames(pca_df), metadata$sample)]

  if (filter_group == TRUE){
    pca_df <- pca_df |> filter(.data$group %in% group_list)
  }
  if (label == TRUE){
    plot <- ggplot(pca_df, aes(x = .data$PC1, y = .data$PC2, color = .data$group, label = rownames(pca_df))) +
      geom_point(size = 3) +
      ggrepel::geom_label_repel(aes(label = rownames(pca_df)), size = 3) +
      theme_classic() +
      labs(x = "PC1", y = "PC2") +
      scale_color_manual(values = color)+
      stat_ellipse(aes(group = .data$group), level = 0.90)
  } else {
    plot <- ggplot(pca_df, aes(x = .data$PC1, y = .data$PC2, color = .data$group)) +
      geom_point(size = 3) +
      # geom_label_repel(aes(label = rownames(pca_df)), size = 3) +
      theme_classic() +
      labs(x = "PC1", y = "PC2") +
      scale_color_manual(values = color)+
      stat_ellipse(aes(group = .data$group), level = 0.90)
  }
  permanova <- permanova_stat(feature_data_pca, metadata, mode = 'data', filter_group = filter_group, group_list = group_list)
  plot
  if (isTRUE(save_output)) {
    ggsave(paste0(outdir, '.pdf'), width = 6, height = 6)
    readr::write_csv(permanova$permanova_res, paste0(outdir, '_permanova_results.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_raw), paste0(outdir, '_pairwise_permanova_results.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_p_matrix), paste0(outdir, '_pairwise_permanova_pvalue_matrix.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_F_matrix), paste0(outdir, '_pairwise_permanova_Fvalue_matrix.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_R2_matrix), paste0(outdir, '_pairwise_permanova_R2_matrix.csv'))
  }

  return(invisible(list(plot = plot, df = pca_df, permanova = permanova)))
}




#' PLS-DA plot with feature loadings
#'
# This function performs PLS-DA analysis and generates a PLS-DA plot with feature loadings.
#'
#' @param mmo The mmo object with feature data and metadata
#' @param color A vector of colors for the groups in the plot. Make sure the names correspond to the group names in metadata
#' @param topk The number of top features to display in the plot (default: 10)
#' @param outdir The output file path for the PLS-DA plot
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'Z')
#' @param filter_feature Boolean to filter features by feature_list (default: FALSE)
#' @param feature_list A vector of feature names to filter (default: NULL)
#' @param filter_group Boolean to filter groups by group_list (default: FALSE)
#' @param group_list A vector of group names to filter (default: NULL)
#' @param save_output Boolean; if TRUE (default) write plot (.pdf) and loadings
#'   tables using `outdir` as prefix. If FALSE, nothing is written.
#' @return A list with elements `plot` (ggplot), `df` (raw data to generate plots),
#'   and `loadings` (loadings for PLSDA).
#' @export
#' @examplesIf FALSE
#' PLSDAplot(
#'  mmo, color = c("Control" = "blue", "Treatment1" = "red", "Treatment2" = "green"),
#'  topk = 10, outdir = 'PLSDA_plot.pdf', normalization = 'Z',
#'  filter_feature = FALSE, filter_group = FALSE
#' )
#' PLSDAplot(
#'  mmo, color = c("Control" = "blue", "Treatment1" = "red"),
#'  topk = 5, outdir = 'PLSDA_plot.pdf', normalization = 'Log',
#'  filter_feature = TRUE, feature_list = Glucosinolates,
#'  filter_group = TRUE, group_list = c("Control", "Treatment1")
#' )
PLSDAplot <- function(mmo, color, topk = 10, outdir, normalization = 'Z', filter_feature = FALSE, feature_list = NULL, filter_group = FALSE, group_list = NULL, save_output = TRUE) {
  .require_pkg("caret")
  .require_pkg("ggrepel")

  metadata <- mmo$metadata
  #Get appropriate feature by normalization parameter
  feature <- GetNormFeature(mmo, normalization)

  # All feature or filtered feature
  if (filter_feature == TRUE){
    feature <- feature |> filter(feature %in% feature_list)
  }

  X <- t(as.matrix(feature[, -(1:2)]))
  Y <- c()
  for (col in colnames(feature)[-c(1,2)]){
    Y <- append(Y, metadata[metadata$sample == col, ]$group)
  }
  Y <- as.factor(Y)

  plsda_model <- caret::plsda(X, Y, ncomp = 2)
  scores <- plsda_model$scores[, 1:2]
  plsda_df <- data.frame(Comp1 = scores[, 1], Comp2 = scores[, 2], Group = Y)
  loadings <- plsda_model$loadings
  loadings_comp1 <- loadings[, 1]
  loadings_comp2 <- loadings[, 2]
  if (filter_feature == FALSE){
    loadings_df <- data.frame(Feature = mmo$feature_data$feature,
                            Comp1_Loading = loadings_comp1,
                            Comp2_Loading = loadings_comp2)
  } else {
    loadings_df <- data.frame(Feature = feature_list,
                            Comp1_Loading = loadings_comp1,
                            Comp2_Loading = loadings_comp2)
  }


  top_features <- loadings_df |>
  mutate(abs_loading_comp1 = abs(.data$Comp1_Loading),
         abs_loading_comp2 = abs(.data$Comp2_Loading)) |>
  arrange(dplyr::desc(.data$abs_loading_comp1 + .data$abs_loading_comp2)) |>
  head(topk)
  loading_scale <- 1
  if (topk > 0){
  loading_scale <- max(abs(scores))/(4*max(abs(top_features$Comp1_Loading)))
  }

  if (filter_group == TRUE){
    plsda_df <- plsda_df |> filter(.data$Group %in% group_list)
  }

 plot <-  ggplot(plsda_df, aes(x = .data$Comp1, y = .data$Comp2, color = .data$Group)) +
    geom_point(size = 3) +
    theme_classic() +
    stat_ellipse(level = 0.90) +
    ggtitle("PLS-DA Plot") +
    labs(x = "Component 1", y = "Component 2") +
    scale_color_manual(values = color) +
    theme(legend.position = "right")+
    geom_segment(data = top_features,
                aes(x = 0, y = 0, xend = .data$Comp1_Loading * loading_scale, yend = .data$Comp2_Loading * loading_scale),  # Scale the arrows
                arrow = grid::arrow(length = grid::unit(0.3, "cm")), color = "grey", linewidth = 1) +
    # Add labels for the top 10 features
    ggrepel::geom_text_repel(data = top_features,
              aes(x = .data$Comp1_Loading * loading_scale, y = .data$Comp2_Loading * loading_scale, label = .data$Feature),
              color = "black", vjust = 1.5, size = 3)
  plot
  if (save_output) {
    ggsave(paste0(outdir, 'PLSDA_plot.pdf'), height = 6, width = 6)
    readr::write_csv(loadings_df, paste0(outdir, 'PLSDA_loadings.csv'))
  }
  return(list(plot = plot, df = plsda_df, loadings = loadings_df))
}

#' Generate input files to be used for pheatmap from the mmo object
#'
#' This function generates heatmap inputs from the mmo object, including fold change or mean values,
#' distance matrix, and row labels for custom-annotated features.
#'
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param filter_feature Boolean to filter features by feature_list (default: FALSE)
#' @param feature_list A vector of feature names to filter (default: NULL)
#' @param filter_group Boolean to filter groups by group_list (default: FALSE)
#' @param group_list A vector of group names to filter (default: NULL)
#' @param summarize The summarization method to use. Options are 'fold_change' or 'mean' (default: 'mean')
#' @param control_group The group to use as control for fold change calculation (default: 'ctrl')
#' @param normalization The normalization method to use. Options are 'None', 'Log', 'Meancentered', or 'Z'
#' @param distance The distance metric to use. Options are 'dreams', 'cosine', or 'm2ds' (default: 'dreams')
#' @return A list containing the following elements:
#' - FC_matrix: A matrix of fold change or mean values
#' - dist_matrix: A distance matrix based on the specified distance metric
#' - row_label: A vector of row labels for custom-annotated features (See AddCustomAnnot()). If no custom annotation is available, feature IDs are used.
#' - heatmap_data: A data frame containing the heatmap data with feature IDs and values
#' @export
#' @examplesIf FALSE
#' # Generate heatmap inputs to visualize fold change values with log normalization and dreams distance
#' heatmap_inputs <- GenerateHeatmapInputs(
#'  mmo, summarize = 'fold_change', control_group = 'Control',
#'  normalization = 'None', distance = 'dreams'
#' )
#' # Generate heatmap inputs to visualize mean values
#' heatmap_inputs <- GenerateHeatmapInputs(
#'  mmo, summarize = 'mean', normalization = 'None', distance = 'dreams'
#' )
#' # The resulting list contains FC_matrix, dist_matrix, row_label, and heatmap_data
#' # A heatmap can be generated using pheatmap
#' # 'clustering_distance_rows' option make the dendrogram follows chemical distances of features.
#' #  -Delete this option to visualize the heatmap following cannonical clustering
#' pheatmap(mat = heatmap_inputs$FC_matrix,
#'     cluster_rows = TRUE, #do not change
#'     clustering_distance_rows = heatmap_inputs$dist_matrix,
#'     cluster_cols = TRUE,
#'     clustering_method = "average", #UPGMA
#'     show_rownames = TRUE,
#'     show_colnames = TRUE,
#'     cellwidth = 25,
#'     cellheight = 0.05,
#'     treeheight_row = 100,
#'     fontsize_row = 3,
#'     fontsize_col = 15,
#'     scale = 'none',
#'     annotation_names_row = TRUE,
#'     labels_row = heatmap_inputs$row_label,
#'     )
GenerateHeatmapInputs <- function(mmo, filter_feature = FALSE, feature_list = NULL,
                                filter_group = FALSE, group_list = NULL,
                                summarize = 'mean', control_group = 'ctrl',
                                normalization = 'None', distance = 'dreams') {
  # 12.1.1. Get summarized data (group mean or FC)
  if (filter_group){
    group_means <- GetGroupMeans(mmo, normalization = normalization, filter_group = TRUE, group_list = group_list)
  } else {
    group_means <- GetGroupMeans(mmo, normalization = normalization)
  }
  if (summarize == 'fold_change'){
    fold_change <- GetLog2FoldChange(group_means, control_group = control_group)
    heatmap_data <- fold_change
    heatmap_data[[control_group]] <- NULL
  } else if(summarize == 'mean'){
    heatmap_data <- group_means
  }
  # 12.1.2. Filter features
  # Determine distance metric
  distance_matrix <- GetDistanceMat(mmo, distance = distance)
  heatmap_data <- heatmap_data |> filter(id %in% rownames(distance_matrix)) # remove features not in distance matrix

  # make matrix for heatmap
  FC_matrix <- as.matrix(heatmap_data[,-1])
  rownames(FC_matrix) <- heatmap_data$id
  # Reorder the rows of distance_matrix to match the order of FC_matrix_
  distance_matrix <- distance_matrix[rownames(FC_matrix), rownames(FC_matrix)]
  dist_matrix <- as.dist(distance_matrix)

  row_label <- rownames(FC_matrix)
  if (filter_feature){
    filter_list <- feature_list
    filter_id <- FeatureToID(mmo, filter_list)
    filter_id <- filter_id[filter_id %in% rownames(distance_matrix)] # remove custom-annotated but not in the distance matrix
    filter_distance <- distance_matrix[filter_id, filter_id]
    heatmap_data <- heatmap_data |> filter(id %in% filter_id)

    # make matrix for heatmap
    FC_matrix <- as.matrix(heatmap_data[,-1])
    rownames(FC_matrix) <- heatmap_data$id


    # Reorder the rows of distance_matrix to match the order of FC_matrix_
    filter_distance <- filter_distance[rownames(FC_matrix), rownames(FC_matrix)]
    dist_matrix <- as.dist(filter_distance)
    #Label custm-annotated features
    row_label <- rownames(FC_matrix)
    for (i in 1:length(rownames(FC_matrix))){
      id <- rownames(FC_matrix)[i]
      custom_annot <- mmo$custom_annot$custom_annot[mmo$custom_annot$id == id]
      if (length(custom_annot[[1]]) > 0) {
        row_label[i] <- custom_annot[[1]]
      }
    }
  }
  return(list(FC_matrix = FC_matrix, dist_matrix = dist_matrix, row_label = row_label, heatmap_data = heatmap_data))
}

#' PlotNPCStackedBar
#'
#' This function generates a stacked bar plot showing the count of features in each group categorized by NPC_pathway.
#' It uses the mmo object with sirius annotation and normalized data.
#' Make sure you don't run ReplaceZero() before using this function, as it may remove presence/absence information.
#'
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param group_col The column name in metadata to use for grouping samples
#' @param outdir The output file path for the stacked bar plot (e.g., 'NPC_stacked_bar.png')
#' @param width The width of the output plot
#' @param height The height of the output plot
#' @param save_output boolean, whether to save the output plot
#' @return A list containing the stacked bar plot and the data used to generate it
#' @export
#' @examplesIf FALSE
#' PlotNPCStackedBar(
#'  mmo, group_col = 'treatment',
#'  outdir = 'NPC_stacked_bar.png', width = 6, height = 3
#' )
PlotNPCStackedBar <- function(mmo, group_col, outdir, width = 6, height = 3, save_output = TRUE) {
  mmo <- SwitchGroup(mmo, group_col)
  feature_data <- mmo$feature_data
  metadata <- mmo$metadata

  # For each group, get features present in any sample
  group_features <- lapply(unique(metadata$group), function(grp) {
    samples <- metadata |> filter(.data$group == grp) |> pull(.data$sample)
    present <- feature_data |> dplyr::select(all_of(samples))
    feature_data$feature[base::rowSums(!is.na(present) & present > 0) > 0]
  })
  names(group_features) <- unique(metadata$group)

  # Build long data frame: feature, group, NPC_pathway
  annot <- mmo$sirius_annot[, c("feature", "NPC#pathway")]
  colnames(annot) <- c("feature", "NPC_pathway")

  bar_df <- do.call(rbind, lapply(names(group_features), function(grp) {
    data.frame(
      feature = group_features[[grp]],
      group = grp,
      stringsAsFactors = FALSE
    )
  }))
  bar_df <- merge(bar_df, annot, by = "feature", all.x = TRUE)
  bar_df <- bar_df[!is.na(bar_df$NPC_pathway) & bar_df$NPC_pathway != "", ]

  # Count features per group and NPC_pathway
  plot_df <- bar_df |>
    dplyr::group_by(group, NPC_pathway) |>
    dplyr::summarise(count = dplyr::n(), .groups = "drop")

  # Set colors for NPC_pathway
  npc_pathways <- unique(plot_df$NPC_pathway)
  .require_pkg("RColorBrewer")
  bar_colors <- setNames(RColorBrewer::brewer.pal(min(length(npc_pathways), 8), "Set2"), npc_pathways)

  # Plot stacked bar by NPC_pathway
  plot <- ggplot(plot_df, aes(x = .data$group, y = .data$count, fill = .data$NPC_pathway, label = .data$count)) +
    geom_bar(stat = "identity", position = "stack") +
    geom_text(aes(group = .data$NPC_pathway), position = position_stack(vjust = 0.5), size = 3, color = "white", fontface = "bold") +
    scale_fill_manual(values = bar_colors) +
    coord_flip() +
    labs(x = "Group", y = "Feature Count", fill = "NPC Pathway") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  if (save_output){
    ggsave(paste0(outdir, 'NPC_stacked_bar.pdf'), width = width, height = height)
    readr::write_csv(plot_df, paste0(outdir, 'NPC_stacked_bar.csv'))
  }
  return(list(plot = plot, df = plot_df))
}

#' Enrichment analysis for Canopus-predicted terms
#'
#' This function performs enrichment analysis for Canopus-predicted terms on a given list of features.
#'
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param list_test A vector containing names of features to analyze
#' @param pthr The threshold for adjusted p-value to be considered significant (default: 0.1)
#' @param sig A logical value indicating whether to return only significant terms (default: TRUE)
#' @param term_level The level of term to use for enrichment analysis
#'               Options are 'NPC_pathway', 'NPC_superclass', 'NPC_class', 'ClassyFire_superclass', 'ClassyFire_class',
#'              'ClassyFire_subclass', 'ClassyFire_level5', or 'ClassyFire_most_specific' (default: 'NPC_pathway')
#' @param representation The representation type for enrichment analysis. Options are 'greater' for overrepresentation (default: 'greater')
#' @param pval pvalue options-pval or fdr (default: 'pval')
#' @return A data frame containing the enrichment results, including term level, term name, subset count, total count, fold enrichment, p-value, and adjusted p-value (FDR)
#' @export
#' @examplesIf FALSE
#' # Perform enrichment analysis for a list of features using NPC_pathway level
#' sig_terms <- CanopusLevelEnrichmentAnal(
#'  mmo, list_test = c("feature1", "feature2"), pthr = 0.1,
#'  sig = TRUE, term_level = 'NPC_pathway', representation = 'greater'
#' )
#' # Perform enrichment analysis for a list of features using ClassyFire_class level and return all terms
#' all_terms <- CanopusLevelEnrichmentAnal(
#'  mmo, list_test = c("feature1", "feature2"), pthr = 0.1,
#'  sig = FALSE, term_level = 'ClassyFire_class', representation = 'greater'
#' )
CanopusLevelEnrichmentAnal <- function(mmo,list_test, pthr = 0.1, sig=TRUE, term_level = 'NPC_pathway', representation = 'greater', pval = 'pval'){
  all_feature <- mmo$sirius_annot
  subset_feature <- mmo$sirius_annot |> filter(.data$feature %in% list_test)
  # print(paste('total features:', nrow(all_feature), 'list_test features:', nrow(subset_feature)))
  # Select the appropriate term level for enrichment analysis
  if (term_level == "NPC_pathway") {
    all_feature$classifications_split <- all_feature[['NPC#pathway']]
    subset_feature$classifications_split <- subset_feature[['NPC#pathway']]
  } else if (term_level == "NPC_superclass") {
    all_feature$classifications_split <- all_feature[['NPC#superclass']]
    subset_feature$classifications_split <- subset_feature[['NPC#superclass']]
  } else if (term_level == "NPC_class") {
    all_feature$classifications_split <- all_feature[['NPC#class']]
    subset_feature$classifications_split <- subset_feature[['NPC#class']]
  } else if (term_level == "ClassyFire_superclass") {
    all_feature$classifications_split <- all_feature[['ClassyFire#superclass']]
    subset_feature$classifications_split <- subset_feature[['ClassyFire#superclass']]
  } else if (term_level == "ClassyFire_class") {
    all_feature$classifications_split <- all_feature[['ClassyFire#class']]
    subset_feature$classifications_split <- subset_feature[['ClassyFire#class']]
  } else if (term_level == "ClassyFire_subclass") {
    all_feature$classifications_split <- all_feature[['ClassyFire#subclass']]
    subset_feature$classifications_split <- subset_feature[['ClassyFire#subclass']]
  } else if (term_level == "ClassyFire_level5") {
    all_feature$classifications_split <- all_feature[['ClassyFire#level 5']]
    subset_feature$classifications_split <- subset_feature[['ClassyFire#level 5']]
  } else if (term_level == "ClassyFire_most_specific") {
    all_feature$classifications_split <- all_feature[['ClassyFire#most specific class']]
    subset_feature$classifications_split <- subset_feature[['ClassyFire#most specific class']]
  } else {
    stop("Invalid term level. Please choose a valid term level.")
  }

  total_term_counts <- table(unlist(all_feature$classifications_split))
  subset_term_counts <- table(unlist(subset_feature$classifications_split))

  total_term_counts['None'] <- sum(is.na(all_feature$classifications_split))
  subset_term_counts['None'] <- sum(is.na(subset_feature$classifications_split))

  # Perform enrichment analysis using Fisher's exact test
  enrichment_results <- sapply(names(subset_term_counts), function(term) {
    contingency_matrix <- matrix(c(
      subset_term_counts[[term]],
      sum(subset_term_counts) - subset_term_counts[[term]],
      total_term_counts[[term]],
      sum(total_term_counts) - total_term_counts[[term]]
    ), nrow = 2, byrow = TRUE)
    fisher.test(contingency_matrix, alternative = representation)$p.value
  })
  # Adjust p-values for multiple testing
  adjusted_pvalues <- p.adjust(enrichment_results, method = "fdr")
  # Create a results dataframe
  results <- data.frame(
    term_level = term_level,
    term = names(enrichment_results),
    subsetcount = as.numeric(subset_term_counts[names(enrichment_results)]),
    totalcount = as.numeric(total_term_counts[names(enrichment_results)]),
    foldenrichment = (as.numeric(subset_term_counts[names(enrichment_results)]) / length(subset_feature))/(as.numeric(total_term_counts[names(enrichment_results)]) / nrow(all_feature)),
    pval = enrichment_results,
    fdr = adjusted_pvalues
  )
  results <- results |> filter(.data$term != 'None')
  # Filter for significantly enriched terms
  if(pval == 'pval'){
    significant_terms <- results |>
      filter(.data$pval < pthr) |>
      arrange(.data$pval)
  } else if (pval == 'fdr'){
    significant_terms <- results |>
      filter(.data$fdr < pthr) |>
      arrange(.data$fdr)
  } else {
    stop("Invalid pval option. Please choose 'pval' or 'fdr'.")
  }
  if(sig==TRUE){
    return(significant_terms)
  }else{
    return(results)
  }
}

#' Generate a plot for enrichment analysis of Canopus-predicted terms
#'
#' This function generates a plot for enrichment analysis of Canopus-predicted terms,
#' showing fold enrichment, p-value, and subset count for each term level.
#'
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param feature_list A vector containing names of features to analyze
#' @param pthr The threshold for adjusted p-value to be considered significant (default: 0.05)
#' @param outdir The output file path for the enrichment plot
#' @param height The height of the output plot in inches (default: 5)
#' @param width The width of the output plot in inches (default: 5)
#' @param pval pvalue options-pval or fdr (default: 'pval')
#' @param save_output boolean, whether to save the output plot (default: TRUE)
#' @return A list containing the enrichment plot and the enrichment results
#' @export
#' @examplesIf FALSE
#' CanopusListEnrichmentPlot(
#'  mmo, feature_list = DAMs_up$control_vs_treatment1.up,
#'  pthr = 0.05, outdir = 'canopus_enrichment_plot.pdf',
#'  height = 5, width = 5
#' )
#'
CanopusListEnrichmentPlot <- function(mmo, feature_list, pthr = 0.05, outdir, height = 5, width = 5, pval = 'pval', save_output = TRUE){
  term_levels = c('NPC_class', 'NPC_superclass', 'NPC_pathway', 'ClassyFire_superclass', 'ClassyFire_class', 'ClassyFire_subclass', 'ClassyFire_level5', 'ClassyFire_most_specific')
  sig.canopus <- data.frame(term = character(),  term_level = character(),subsetcount = double(), totalcount = double(), foldenrichment = double(), pval = double(), fdr = double())
  for (term_level in term_levels){
    sig.canopus <- rbind(sig.canopus, CanopusLevelEnrichmentAnal(mmo, feature_list, pthr = pthr, sig = TRUE, term_level = term_level, representation = 'greater', pval = pval))
  }
  sig.canopus <- sig.canopus |> arrange(dplyr::desc(.data$foldenrichment))
  plot <- ggplot(sig.canopus, aes(x = .data$foldenrichment, y = reorder(.data$term, .data$foldenrichment), color = -log(.data$fdr), size = .data$subsetcount)) +
    geom_point() +
    scale_color_gradient(low = 'grey', high = 'red') +
    theme_classic()+
    facet_grid(term_level ~ ., scales = 'free_y', space = 'free', switch = 'y')+
    xlim(0,max(sig.canopus$foldenrichment+1))
    #facet_wrap(~term_level, ncol = 1, scales = 'free_y', strip.position = 'right', shrink = TRUE)
  plot

  if (save_output){
    ggsave(paste0(outdir, 'enrichment.pdf'), height = height, width = width)
    readr::write_csv(sig.canopus, paste0(outdir, 'enrichment.csv'))
  }
  return(list(plot = plot, df = sig.canopus))
}

#' Generate a plot for enrichment analysis of Canopus-predicted terms across multiple levels
#'
#' This function generates a plot for enrichment analysis of Canopus-predicted terms across multiple levels,
#' showing fold enrichment, p-value, and subset count for each term level.
#'
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param feature_list A vector containing names of features to analyze
#' @param pthr The threshold for adjusted p-value to be considered significant (default: 0.05)
#' @param outdir The output file path for the enrichment plot
#' @param height The height of the output plot in inches (default: 5)
#' @param width The width of the output plot in inches (default: 5)
#' @param topn The number of top terms to display in the plot (default: 5)
#' @param pval pvalue options-pval or fdr (default: 'pval')
#' @param save_output boolean, whether to save the output plot (default: TRUE)
#' @return A list containing the enrichment plot and the enrichment results
#' @export
#' @examplesIf FALSE
#' CanopusListEnrichmentPlot_2(
#'  mmo, feature_list = DAMs_up$control_vs_treatment1.up,
#'  pthr = 0.05, outdir = 'canopus_enrichment_plot_topn.pdf',
#'  height = 5, width = 5, topn = 5
#' )
CanopusListEnrichmentPlot_2 <- function(mmo, feature_list, pthr = 0.05, outdir, height = 5, width = 5, topn = 5, pval = 'pval', save_output = TRUE){
  term_levels = c('NPC_class', 'NPC_superclass', 'NPC_pathway', 'ClassyFire_superclass', 'ClassyFire_class', 'ClassyFire_subclass', 'ClassyFire_level5', 'ClassyFire_most_specific')
  sig.canopus <- data.frame(term = character(),  term_level = character(),subsetcount = double(), totalcount = double(), foldenrichment = double(), pval = double(), fdr = double())
  for (term_level in term_levels){
    sig.canopus <- rbind(sig.canopus, CanopusLevelEnrichmentAnal(mmo, feature_list, pthr = pthr, sig = TRUE, term_level = term_level, representation = 'greater', pval = pval))
  }
  sig.canopus$term <- paste(sig.canopus$term, ';', sig.canopus$term_level)
  sig.canopus <- sig.canopus |> dplyr::slice_max(order_by = -.data$pval, n = topn)
  sig.canopus <- sig.canopus |> dplyr::arrange(dplyr::desc(.data$foldenrichment))
  plot <- ggplot(sig.canopus, aes(x = .data$foldenrichment, y = reorder(.data$term, .data$foldenrichment), color = -log(.data$fdr), size = .data$subsetcount)) +
    geom_point() +
    scale_color_gradient(low = 'grey', high = 'red') +
    theme_classic()+
    xlim(0,max(sig.canopus$foldenrichment+1))+
    ylab('Chemical Class')
  plot
  if (save_output){
    ggsave(outdir, height = height, width = width)
    readr::write_csv(sig.canopus, paste0(outdir, 'enrichment.csv'))
  }
  return(list(plot = plot, df = sig.canopus))
}

#' Generate a plot for enrichment analysis of Canopus-predicted terms at a specific level using a list of vectors of features
#'
#' This function generates a plot for enrichment analysis of Canopus-predicted terms at a specific level,
#' showing fold enrichment, p-value, and subset count for each term.
#'
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param comp.list A list to analyze, where each element is a vector of feature names
#' @param term_level The level of term to use for enrichment analysis.
#'               Options are 'NPC_pathway', 'NPC_superclass', 'NPC_class',
#'              'ClassyFire_superclass', 'ClassyFire_class', 'ClassyFire_subclass',
#'             'ClassyFire_level5', or 'ClassyFire_most_specific' (default: 'NPC_pathway')
#' @param pthr The threshold for adjusted p-value to be considered significant (default: 0.1)
#' @param representation The representation type for enrichment analysis. Options are 'greater' for overrepresentation (default: 'greater')
#' @param outdir The output directory for saving the plot and the enrichment results (default: 'enrichment')
#' @param height The height of the output plot in inches (default: 5)
#' @param width The width of the output plot in inches (default: 5)
#' @param pval pvalue options-pval or fdr (default: 'pval')
#' @param save_output boolean, whether to save the output plot (default: TRUE)
#' @return A list containing the enrichment plot and the enrichment results
#' @export
#' @examplesIf FALSE
#' # Perform enrichment analysis for multiple comparisons using NPC_pathway level
#' comp.list <- list(
#'   comparison1 = DAMs_up$control_vs_treatment1.up,
#'   comparison2 = DAMs_up$control_vs_treatment2.up
#' )
#' CanopusLevelEnrichmentPlot(
#'  mmo, comp.list = comp.list, term_level = 'NPC_pathway',
#'  pthr = 0.1, representation = 'greater', outdir = 'enrichment_plot',
#'  height = 5, width = 5
#' )
CanopusLevelEnrichmentPlot <- function(mmo = mmo, comp.list, term_level = 'NPC_pathway',pthr = 0.1, representation = 'greater', outdir = 'enrichment', height = 5, width = 5, pval = 'pval', save_output = TRUE){
  df.EA <- data.frame()
  sig.terms <- c()
  for(list in names(comp.list)){
    # Calculate enrichment score for all terms
    res <- CanopusLevelEnrichmentAnal(mmo = mmo, list_test = comp.list[[list]],sig=FALSE, pthr = pthr, representation = representation, term_level = term_level, pval = pval)
    res <- res |> mutate(comp = list)
    df.EA <- dplyr::bind_rows(df.EA, res)
    # get terms that are at least once enriched in one comparison
    res.sig <- CanopusLevelEnrichmentAnal(mmo = mmo, list_test = comp.list[[list]],sig=TRUE, pthr = pthr, representation = representation, term_level = term_level, pval = pval)
    sig.terms <- append(sig.terms, res.sig$term)
  }
  sig.terms <- unique(sig.terms)
  df.EA.sig <- df.EA |> filter(.data$term %in% sig.terms)
  if (pval == 'pval'){
    df.EA.sig <- df.EA.sig |>
      mutate(label = cut(
        .data$pval,
        breaks = c(0,0.001, 0.01, 0.05, 0.1, 1),
        labels = c("***", "**", "*", ".", "")
      ))
    plot <- ggplot(data = df.EA.sig, aes(x = .data$comp, y = .data$term, label = .data$label))+
      geom_point(aes(size = .data$subsetcount, color = .data$pval))+
      geom_text()+
      scale_size_area(name = 'Count', max_size = 10)+
      scale_color_gradient2(low = 'red', high = 'grey', mid = 'grey', midpoint = 0.4)+
      theme_minimal()+
      theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.5))+
      xlab('Comparisons')+
      ylab('Chemical classes')
  } else if (pval == 'fdr'){
    df.EA.sig <- df.EA.sig |>
      mutate(label = cut(
        .data$fdr,
        breaks = c(0,0.001, 0.01, 0.05, 0.1, 1),
        labels = c("***", "**", "*", ".", "")
      ))
    plot <- ggplot(data = df.EA.sig, aes(x = .data$comp, y = .data$term, label = .data$label))+
      geom_point(aes(size = .data$subsetcount, color = .data$fdr))+
      geom_text()+
      scale_size_area(name = 'Count', max_size = 10)+
      scale_color_gradient2(low = 'red', high = 'grey', mid = 'grey', midpoint = 0.4)+
      theme_minimal()+
      theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.5))+
      xlab('Comparisons')+
      ylab('Chemical classes')
  }
  plot
  if (save_output){
    ggsave(paste0(outdir, '.pdf'), width = width, height = height)
    readr::write_csv(df.EA, paste0(outdir, '.csv'))
    readr::write_csv(df.EA.sig, paste0(outdir, '_sig.csv'))
  }
  return(list(plot = plot, df = df.EA))
}

#' Generate a plot for enrichment analysis of Canopus-predicted terms across all levels
#'
#' This function generates a plot for enrichment analysis of Canopus-predicted terms across all levels,
#' showing fold enrichment, p-value, and subset count for each term level.
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param comp.list A list to analyze, where each element is a vector of feature names
#' @param terms The terms to analyze. Options are 'all_terms', 'NPC', 'ClassyFire', or 'custom' (default: 'all_terms')
#' @param term_levels list of custom term levels to use
#' @param pthr The threshold for adjusted p-value to be considered significant (default: 0.1)
#' @param representation The representation type for enrichment analysis. Options are 'greater' for overrepresentation (default: 'greater')
#' @param outdir The output directory for saving the plot and the enrichment results (default: 'enrichment')
#' @param height The height of the output plot in inches (default: 10)
#' @param width The width of the output plot in inches (default: 8)
#' @param pval pvalue options-pval or fdr (default: 'pval')
#' @param save_output boolean, whether to save the output plot (default: TRUE)
#' @return A list of the plot and the enrichment results
#' @export
#' @examplesIf FALSE
#' comp.list <- list(
#'   comparison1 = DAMs_up$control_vs_treatment1.up,
#'   comparison2 = DAMs_up$control_vs_treatment2.up
#' )
#' CanopusAllLevelEnrichmentPlot(
#'  mmo, comp.list = comp.list, terms = 'all_terms',
#'  pthr = 0.1, representation = 'greater', outdir = 'enrichment_all_levels',
#'  height = 10, width = 8
#' )
#' CanopusAllLevelEnrichmentPlot(
#'  mmo, comp.list = comp.list, terms = 'NPC',
#'  pthr = 0.1, representation = 'greater', outdir = 'enrichment_NPC_levels',
#'  height = 10, width = 8
#' )
#' CanopusAllLevelEnrichmentPlot(
#'  mmo, comp.list = comp.list, terms = 'ClassyFire',
#'  pthr = 0.1, representation = 'greater', outdir = 'enrichment_ClassyFire_levels',
#'  height = 10, width = 8
#' )
CanopusAllLevelEnrichmentPlot <- function(mmo = mmo, comp.list, terms = 'all_terms', term_levels = NULL, pthr = 0.1, representation = 'greater', outdir = 'enrichment', height = 10, width = 8, pval = 'pval', save_output = TRUE){
  df.EA <- data.frame()
  sig.terms <- c()
  if(terms == 'all_terms'){
    term_levels = c('NPC_class', 'NPC_superclass', 'NPC_pathway', 'ClassyFire_superclass', 'ClassyFire_class', 'ClassyFire_subclass', 'ClassyFire_level5', 'ClassyFire_most_specific')
  } else if (terms == 'NPC'){
    term_levels = c('NPC_class', 'NPC_superclass', 'NPC_pathway')
  } else if (terms == 'ClassyFire'){
    term_levels = c('ClassyFire_superclass', 'ClassyFire_class', 'ClassyFire_subclass', 'ClassyFire_level5', 'ClassyFire_most_specific')
  } else if (terms == 'custom'){
    term_levels = term_levels
  }
  for(term_level in term_levels){
    for(list in names(comp.list)){
      # Calculate enrichment score for all terms
      res <- CanopusLevelEnrichmentAnal(mmo = mmo, list_test = comp.list[[list]],sig=FALSE, pthr = pthr, representation = representation, term_level = term_level, pval = pval)
      res <- res |> mutate(comp = list)
      df.EA <- dplyr::bind_rows(df.EA, res)
      # get terms that are at least once enriched in one comparison
      res.sig <- CanopusLevelEnrichmentAnal(mmo = mmo, list_test = comp.list[[list]],sig=TRUE, pthr = pthr, representation = representation, term_level = term_level, pval = pval)
      sig.terms <- append(sig.terms, res.sig$term)
    }
    sig.terms <- unique(sig.terms)
    df.EA.sig <- df.EA |> filter(.data$term %in% sig.terms)
    if (pval == 'pval'){
      df.EA.sig <- df.EA.sig |>
        mutate(label = cut(
          .data$pval,
          breaks = c(0,0.001, 0.01, 0.05, 0.1, 1),
          labels = c("***", "**", "*", ".", "")
        ))
      plot <- ggplot(data = df.EA.sig, aes(x = .data$comp, y = .data$term, label = .data$label))+
        geom_point(aes(size = .data$subsetcount, color = .data$pval))+
        geom_text()+
        scale_size_area(name = 'Count', max_size = 10)+
        scale_color_gradient2(low = 'red', high = 'grey', mid = 'grey', midpoint = 0.4)+
        theme_minimal()+
        theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.5))+
        xlab('Comparisons')+
        ylab('Chemical classes')+
        facet_grid(term_level ~ ., scales = 'free_y', space = 'free', switch = 'y')
    } else if (pval == 'fdr'){
      df.EA.sig <- df.EA.sig |>
        mutate(label = cut(
          .data$fdr,
          breaks = c(0,0.001, 0.01, 0.05, 0.1, 1),
          labels = c("***", "**", "*", ".", "")
        ))
      plot <- ggplot(data = df.EA.sig, aes(x = .data$comp, y = .data$term, label = .data$label))+
        geom_point(aes(size = .data$subsetcount, color = .data$fdr))+
        geom_text()+
        scale_size_area(name = 'Count', max_size = 10)+
        scale_color_gradient2(low = 'red', high = 'grey', mid = 'grey', midpoint = 0.4)+
        theme_minimal()+
        theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.5))+
        xlab('Comparisons')+
        ylab('Chemical classes')+
        facet_grid(term_level ~ ., scales = 'free_y', space = 'free', switch = 'y')
    }
  }
  plot
  if (save_output){
    ggsave(paste0(outdir, '.pdf'), width = width, height = height)
    readr::write_csv(df.EA, paste0(outdir, '.csv'))
    readr::write_csv(df.EA.sig, paste0(outdir, '_sig.csv'))
  }
  return(list(plot = plot, df = df.EA))
}


#' Metabolite Set Enrichment Analysis (MSEA)
#'
#' This function performs Metabolite Set Enrichment Analysis (MSEA) using the fgsea package.
#' It takes a ranked list of feature scores and tests for enrichment of metabolite sets based on Canopus-predicted terms.
#' The results are saved as a CSV file and a PDF plot.
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param feature_name A vector of feature names corresponding to the feature scores
#' @param feature_score A vector of feature scores (e.g., log2 fold changes)
#' @param term_level The level of term to use for enrichment analysis.
#'               Options are 'NPC_pathway', 'NPC_superclass', 'NPC_class',
#'              'ClassyFire_superclass', 'ClassyFire_class', 'ClassyFire_subclass',
#'             'ClassyFire_level5', or 'ClassyFire_most_specific' (default: 'NPC_class')
#' @param pthr The threshold for adjusted p-value to be considered significant (default: 0.05)
#' @param outdir The directory to save the output files (default: 'MSEA')
#' @param width The width of the output plot in inches (default: 8)
#' @param height The height of the output plot in inches (default: 12)
#' @param sig A logical value indicating whether to return only significant terms (default: FALSE)
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @return A list of the plot and the enrichment results
#' @export
#' @examplesIf FALSE
#' # Perform MSEA using NPC_class level
#' MSEA(
#'  mmo, feature_name = rownames(DE_results), feature_score = DE_results$log2FoldChange,
#'  term_level = 'NPC_class', pthr = 0.05, outdir = 'MSEA_NPC_class',
#'  width = 8, height = 12, sig = FALSE
#' )
MSEA <- function(mmo, feature_name, feature_score, term_level = 'NPC_class', pthr = 0.05, outdir = 'MSEA', width = 8, height = 12, sig = FALSE, save_output = TRUE){
  # Create a named vector of feature scores
  .require_pkg("fgsea")
  ranked_list <- feature_score
  names(ranked_list) <- feature_name
  ranked_list <- sort(ranked_list, decreasing = TRUE)

  # Retrieve metabolite sets based on the specified term level
  if(term_level == 'NPC_class'){
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['NPC#class']])
  } else if (term_level == 'NPC_superclass'){
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['NPC#superclass']])
  } else if (term_level == 'NPC_pathway'){
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['NPC#pathway']])
  } else if (term_level == "ClassyFire_superclass") {
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['ClassyFire#superclass']])
  } else if (term_level == "ClassyFire_class") {
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['ClassyFire#class']])
  } else if (term_level == "ClassyFire_subclass") {
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['ClassyFire#subclass']])
  } else if (term_level == "ClassyFire_level5") {
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['ClassyFire#level 5']])
  } else if (term_level == "ClassyFire_most_specific") {
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['ClassyFire#most specific class']])
  } else {
    stop("Invalid term level. Please choose a valid term level.")
  }
  msea_res <- fgsea::fgsea(pathways = metabolite_sets,
                       stats    = ranked_list,
                       minSize  = 5,   # minimum number of features in a class
                       maxSize  = 1500,
                       nPermSimple = 10000)
  msea_res <- msea_res |> arrange(.data$padj)
  # readr::write_csv(msea_res, paste0(outdir,'_', term_level,'_results.csv'))
  if (sig) {
    msea_res <- msea_res |> filter(.data$padj < pthr)
  }
  plot <- ggplot(msea_res, aes(x = reorder(.data$pathway, .data$NES), y = .data$NES)) +
    geom_point(shape = 21, aes(color = .data$padj < 0.05, size = .data$size, fill = -log(.data$padj)), stroke = 1) +
    coord_flip() +
    geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
    scale_fill_gradient(low = "grey", high = "red") +
    scale_color_manual(values = c("TRUE" = 'black', "FALSE" = 'white')) +
    guides(shape = "none") +
    labs(x = "Metabolite Class", y = "Normalized Enrichment Score (NES)", title = "MSEA Results", color = "-log10(padj)", size = "Set Size") +
    theme_classic() +
    theme(legend.position = "top", axis.text.y = element_text(size = 6))
  plot
  if (save_output){
    ggsave(paste0(outdir,'_', term_level,'.pdf'), width = width, height = height)
    readr::write_csv(msea_res, paste0(outdir,'_', term_level,'_results.csv'))
  }
  return (list(plot = plot, df = msea_res))
}


#' FeaturePhenotypeCorrelation
#'
#' This function performs correlation analysis of a specific feature against a phenotype in the metadata.
#' It can use linear mixed models (LMM), simple linear regression (LM), or Pearson correlation.
#' The default regression line of the plot uses linear model
#'
#' @param mmo The mmo object with feature data and metadata
#' @param feature The name of the feature to analyze
#' @param phenotype The name of the phenotype  in the metadata
#' @param groups A vector of group names from the metadata containing phenotype data
#' @param model The type of regression model to use. Options are 'lmm' for linear mixed model, 'lm' for simple linear regression, or 'pearson' for Pearson correlation (default: 'lmm')
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'Z')
#' @param outdir The directory to save the output files
#' @param width The width of the output plot in inches (default: 6)
#' @param height The height of the output plot in inches (default: 6)
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @return A list of the plot and the raw data
#' @export

FeaturePhenotypeCorrelation <- function(mmo, feature, phenotype, groups, model = 'lm', normalization = 'Z', outdir = 'FeaturePhenotypeCorrelation', width = 6, height = 6, save_output = TRUE){
  .require_pkg("ggrepel")
  feature <- GetNormFeature(mmo, normalization)
  metadata <- mmo$metadata

  # Get phenotype phenotype from the metadata, get the feature value from the feature matrix, then combine
  phenotype.df <- data.frame(sample = metadata$sample, group = metadata$group, phenotype = metadata[,phenotype]) |> filter(.data$group %in% groups)
  feature_df <- data.frame(sample = colnames(feature[,-(1:2)]), feature_value = as.numeric(feature[feature$feature == feature, -(1:2)]))
  combined_df <- merge(phenotype.df, feature_df, by='sample')

  # Perform linear mixed model or simple linear regression
  if (model == 'lmm'){
    fit <- lme4::lmer(combined_df$phenotype ~ combined_df$feature_value + (1|combined_df$group))
    p_value <- summary(fit)$coefficients[2, 5]
  } else if (model == 'lm'){
    fit <- lm(combined_df$phenotype ~ combined_df$feature_value)
    p_value <- summary(fit)$coefficients[2, 4]
  } else if (model %in% c('pearson', 'spearman', 'kendall')){
    correlation <- cor.test(combined_df$phenotype, combined_df$feature_value, method = model)
    p_value <- correlation$p.value
  } else {
    stop("Invalid model type. Please use 'lmm', 'lm', 'pearson', 'spearman' or 'kendall'")
  }

  # Plot the fit using ggplot
  plot <-ggplot(combined_df, aes(x = .data$feature_value, y = .data$phenotype, color = .data$group)) +
    geom_point(size = 3) +
    geom_smooth(method = "lm", se = TRUE, color = "black") +
    ggrepel::geom_text_repel(aes(label = sample), size = 2.5, show.legend = FALSE) +
    theme_classic() +
    labs(title = paste("Regression of", feature, "against", phenotype, "phenotype"),
         x = "Feature Value",
         y = "phenotype") +
    theme(legend.position = "right") +
    annotate("text", x = Inf, y = Inf, label = paste("p-value:", signif(p_value, digits = 4)),
             hjust = 1.1, vjust = 1.1, size = 3, color = "black")
  plot
  if (save_output){
    ggsave(paste0(outdir,'_', feature,'_vs_', phenotype,'.pdf'), height = height, width = width)
    readr::write_csv(combined_df, paste0(outdir,'_', feature,'_vs_', phenotype,'_data.csv'))
  }
  return (list(plot = plot, df = combined_df))
}


#' Screen feature-phenotype correlation
#'
#' Use metadata-provided variables (any phenotypes or environmental variables) to screen feature-phenotype correlation
#' linear model, linear mixed model (using groups as random effect), or correlation (Pearson, Spearman, Kendall) are supported
#'
#' @param mmo The mmo object with feature data and metadata
#' @param phenotype The name of the phenotype in the metadata
#' @param groups A vector of group names from the metadata containing phenotype data
#' @param model The type of regression model to use. Options are 'lmm' for linear mixed model, 'lm' for simple linear regression, or 'pearson', 'spearman', 'kendall' for correlation (default: 'lm')
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'Z')
#' @return A list of the plot and the raw data
#' @export
ScreenFeaturePhenotypeCorrelation <- function(mmo, phenotype, groups, model = 'lm', normalization = 'None'){
  # Load feature and metadata
  feature <- GetNormFeature(mmo, normalization)
  metadata <- mmo$metadata
  # Generate df for analysis
  if (missing(groups)) {
    groups <- unique(metadata$group)
    message("'groups' is not provided, using all groups")
  }
  phenotype_df <- data.frame(sample = metadata$sample, group = metadata$group, phenotype = metadata[,phenotype]) |> filter(.data$group %in% groups)
  corr_res <- data.frame(feature = character(), coefficient = numeric(), p_value = numeric(), stringsAsFactors = FALSE)
  for (i in 1:nrow(feature)){
    feature_name <- feature$feature[i]
    feature_df <- data.frame(sample = colnames(feature[,-(1:2)]), feature_value = as.numeric(feature[i, -(1:2)]))
    combined_df <- merge(phenotype_df, feature_df, by='sample')
    if (model == 'lmm'){
      fit <- lme4::lmer(combined_df$phenotype ~ combined_df$feature_value + (1|combined_df$group))
      p_value <- summary(fit)$coefficients[2, 5]
      coefficient <- lme4::fixef(fit)[2]
    } else if (model == 'lm'){
      fit <- lm(combined_df$phenotype ~ combined_df$feature_value)
      coefficient <- summary(fit)$coefficients[2]
      p_value <- summary(fit)$coefficients[2, 4]
    } else if (model %in% c('pearson', 'spearman', 'kendall')){
      correlation <- cor.test(combined_df$phenotype, combined_df$feature_value, method = model)
      p_value <- correlation[[3]]
      coefficient <- correlation[[4]]
    } else {
      stop("Invalid model type. Please use 'lmm', 'lm', 'pearson', 'spearman' or 'kendall'")
    }
    corr_res <- rbind(corr_res, data.frame(
      feature = feature_name, coefficient = coefficient, p_value = p_value))
  }
  return (corr_res)
  print(paste0(normalization, '-normalized feature data screened using ', model))
}


#' GetPerformanceFeatureRegression
#'
#' This function performs linear regression analysis of all features against a phenotype performance in the metadata.
#' @param mmo The mmo object with feature data and metadata
#' @param phenotype The name of the phenotype performance in the metadata
#' @param groups A vector of group names from the metadata containing performance data
#' @param DAM.list A list of DAMs to tag features
#' @param comparisons A list of pairwise comparisons to add fold change columns
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @export
#' @return A data frame containing regression results for each feature, including effect size, p-value, and fold change columns for specified comparisons.
#'
GetPerformanceFeatureRegression <- function(mmo, phenotype, groups, DAM.list, comparisons, normalization = 'None'){
  feature <- GetNormFeature(mmo, normalization)
  metadata <- mmo$metadata

  # phenotype.sample <- metadata |> filter(group %in% groups) |> pull(sample)
  # phenotype.area <- feature |> dplyr::select(id, feature, all_of(phenotype.sample))

  performance.linreg <- data.frame(pval = double(), effect.size = double())
  phenotype.df <- data.frame(sample = metadata$sample, group = metadata$group, performance = metadata[,phenotype]) |> filter(.data$group %in% groups)

  regression_results <- data.frame(feature = character(), effect.size = numeric(), p_value = numeric(), is.Spec = logical(), stringsAsFactors = FALSE)
  for (i in 1:nrow(feature)) {
    feature_name <- feature$feature[i]
    feature_df <- data.frame(sample = colnames(feature[,-(1:2)]), feature_value = as.numeric(feature[i, -(1:2)]))
    combined_df <- merge(phenotype.df, feature_df, by='sample')

    fit <- lm(combined_df$performance ~ combined_df$feature_value)
    effect.size <- coef(fit)[2]
    p_value <- summary(fit)$coefficients[2, 4]
    tag <- "else"
    for (list_name in names(DAM.list)) {
      if (feature_name %in% DAM.list[[list_name]]) {
        tag <- list_name
      }
    }
    #is.Spec <- feature_name %in% target

    regression_results <- rbind(regression_results, data.frame(
      feature = feature_name, effect.size = effect.size, p_value = p_value, tag = tag
    ))
  }
  # Add FC columns to regression_results
  for (comparison in comparisons) {
    fc_column <- paste(comparison, "log2FC", sep = "_")
    regression_results[[fc_column]] <- mmo$pairwise[[fc_column]][match(regression_results$feature, mmo$pairwise$feature)]
  }
  return(regression_results)
}

#' GetPerformanceFeatureLMM
#'
#' This function performs linear mixed model analysis of all features against a phenotype performance in the metadata.
#'
#' @param mmo The mmo object with feature data and metadata
#' @param phenotype The name of the phenotype performance in the metadata
#' @param groups A vector of group names from the metadata containing performance data
#' @param DAM.list A list of DAMs to tag features
#' @param comparisons A list of pairwise comparisons to add fold change columns
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'Z')
#' @return A data frame containing regression results for each feature, including effect size, p-value, and fold change columns for specified comparisons.
#' @export
GetPerformanceFeatureLMM <- function(mmo, phenotype, groups, DAM.list, comparisons, normalization = 'Z'){
  feature <- GetNormFeature(mmo, normalization)
  # if (normalization == 'None'){
  #   feature <- mmo$feature_data
  # } else if (normalization == 'Log'){
  #   feature <- mmo$log
  # } else if (normalization == 'Meancentered'){
  #   feature <- mmo$meancentered
  # } else if (normalization == 'Z'){
  #   feature <- mmo$zscore
  # }
  metadata <- mmo$metadata

  # get phenotype performance data
  phenotype.df <- data.frame(sample = metadata$sample, group = metadata$group, performance = metadata[,phenotype]) |> filter(.data$group %in% groups)
  #create an empty dataframe to store regression results
  regression_results <- data.frame(feature = character(), effect.size = numeric(), p_value = numeric(), is.Spec = logical(), stringsAsFactors = FALSE)
  # iterate regression analysis
  for (i in 1:nrow(feature)) {
    # for each feature, generate phenotype performance X feature value data
    feature_name <- feature$feature[i]
    feature_df <- data.frame(sample = colnames(feature[,-(1:2)]), feature_value = as.numeric(feature[i, -(1:2)]))
    combined_df <- merge(phenotype.df, feature_df, by='sample')

    # linear mixed model
    lmm_fit <- lme4::lmer(performance ~ feature_value + (1|group), data = combined_df)
    fixed_effects <- lme4::fixef(lmm_fit)
    effect.size <- fixed_effects[2]
    p_value <- summary(lmm_fit)$coefficients[2, 5]

    #tag using DAM.list
    tag <- "else"
    for (list_name in names(DAM.list)) {
      if (feature_name %in% DAM.list[[list_name]]) {
        tag <- list_name
      }
    }

    regression_results <- rbind(regression_results, data.frame(
      feature = feature_name, effect.size = effect.size, p_value = p_value, tag = tag
    ))
  }
  # Add FC columns to regression_results
  for (comparison in comparisons) {
    fc_column <- paste(comparison, "log2FC", sep = "_")
    regression_results[[fc_column]] <- mmo$pairwise[[fc_column]][match(regression_results$feature, mmo$pairwise$feature)]
  }
  return(regression_results)
}

#' GetPerformanceFeatureCorrelation
#'
#'
#' This function calculates the Pearson correlation between each feature and a specified phenotype performance in the metadata.
#' @param mmo The mmo object with feature data and metadata
#' @param phenotype The name of the phenotype performance in the metadata
#' @param groups A vector of group names from the metadata containing performance data
#' @param DAM.list A list of DAMs to tag features
#' @param comparisons A list of pairwise comparisons to add fold change columns
#' @param cor_method The correlation method to use. Options are 'pearson', 'spearman', or 'kendall' (default: 'pearson')
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @return A data frame containing correlation results for each feature, including effect size (correlation coefficient), p-value, and fold change columns for specified comparisons.
#' @export
GetPerformanceFeatureCorrelation <- function(mmo, phenotype, groups, DAM.list, comparisons, cor_method = 'pearson', normalization = 'None'){
  feature <- GetNormFeature(mmo, normalization)
  metadata <- mmo$metadata

  # phenotype.sample <- metadata |> filter(group %in% groups) |> pull(sample)
  # phenotype.area <- feature |> dplyr::select(id, feature, all_of(phenotype.sample))

  performance.linreg <- data.frame(pval = double(), effect.size = double())
  phenotype.df <- data.frame(sample = metadata$sample, group = metadata$group, performance = metadata[,phenotype]) |> filter(.data$group %in% groups)

  regression_results <- data.frame(feature = character(), effect.size = numeric(), p_value = numeric(), is.Spec = logical(), stringsAsFactors = FALSE)
  for (i in 1:nrow(feature)) {
    feature_name <- feature$feature[i]
    feature_df <- data.frame(sample = colnames(feature[,-(1:2)]), feature_value = as.numeric(feature[i, -(1:2)]))
    combined_df <- merge(phenotype.df, feature_df, by='sample')
    cor <- cor.test(combined_df$performance, combined_df$feature_value, method = cor_method)
    pval <- cor[[3]]
    cor <- cor[[4]]
    tag <- "else"
    for (list_name in names(DAM.list)) {
      if (feature_name %in% DAM.list[[list_name]]) {
        tag <- list_name
      }
    }
    #is.Spec <- feature_name %in% target

    regression_results <- rbind(regression_results, data.frame(
      feature = feature_name, effect.size = cor, p_value = pval, tag = tag
    ))
  }
  # Add FC columns to regression_results
  for (comparison in comparisons) {
    fc_column <- paste(comparison, "log2FC", sep = "_")
    regression_results[[fc_column]] <- mmo$pairwise[[fc_column]][match(regression_results$feature, mmo$pairwise$feature)]
  }
  return(regression_results)
}


#' PlotFoldchangeResistanceRegression
#'
#' This function plots the regression results of a feature against a fold change in resistance, including
#' regression line, p-value, and R-squared value.
#'
#' @param performance_regression The regression results data frame containing effect size, fold change, and tag. The output from GetPerformanceFeatureRegression, GetPerformanceFeatureLMM, or GetPerformanceFeatureCorrelation.
#' @param fold_change The name of the fold change column in the performance_regression dataframe
#' @param color A vector of colors for the points in the plot
#' @param outdir The output file path for the regression plot
#' @param width The width of the output plot in inches (default: 6)
#' @param height The height of the output plot in inches (default: 6)
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @return A list containing the regression plot and the performance regression data frame
#' @export
PlotFoldchangeResistanceRegression <- function(performance_regression, fold_change, color, outdir, width = 6, height = 6, save_output = TRUE){
  ind_fit <- lm(data = performance_regression, formula = as.formula(paste("-effect.size ~", fold_change)))
  summary_fit <- summary(ind_fit)
  p_value <- summary_fit$coefficients[2, 4]
  r_squared <- summary_fit$r.squared

  plot <- ggplot(performance_regression, aes(x = !!rlang::sym(fold_change), y = -.data$effect.size)) +
    geom_point(size = 0.5, aes(color = .data$tag)) +
    geom_smooth(method = "lm", se = TRUE, color = "black", level = 0.95) +
    xlab(fold_change) +
    ylab('-effect.size') +
    scale_color_manual(values = color) +
    theme_classic() +
    annotate("text", x = Inf, y = Inf, label = paste("p-value:", round(p_value, 500), "\nR-squared:", round(r_squared, 4)),
            hjust = 1.1, vjust = 1.1, size = 3, color = "black")+
    geom_hline(yintercept = 0, linetype = "dashed", color = "black")
  plot
  if (save_output){
    ggsave(paste0(outdir, ".png"), plot, height = height, width = width)
    readr::write_csv(performance_regression, file = paste0(outdir, ".csv"))
  }
  return(list(plot = plot, df = performance_regression))
}

#' PlotFoldchangeResistanceRegression_t
#'
#' This function plots the regression results of a feature against a fold change in resistance, including
#' regression line, p-value, and R-squared value. Transposed version of PlotFoldchangeResistanceRegression.
#'
#' @param performance_regression The regression results data frame containing effect size, fold change, and tag. The output from GetPerformanceFeatureRegression, GetPerformanceFeatureLMM, or GetPerformanceFeatureCorrelation.
#' @param fold_change The name of the fold change column in the performance_regression dataframe
#' @param color A vector of colors for the points in the plot
#' @param output_dir The output file path for the regression plot
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @param width The width of the output plot in inches (default: 6)
#' @param height The height of the output plot in inches (default: 6)
#' @return A list containing the regression plot and the performance regression data frame
#' @export
PlotFoldchangeResistanceRegression_t <- function(performance_regression, fold_change, color, output_dir, save_output = TRUE, width = 6, height = 6){
  ind_fit <- lm(data = performance_regression, formula = as.formula(paste(fold_change, "~ -effect.size")))
  summary_fit <- summary(ind_fit)
  p_value <- summary_fit$coefficients[4]
  r_squared <- summary_fit$r.squared

  plot <- ggplot(performance_regression, aes(x = -.data$effect.size, y = !!rlang::sym(fold_change))) +
    geom_point(size = 0.5, aes(color = .data$tag)) +
    geom_smooth(method = "lm", se = TRUE, color = "black", level = 0.95) +
    xlab('-effect.size') +
    ylab(fold_change) +
    scale_color_manual(values = color) +
    theme_classic() +
    annotate("text", x = Inf, y = Inf, label = paste("p-value:", round(p_value, 500), "\nR-squared:", round(r_squared, 4)),
            hjust = 1.1, vjust = 1.1, size = 3, color = "black")+
    geom_hline(yintercept = 0, linetype = "dashed", color = "black")+
    geom_vline(xintercept = 0, linetype = "dashed", color = "black")
  if (save_output){
    ggsave(paste0(output_dir, ".png"), plot, height = height, width = width)
    readr::write_csv(performance_regression, file = paste0(output_dir, ".csv"))
  }
  return(list(plot = plot, df = performance_regression))
}

#' PlotFoldchangeResistanceQuad
#'
#' This function plots the fold change resistance in a quadrant plot, categorizing points into quadrants based on their effect size and fold change.
#' It also performs a binomial test to assess the distribution of points across quadrants.
#' @param performance_regression The regression results data frame containing effect size, fold change, and tag. The output from GetPerformanceFeatureRegression, GetPerformanceFeatureLMM, or GetPerformanceFeatureCorrelation.
#' @param fold_change The name of the fold change column in the performance_regression dataframe
#' @param color A vector of colors for the points in the plot
#' @param output_dir The output file path for the quadrant plot
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @param width The width of the output plot in inches (default: 6)
#' @param height The height of the output plot in inches (default: 6)
#' @return A list containing the quadrant plot and the performance regression data frame
#' @export
PlotFoldchangeResistanceQuad <- function(performance_regression, fold_change, color, output_dir, save_output = TRUE, width = 6, height = 6){
  performance_regression <- performance_regression |>
  mutate(
    quadrant = dplyr::case_when(
      -effect.size > 0 & !!rlang::sym(fold_change) > 0 ~ "Q1",
      -effect.size < 0 & !!rlang::sym(fold_change) < 0 ~ "Q3",
      -effect.size < 0 & !!rlang::sym(fold_change) > 0 ~ "Q2",
      -effect.size > 0 & !!rlang::sym(fold_change) < 0 ~ "Q4",
      TRUE ~ "Edge"             # For points on axes
    )
  )
  q_counts <- table(performance_regression$quadrant)
  q13 <- sum(q_counts[c("Q1", "Q3")], na.rm = TRUE)
  q24 <- sum(q_counts[c("Q2", "Q4")], na.rm = TRUE)
  binom_test <- binom.test(q13, q13+q24, p = 0.5, alternative = "two.sided")

  plot <- ggplot(performance_regression, aes(x = -.data$effect.size, y = !!sym(fold_change))) +
    geom_point(size = 0.5, aes(color = .data$tag)) +
    xlab('-effect.size') +
    ylab(fold_change) +
    scale_color_manual(values = color) +
    theme_classic() +
    annotate("text", x = Inf, y = Inf, label = paste("p-value:", round(binom_test[[3]], 500)),
            hjust = 1.1, vjust = 1.1, size = 3, color = "black")+
    geom_hline(yintercept = 0, linetype = "dashed", color = "black")+
    geom_vline(xintercept = 0, linetype = "dashed", color = "black")
  plot
  if (save_output){
    ggsave(paste0(output_dir, ".png"), plot, height = height, width = width)
    readr::write_csv(performance_regression, file = paste0(output_dir, ".csv"))
  }
  return(list(plot = plot, df = performance_regression))
}
################### Singlevariate analyses ###################

#' Generate barplots for each feature and perform ANOVA
#'
#' This function generates bar plots for a specified feature across different groups in the metadata, performing ANOVA and Tukey's HSD test for post-hoc analysis.
#'
#' @param mmo The mmo object containing metadata and feature data
#' @param ID_list A list of feature IDs to analyze. Use FeatureToID() to convert feature names to IDs.
#' @param outdir The output directory to save the bar plots and ANOVA results
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param filter_group A boolean indicating whether to filter the feature values by a specific group list (default: FALSE)
#' @param group_list A list of groups to filter the feature values by, if filter_group is TRUE (default: NULL)
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @param width The width of the output plot in inches (default: 6)
#' @param height The height of the output plot in inches (default: 6)
#' @export
#' @return A list containing the bar plot and the ANOVA results
#' @examplesIf FALSE
#' AnovaBarPlot(mmo, ID_list = c("ID_1", "ID_2"), outdir = "output_directory", normalization = 'Z')
#' AnovaBarPlot(
#'  mmo, ID_list = c("ID_1", "ID_2"), outdir = "output_directory", normalization = 'Z',
#'  filter_group = TRUE, group_list = c("Group1", "Group2")
#' )
AnovaBarPlot <- function(mmo, ID_list, outdir, normalization = 'None', filter_group = FALSE, group_list = NULL, save_output = TRUE, width = 6, height = 6) {
  .require_pkg("ggbeeswarm")
  # Extract metadata and feature data
  metadata <- mmo$metadata
  feature_data <- GetNormFeature(mmo, normalization)

  # Iterate through each feature ID
  for (target_id in ID_list) {
    # Extract feature values and merge with metadata
    feature_values <- feature_data |>
      filter(.data$id == target_id) |>
      dplyr::select(-id, -feature) |>
      t() |>
      as.data.frame()
    colnames(feature_values) <- "value"
    feature_values$sample <- rownames(feature_values)
    feature_values <- merge(feature_values, metadata, by = "sample")
    if (filter_group == TRUE){
      feature_values <- feature_values |> filter(.data$group %in% group_list)
    }
    # Perform ANOVA
    anova <- anova_tukey_dunnett(feature_values, 'value ~ group')



    # Generate bar plot
    plot <- ggplot(feature_values, aes(x = .data$group, y = .data$value, fill = .data$group)) +
      geom_bar(stat = "summary", fun = "mean", position = "dodge") +
      geom_errorbar(stat = "summary", fun.data = "mean_se", position = position_dodge(width = 0.9), width = 0.2) +
      ggbeeswarm::geom_beeswarm() +
      theme_classic() +
      labs(title = paste("Feature:", target_id), x = "Group", y = "Value") +
      theme(legend.position = "none", axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
    plot
    if (save_output){
      ggsave(file.path(outdir, paste0(target_id, "_barplot.pdf")), plot = plot, width = width, height = height)
      write_anova(anova, outdir = paste0(outdir,'/', target_id, '_anova.csv'), way = 'oneway')
    }
    return(list(plot = plot, anova = anova))
  }
}

#' ExportFeaturesToCSV
#'
#' This function exports selected features, their annotations, and pairwise comparisons to a CSV file.
#'
#' @param mmo The mmo object containing feature data, annotations, and pairwise comparisons
#' @param feature_list A list of feature names to filter and export
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param output_dir The output directory to save the CSV file
#' @export
#' @examplesIf FALSE
#' ExportFeaturesToCSV(mmo, feature_list = Glucosinolates, normalization = 'Z', output_dir = 'output.csv')
#' ExportFeaturesToCSV(mmo, feature_list = DAMs_up$control_vs_treatment1.up, normalization = 'None', output_dir = 'output.csv')
#'
ExportFeaturesToCSV <- function(mmo, feature_list, normalization = 'None', output_dir){
  feature <- GetNormFeature(mmo, normalization = normalization) # Get normalized feature data
  # Filter the feature data, annotation, and DA analysis for the list provided
  selected_feature <- feature |> filter(feature %in% feature_list)
  selected_pairwise <- mmo$pairwise |> filter(feature %in% feature_list)
  # Merge all
  merged_df <- merge(mmo$sirius_annot, selected_feature, by = 'feature')
  merged_df <- merge(merged_df, selected_pairwise, by = 'feature')

  readr::write_csv(merged_df, output_dir)
}


#' GetRichness
#'
#' This function calculates the richness of features for each sample in the mmo object.
#' Richness is defined as the number of non-missing features observed in each sample.
#' @param mmo The mmo object containing feature data and metadata
#' @param filter_feature A boolean indicating whether to filter features based on a provided list (default: FALSE)
#' @param feature_list A list of features to include in the richness calculation if filter_feature is TRUE (default: NULL)
#' @return A data frame containing the richness for each sample, with columns for sample, richness, and group.
#' @export
GetRichness <- function(mmo, filter_feature = FALSE, feature_list = NULL) {
  feature_data <- mmo$feature_data
  if (filter_feature) {
    feature_data <- feature_data |> filter(.data$feature %in% feature_list)
  }
  richness <- apply(feature_data[, -(1:2)], 2, function(x) sum(!is.na(x)))

  metadata <- mmo$metadata
  groups <- c()
  for (col in colnames(feature_data)[-c(1, 2)]) {
    groups <- append(groups, metadata[metadata$sample == col, ]$group)
  }

  richness_df <- data.frame(sample = colnames(feature_data)[-c(1, 2)], richness = richness, group = groups)
  return(richness_df)
}

#' CalculateCumulativeRichness
#'
#' This function calculates the cumulative richness of features across groups in the metadata.
#' Cumulative richness is defined as the total number of unique features observed as groups are added sequentially.
#' @param mmo The mmo object containing feature data and metadata
#' @param groups A vector specifying the order of groups to consider for cumulative richness calculation
#' @return A data frame containing the cumulative richness for each group in the specified order, with columns for group and cumulative richness.
#' @export
#' @examplesIf FALSE
#' groups <- c("Control", "Treatment1", "Treatment2")
#' cumulative_richness <- CalculateCumulativeRichness(mmo, groups)
CalculateCumulativeRichness <- function(mmo, groups) {
  feature_data <- mmo$feature_data
  metadata <- mmo$metadata
  cumulative_richness <- numeric(length(groups))
  selected_features <- rep(FALSE, nrow(feature_data))
  for (i in seq_along(groups)) {
    selected_groups <- groups[1:i]
    selected_samples <- metadata |> filter(.data$group %in% selected_groups) |> pull(.data$sample)
    selected_data <- feature_data |> dplyr::select(all_of(selected_samples))
    selected_features <- selected_features | (rowSums(!is.na(selected_data)) > 0)
    cumulative_richness[i] <- sum(selected_features)
  }
  data.frame(group = groups, cumulative_richness = cumulative_richness)
}

#' BootstrapCumulativeRichness
#'
#' This function bootstraps the cumulative richness of features across groups in the metadata by randomizing the order of groups.
#' It performs multiple bootstrap iterations to estimate the mean and confidence intervals of cumulative richness at each step.
#' @param mmo The mmo object containing feature data and metadata
#' @param groups A vector of group names from the metadata to consider for cumulative richness calculation
#' @param n_boot The number of bootstrap iterations to perform (default: 1000)
#' @param ci The confidence interval width (e.g., 0.95 for 95% CI) (default: 0.95)
#' @return A data frame containing the mean cumulative richness and confidence intervals for each group index, with columns for group index, mean, lower CI, and upper CI.
#' @export
#' @examplesIf FALSE
#' groups <- c("Control", "Treatment1", "Treatment2")
#' bootstrapped_richness <- BootstrapCumulativeRichness(mmo, groups, n_boot = 1000, ci = 0.95)
BootstrapCumulativeRichness <- function(mmo, groups, n_boot = 1000, ci = 0.95) {
  # Bootstraps cumulative richness by randomizing group order within a direction
  # ci: confidence interval width (e.g., 0.5 for 25%-75%)
  lower_q <- (1 - ci) / 2
  upper_q <- 1 - lower_q
  n_groups <- length(groups)
  boot_mat <- matrix(NA, nrow = n_boot, ncol = n_groups)
  for (i in seq_len(n_boot)) {
    rand_order <- sample(groups)
    boot_mat[i, ] <- CalculateCumulativeRichness(mmo, rand_order)$cumulative_richness
  }
  # Each row is a bootstrap, each column is the cumulative richness after adding that many groups
  boot_df <- data.frame(
    group_index = rep(seq_len(n_groups), times = n_boot),
    bootstrap = rep(seq_len(n_boot), each = n_groups),
    richness = as.vector(t(boot_mat))
  )
  boot_summary <- boot_df |>
    dplyr::group_by(group_index) |>
    dplyr::summarise(
      mean = mean(.data$richness),
      lower = stats::quantile(.data$richness, lower_q),
      upper = stats::quantile(.data$richness, upper_q)
    ) |>
    dplyr::ungroup()
  as.data.frame(boot_summary)
}

#' CalculateNullCumulativeRichness
#'
#' This function calculates the null model of cumulative richness by randomizing samples regardless of group.
#' It performs multiple bootstrap iterations to estimate the mean and confidence intervals of cumulative richness at each step.
#' @param mmo The mmo object containing feature data and metadata
#' @param n_boot The number of bootstrap iterations to perform (default: 1000)
#' @param n_groups The number of groups to simulate for cumulative richness calculation
#' @param ci The confidence interval width (e.g., 0.95 for 95% CI) (default: 0.95)
#' @return A data frame containing the mean cumulative richness and confidence intervals for each group index, with columns for group index, mean, lower CI, and upper CI.
#' @export
#' @examplesIf FALSE
#' null_richness <- CalculateNullCumulativeRichness(mmo, n_boot = 1000, n_groups = 5, ci = 0.95)
CalculateNullCumulativeRichness <- function(mmo, n_boot = 1000, n_groups, ci = 0.95) {
  # Null model: randomize samples regardless of group, then add samples one by one
  feature_data <- mmo$feature_data
  metadata <- mmo$metadata
  all_samples <- metadata$sample
  n_features <- nrow(feature_data)
  samples_per_group <- ceiling(length(all_samples) / n_groups)
  boot_mat <- matrix(NA, nrow = n_boot, ncol = n_groups)
  lower_q <- (1 - ci) / 2
  upper_q <- 1 - lower_q
  for (i in seq_len(n_boot)) {
    rand_samples <- sample(all_samples)
    selected_features <- rep(FALSE, n_features)
    for (j in seq_len(n_groups)) {
      end_idx <- min(j * samples_per_group, length(rand_samples))
      selected_data <- feature_data |> dplyr::select(all_of(rand_samples[1:end_idx]))
      selected_features <- selected_features | (rowSums(!is.na(selected_data)) > 0)
      boot_mat[i, j] <- sum(selected_features)
    }
  }
  boot_df <- data.frame(
    group_index = rep(seq_len(n_groups), times = n_boot),
    bootstrap = rep(seq_len(n_boot), each = n_groups),
    richness = as.vector(t(boot_mat))
  )
  boot_summary <- boot_df |>
    dplyr::group_by(group_index) |>
    dplyr::summarise(
      mean = mean(.data$richness),
      lower = stats::quantile(.data$richness, lower_q),
      upper = stats::quantile(.data$richness, upper_q)
    ) |>
    dplyr::ungroup()
  as.data.frame(boot_summary)
}

#' CalcNormalizedAUC
#'
#' This function calculates the normalized area under the curve (AUC) for a cumulative richness curve.
#' The normalized AUC is computed by dividing the AUC by the maximum possible area, which is the product of the maximum group index and maximum cumulative richness.
#' @param curve A data frame containing the cumulative richness curve with columns for group index and cumulative richness
#' @return The normalized AUC value
#' @export
#' @examplesIf FALSE
#' curve <- CalculateCumulativeRichness(mmo, group =c("Control", "Treatment1", "Treatment2"))
#' norm_auc <- CalcNormalizedAUC(curve)
CalcNormalizedAUC <- function(curve) {
  curve$group_index <- seq_len(nrow(curve))
  x <- curve$group_index
  y <- curve$cumulative_richness
  auc <- sum(diff(x) * (utils::head(y, -1) + utils::tail(y, -1)) / 2)
  norm_auc <- auc / (max(x) * max(y))
  norm_auc
}

#' BootCumulRichnessAUC
#'
#' This function bootstraps the normalized area under the curve (AUC) for cumulative richness by randomizing the order of groups.
#' It performs multiple bootstrap iterations to estimate the distribution of normalized AUC values.
#' @param mmo The mmo object containing feature data and metadata
#' @param groups A vector of group names from the metadata to consider for cumulative richness calculation
#' @param n_boot The number of bootstrap iterations to perform (default: 500)
#' @return A numeric vector containing the normalized AUC values from each bootstrap iteration
#' @export
#' @examplesIf FALSE
#' groups <- c("Control", "Treatment1", "Treatment2")
#' bootstrapped_aucs <- BootCumulRichnessAUC(mmo, groups, n_boot = 500)
BootCumulRichnessAUC <- function(mmo, groups, n_boot = 500) {
  aucs <- numeric(n_boot)
  for (i in seq_len(n_boot)) {
    rand_order <- sample(groups)
    curve <- CalculateCumulativeRichness(mmo, rand_order)
    aucs[i] <- CalcNormalizedAUC(curve)
  }
  aucs
}

#' GetFunctionalHillNumber
#'
#' This function calculates the functional Hill number for a given mmo object, normalization method, and distance metric.
#' See https://nph.onlinelibrary.wiley.com/doi/full/10.1111/nph.18685 for details of the functional Hill number calculation.
#'
#' @param mmo The mmo object containing feature data and metadata
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param q The order of the Hill number to calculate (default: 1). Larger q values give more weight to evenness portion of the hill number over richness.
#' @param distance The distance metric to use for calculating dissimilarity. Options are 'dreams', 'm2ds', or 'cosine' (default: 'dreams')
#' @param filter_feature A boolean indicating whether to filter the feature data by a specific list (default: FALSE)
#' @param feature_list A list of feature names to filter the feature data by, if filter_feature is TRUE (default: NULL)
#' @return A data frame containing the functional Hill number for each group in the metadata, with columns for group and hill number.
#' @export
#' @examplesIf FALSE
#' hill_number <- GetFunctionalHillNumber(mmo, normalization = 'Z', q = 1, distance = 'dreams', filter_feature = FALSE)
#' hill_number <- GetFunctionalHillNumber(mmo, normalization = 'Z', q = 3, distance = 'dreams', filter_feature = TRUE, feature_list = Glucosinolates)
#
GetFunctionalHillNumber <- function(mmo, normalization = 'None',q = 1, distance = 'dreams', filter_feature = FALSE, feature_list = NULL){
  feature <- GetNormFeature(mmo, normalization = normalization)
  metadata <- mmo$metadata
  distance_matrix <- GetDistanceMat(mmo, distance = distance)
  # Scale the  distance matrix to be between 0 and 1

  if (filter_feature == TRUE){
    id_list <- FeatureToID(mmo, feature_list)
    id_list <- rownames(distance_matrix)[rownames(distance_matrix) %in% id_list]
    distance_matrix <- distance_matrix[id_list, id_list]
  }
  scaled_dissimilarity <- distance_matrix / max(distance_matrix)
  # Calculate the relative proportions of each feature and reorder them to match the order of the distance matrix
  q.feature <- feature |> filter(.data$id %in% colnames(scaled_dissimilarity))
  relative_proportions <- apply(q.feature[, -(1:2)], 2, function(x) x / sum(x))
  rownames(relative_proportions) <- q.feature$id
  relative_proportions <- relative_proportions[rownames(scaled_dissimilarity), ]
  scaled_dissimilarity <- as.matrix(scaled_dissimilarity)
  raoQ <- colSums(relative_proportions * (scaled_dissimilarity %*% relative_proportions))
  # Calculate Hill
  functional_hill_number <- c()
  if (q == 1){
    mask <- relative_proportions > 0
    Plog <- ifelse(mask, relative_proportions/raoQ * log(relative_proportions/raoQ), 0)
    DP <- scaled_dissimilarity %*% relative_proportions
    vals <- 2 * colSums(Plog * DP)
    functional_hill_number <- exp(-vals)
  } else {
    Pq <- (relative_proportions/raoQ)^q
    DPq <- scaled_dissimilarity %*% Pq
    vals <- colSums(Pq*DPq)
    functional_hill_number <- vals^(1/(1-q))
  }
  names(functional_hill_number) <- colnames(relative_proportions)
  # Get the group information
  groups <- c()
  for (col in colnames(feature)[-c(1, 2)]) {
    groups <- append(groups, metadata[metadata$sample == col, ]$group)
  }

  hill_df <- data.frame(group = groups, hill_number = functional_hill_number)
  return(hill_df)
}

#' GetHillNumbers
#'
#' This function calculates the Hill numbers for a given mmo object, normalization method, and order of the Hill number without considering feature dissimilarity.
#'
#'
#' @param mmo The mmo object containing feature data and metadata
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param q The order of the Hill number to calculate (default: 0)
#' @param filter_feature A boolean indicating whether to filter the feature data by a specific list (default: FALSE)
#' @param feature_list A list of feature names to filter the feature data by, if filter_feature is TRUE (default: NULL)
#' @return A data frame containing the Hill number for each group in the metadata, with columns for group and hill number.
#' @export
#' @examplesIf FALSE
#' hill_number <- GetHillNumbers(mmo, normalization = 'Z', q = 1, filter_feature = FALSE)
#' hill_number <- GetHillNumbers(mmo, normalization = 'Z', q = 2, filter_feature = TRUE, feature_list = Glucosinolates)
GetHillNumbers <- function(mmo, normalization = 'None', q = 0, filter_feature = FALSE, feature_list = NULL) {
  feature <- GetNormFeature(mmo, normalization = normalization)
  if (filter_feature == TRUE) {
    feature <- feature |> filter(feature %in% feature_list)
  }
  metadata <- mmo$metadata

  hill_numbers <- apply(feature[, -(1:2)], 2, function(x) {
    p <- x / sum(x)
    if (q == 0) {
      return(length(p))
    } else if (q == 1) {
      return(exp(-sum(p * log(p))))
    } else {
      return((sum(p^q))^(1 / (1 - q)))
    }
  })

  groups <- c()
  for (col in colnames(feature)[-c(1, 2)]) {
    groups <- append(groups, metadata[metadata$sample == col, ]$group)
  }

  hill_df <- data.frame(group = groups, hill_number = hill_numbers)


  return(hill_df)
}

#' GetAlphaDiversity
#'
#' This function calculates the alpha diversity for a given mmo object, order of the Hill number, normalization method, mode (weighted or unweighted), distance metric, and optional feature filtering.
#' Unweighted mode uses Hill numbers without considering feature dissimilarity, while weighted mode uses functional Hill numbers that account for feature dissimilarity.
#'
#' @param mmo The mmo object containing feature data and metadata
#' @param q The order of the Hill number to calculate (default: 1)
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param mode The mode of diversity calculation. Options are 'weighted' or 'unweighted' for chemical distance(default: 'weighted')
#' @param distance The distance metric to use for calculating dissimilarity. Options are 'dreams', 'm2ds', or 'cosine' (default: 'dreams')
#' @param filter_feature A boolean indicating whether to filter the feature data by a specific list (default: FALSE)
#' @param feature_list A list of feature names to filter the feature data by, if filter_feature is TRUE (default: NULL)
#' @return A data frame containing the alpha diversity for each group in the metadata, with columns for group and alpha diversity value.
#' @export
#' @examplesIf FALSE
#' alpha_diversity <- GetAlphaDiversity(mmo, q = 1, normalization = 'None',
#'  mode = 'weighted', distance = 'dreams', filter_feature = FALSE)
#' alpha_diversity <- GetAlphaDiversity(mmo, q = 2, normalization = 'Z',
#'  mode = 'unweighted', filter_feature = TRUE, feature_list = Glucosinolates)
GetAlphaDiversity <- function(mmo, q = 1, normalization = 'None', mode = 'weighted', distance = 'dreams', filter_feature = FALSE, feature_list = NULL){
  if (mode == 'weighted'){
    GetFunctionalHillNumber(mmo, normalization = normalization, q = q, distance = distance, filter_feature = filter_feature, feature_list = feature_list)
  } else if (mode == 'unweighted'){
    GetHillNumbers(mmo, normalization = normalization, q = q, filter_feature = filter_feature, feature_list = feature_list)
  } else{
    print('mode should be weighted or unweighted')
  }
}

#' GetSpecializationIndex
#'
#' This function calculates the specialization index for a given mmo object, normalization method, and optional filtering by groups and features.
#'
#' @param mmo The mmo object containing feature data and metadata
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param filter_group A boolean indicating whether to filter the feature data by a specific group list (default: FALSE)
#' @param group_list A list of groups to filter the feature data by, if filter_group is TRUE (default: NULL)
#' @param filter_feature A boolean indicating whether to filter the feature data by a specific list (default: FALSE)
#' @param feature_list A list of feature names to filter the feature data by, if filter_feature is TRUE (default: NULL)
#' @export
#' @return A data frame containing the specialization index for each group in the metadata, with columns for group and specialization index.
#' @examplesIf FALSE
#' specialization_index <- GetSpecializationIndex(mmo, normalization = 'None', filter_group = FALSE)
#' specialization_index <- GetSpecializationIndex(mmo, normalization = 'Z', filter_group = TRUE, group_list = c('Control', 'Treatment1'), filter_feature = TRUE)
GetSpecializationIndex <- function(mmo, normalization = 'None', filter_group = FALSE, group_list = NULL, filter_feature = FALSE, feature_list = NULL){
  metadata <- mmo$metadata
  feature <- GetNormFeature(mmo, normalization)

  # All feature or filtered feature
  if (filter_feature == TRUE){
    feature <- feature |> filter(feature %in% feature_list)
  }
  if (filter_group == TRUE){
    samples <- c()
    for (group in group_list){
      samples <- append(samples, metadata |> filter(.data$group == !!group) |> pull(.data$sample))
    }
    feature <- feature |> dplyr::select(id, feature, all_of(samples))
  }

  # Get frequency matrix
  Pij <- feature[, -(1:2)]
  rownames(Pij) <- feature$feature
  Pij <- t(Pij)
  Pij <- Pij / rowSums(Pij)
  Pij[is.na(Pij)] <- 0

  # Get shannon diversity index
  # Pij.diversity <- Pij * log(Pij, base = 2)
  # Pij.diversity[is.na(Pij.diversity)] <- 0
  # Pij.diversity <- -rowSums(Pij.diversity)

  # Get specialization index
  Pi <- colSums(Pij)/nrow(Pij) # average frequency of each metabolite

  Si <- t((t(Pij)/Pi) * log((t(Pij)/Pi), base = 2)) # specialized degree
  Si[is.na(Si)] = 0
  Si <- colSums(Si)/ncol(Pij) # for each feature get average specialization index
  Pij.specialization <- colSums(t(Pij)*Si) # for each sample get specialization index
  # Retrieve group for each sample from metadata
  groups <- sapply(colnames(feature)[-c(1,2)], function(sample) {
    metadata$group[metadata$sample == sample]
  })
  output <- data.frame(group = groups, specialization = Pij.specialization)
}

#' GetBetaDiversity
#'
#' This function calculates the beta diversity for a given mmo object, method (Generalized Unifrac, bray, jaccard, or CSCS), normalization method, distance metric, and optional feature filtering.
#' Then it returns a distance matrix of beta diversity values.
#' The Generalized UniFrac and CSCS method requires a distance matrix of feature dissimilarity, which is calculated using the specified distance metric.
#' Bray-Curtis and Jaccard methods are calculated using the vegan package, not considering feature dissimilarity.
#'
#' @param mmo The mmo object containing feature data and metadata
#' @param method The method of beta diversity calculation. Options are 'Gen.Uni' for Generalized UniFrac, 'bray' for Bray-Curtis, 'jaccard' for Jaccard, or 'CSCS' for Compound Similarity and Chemical structural and compositional similarity (default: 'Gen.Uni')
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param distance The distance metric to use for calculating dissimilarity. Options are 'dreams', 'm2ds', or 'cosine' (default: 'dreams')
#' @param filter_feature A boolean indicating whether to filter the feature data by a specific list (default: FALSE)
#' @param feature_list A list of feature names to filter the feature data by, if filter_feature is TRUE (default: NULL)
#' @param filter_group A boolean indicating whether to filter the feature data by a specific group list (default: FALSE)
#' @param group_list A list of groups to filter the feature data by, if filter_group is TRUE (default: NULL)
#' @return A distance matrix of beta diversity values between samples.
#' @export
#' @examplesIf FALSE
#' beta_diversity <- GetBetaDiversity(mmo, method = 'Gen.Uni',
#'  normalization = 'None', distance = 'dreams', filter_feature = FALSE)
#' beta_diversity <- GetBetaDiversity(mmo, method = 'bray',
#'  normalization = 'Z', filter_feature = TRUE, feature_list = Glucosinolates,
#'  filter_group = TRUE, group_list = c('Control', 'Treatment1'))
GetBetaDiversity <- function(mmo, method = 'Gen.Uni', normalization = 'None', distance = 'dreams', filter_feature = FALSE, feature_list = NULL, filter_group = FALSE, group_list = NULL){
  # Get compound distance and build tree for UniFrac
  scaled_dissimilarity <- GetDistanceMat(mmo, distance = distance) / max(GetDistanceMat(mmo, distance = distance))
  if (filter_feature == TRUE) {
    id_list <- FeatureToID(mmo, feature_list)
    scaled_dissimilarity <- scaled_dissimilarity[id_list, id_list]
  }
  compound_tree <- ape::as.phylo(hclust(as.dist(scaled_dissimilarity), method = "average"))

  # Get feature matrix of relative proportion
  metadata <- mmo$metadata
  feature <- GetNormFeature(mmo, normalization)
  if (filter_group == TRUE){
    samples <- c()
    for (group in group_list){
      samples <- append(samples, metadata |> filter(.data$group == !!group) |> pull(sample))
    }
    feature <- feature |> dplyr::select(id, feature, all_of(samples))
  }
  feature <- feature |> filter(.data$id %in% colnames(scaled_dissimilarity))
  relative_proportions <- apply(feature[, -(1:2)], 2, function(x) x / sum(x))
  rownames(relative_proportions) <- feature$id
  relative_proportions <- relative_proportions[rownames(scaled_dissimilarity), ] #reorder
  relative_proportions <- t(relative_proportions)
  # Calculate Generalized UniFrac
  if (method == 'Gen.Uni') {
    guni <- GUniFrac::GUniFrac(relative_proportions, compound_tree, alpha = c(0, 0.5, 1), verbose = TRUE)
    beta_div <- guni$unifracs
  } else if (method == 'bray') {
    beta_div <- as.matrix(vegan::vegdist(relative_proportions, method = 'bray'))
  } else if (method == 'jaccard') {
    beta_div <- as.matrix(vegan::vegdist(relative_proportions, method = 'jaccard'))
  } else if (method == 'CSCS') {
    CSS <- 1-GetDistanceMat(mmo, distance = distance)
    diag(CSS)
    q.feature <- GetNormFeature(mmo, normalization = normalization) |> filter(.data$id %in% colnames(CSS))
    relative_proportions <- apply(q.feature[, -(1:2)], 2, function(x) x / sum(x))
    CSCS_all <- t(relative_proportions) %*% CSS %*% relative_proportions

    sample_names <- colnames(relative_proportions)
    n_samples <- length(sample_names)
    CSCS_matrix <- matrix(NA, nrow = n_samples, ncol = n_samples)
    rownames(CSCS_matrix) <- sample_names
    colnames(CSCS_matrix) <- sample_names
    for (i in 1:n_samples) {
      for (j in 1:n_samples) {
        CSCS_matrix[i,j] <- CSCS_all[i, j] / max(CSCS_all[i, i], CSCS_all[j, j])
      }
    }
    beta_div <- 1-CSCS_matrix
  } else {
    stop("Invalid method. Please use 'Gen.Uni', 'bray' or 'jaccard'")
  }


  return(beta_div)
}


#' NMDSplot
#'
#' This function generates a Non-metric Multidimensional Scaling (NMDS) plot based on the provided beta diversity distance matrix.
#' It also performs PERMANOVA analysis to assess the significance of group differences and saves the results to CSV files.
#' @param mmo The mmo object containing metadata
#' @param betadiv The beta diversity distance matrix, output of GetBetaDiversity()
#' @param outdir The outdir for the output files
#' @param width The width of the output NMDS plot (default: 6)
#' @param height The height of the output NMDS plot (default: 6)
#' @param color A vector of colors for the groups in the plot
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @return A list containing the NMDS plot, the NMDS coordinates, and the PERMANOVA results
#' @export
#' @examplesIf FALSE
#' beta_diversity <- GetBetaDiversity(mmo, method = 'Gen.Uni',
#'  normalization = 'None', distance = 'dreams', filter_feature = FALSE)
#' # Use method = 'bray' or 'jaccard' if you want to use just feature abundance
#' # without considering feature spectral dissimilarity
#' NMDSplot(mmo, betadiv = beta_diversity, outdir = 'output/NMDS', width = 6, height = 6)
NMDSplot <- function(mmo, betadiv, outdir, width = 6, height = 6, color, save_output = TRUE){
  .require_pkg("vegan")
  .require_pkg("ggrepel")
  metadata <- mmo$metadata
  nmds <- vegan::metaMDS(betadiv, k = 2, try = 50, trymax = 100)

  # Extract NMDS coordinates
  nmds_coords <- as.data.frame(vegan::scores(nmds, display = "sites"))
  groups <- c()
  for (row in rownames(nmds_coords)) {
    groups <- append(groups, metadata[metadata$sample == row, ]$group)
  }
  nmds_coords$group <- groups

  # Plot NMDS
  plot <- ggplot(nmds_coords, aes(x = .data$NMDS1, y = .data$NMDS2, color = .data$group)) +
    geom_point(size = 3) +
    #geom_text_repel(aes(label = group), size = 3) +
    theme_classic() +
    stat_ellipse(level = 0.90) +
    labs(x = "NMDS1", y = "NMDS2") +
    scale_color_manual(values = color) +
    theme(legend.position = "right")
  plot
  permanova <- permanova_stat(betadiv, mmo$metadata, mode = 'distance')
  if (save_output){
    ggsave(paste0(outdir, '_NMDS.pdf'), height = height, width = width)
    readr::write_csv(permanova$permanova_res, paste0(outdir, '_permanova_results.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_raw), paste0(outdir, '_pairwise_permanova_results.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_p_matrix), paste0(outdir, '_pairwise_permanova_pvalue_matrix.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_F_matrix), paste0(outdir, '_pairwise_permanova_F_matrix.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_R2_matrix), paste0(outdir, '_pairwise_permanova_R2_matrix.csv'))
  }
  return(list(plot = plot, df = nmds_coords, permanova = permanova))
}

#' PCoAplot
#'
#' This function generates a Principal Coordinates Analysis (PCoA) plot based on the provided beta diversity distance matrix.
#' It also performs PERMANOVA analysis to assess the significance of group differences and saves the
#' results to CSV files.
#' @param mmo The mmo object containing metadata
#' @param betadiv The beta diversity distance matrix, output of GetBetaDiversity
#' @param outdir The prefix for the output files
#' @param width The width of the output PCoA plot (default: 6
#' @param height The height of the output PCoA plot (default: 6)
#' @param color A vector of colors for the points in the plot
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @return A list containing the PCoA plot, the PCoA coordinates, and the PERMANOVA results
#' @export
#' @examplesIf FALSE
#' beta_diversity <- GetBetaDiversity(mmo, method = 'Gen.Uni',
#'  normalization = 'None', distance = 'dreams', filter_feature = FALSE)
#' PCoAplot(mmo, betadiv = beta_diversity, outdir = 'output/PCoA', width = 6, height = 6)
PCoAplot <- function(mmo, betadiv, outdir, width = 6, height = 6, color, save_output = TRUE){
  .require_pkg('ape')
  metadata <- mmo$metadata
  pcoa_res <- ape::pcoa(betadiv)
  pcoa_coords <- as.data.frame(pcoa_res$vectors[, 1:2])
  colnames(pcoa_coords) <- c("PCoA1", "PCoA2")
  pcoa_coords$group <- metadata$group[match(rownames(pcoa_coords), metadata$sample)]

  plot <- ggplot(pcoa_coords, aes(x = .data$PCoA1, y = .data$PCoA2, color = .data$group)) +
    geom_point(size = 3) +
    stat_ellipse(level = 0.90) +
    theme_classic() +
    labs(x = "PCoA1", y = "PCoA2") +
    scale_color_manual(values = color) +
    theme(legend.position = "right")
  plot
  permanova <- permanova_stat(betadiv, mmo$metadata, mode = 'distance')
  if (save_output){
    ggsave(paste0(outdir, '_PCoA.pdf'), height = height, width = width)
    readr::write_csv(permanova$permanova_res, paste0(outdir, '_permanova_results.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_raw), paste0(outdir, '_pairwise_permanova_results.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_p_matrix), paste0(outdir, '_pairwise_permanova_pvalue_matrix.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_F_matrix), paste0(outdir, '_pairwise_permanova_F_matrix.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_R2_matrix), paste0(outdir, '_pairwise_permanova_R2_matrix.csv'))
  }
  return(list(plot = plot, df = pcoa_coords, permanova = permanova))
}

#' CalculateGroupBetaDistance
#'
#' This function calculates the beta diversity distance between a reference group and other groups in the metadata.
#'
#' @param mmo The mmo object containing feature data and metadata
#' @param beta_div The beta diversity distance matrix, output of GetBetaDiversity()
#' @param reference_group The name of the reference group to compare against
#' @param groups A vector of group names from the metadata to calculate distances for
#' @return A data frame containing the group names, sample names, and their corresponding beta diversity distances from the reference group.
#' @export
#' @examplesIf FALSE
#' beta_diversity <- GetBetaDiversity(mmo, method = 'Gen.Uni',
#'  normalization = 'None', distance = 'dreams', filter_feature = FALSE)
#' group_distances <- CalculateGroupBetaDistance(mmo, beta_div = beta_diversity,
#'  reference_group = 'Control', groups = c('Control', 'Treatment1', 'Treatment2'))
CalculateGroupBetaDistance <- function(mmo, beta_div, reference_group, groups) {
  metadata <- mmo$metadata
  distances <- data.frame(group = character(), distance = numeric())

  for (group in groups) {
      group_samples <- metadata |> filter(group == !!group) |> pull(sample)
      reference_samples <- metadata |> filter(group == !!reference_group) |> pull(sample)

      for (sample in group_samples) {
        for (ref_sample in reference_samples) {
          distance <- beta_div[sample, ref_sample]
          distances <- rbind(distances, data.frame(group = group,sample = sample, distance = distance))
        }

    }
  }

  return(distances)
}

#' Save entire mmo object to a file (RDS)
#'
#' @param mmo The mmo object (list) to save
#' @param file File path to write (default: "mmo.rds")
#' @param compress Compression type passed to saveRDS ("gzip", "bzip2", "xz", or logical) (default: "xz")
#' @param include_session Logical; if TRUE attach sessionInfo() as an attribute to the saved object (default: TRUE)
#' @return Invisibly returns the file path
#' @export
SaveMMO <- function(mmo, file = "mmo.rds", compress = "xz", include_session = TRUE) {
  if (missing(mmo) || !is.list(mmo)) stop("mmo must be a list-like object")
  if (include_session) {
    attr(mmo, "saved_session_info") <- sessionInfo()
  }
  saveRDS(mmo, file = file, compress = compress)
  message("Saved mmo to: ", file)
  invisible(file)
}


#' Load an mmo object previously saved with SaveMMO
#'
#' This function returns the loaded mmo object (visible return). By default it prints basic
#' information about the R version and recorded packages that were present when the object
#' was saved.
#'
#' @param file Path to an RDS file created with SaveMMO
#' @param check_session Logical; if TRUE and save-time session info is present, print a short summary (default: TRUE)
#' @param verbose Logical; print messages about saved session info when available (default: TRUE)
#' @return The loaded mmo object (list)
#' @export
LoadMMO <- function(file, check_session = TRUE, verbose = TRUE) {
  if (!file.exists(file)) stop("File not found: ", file)
  mmo <- readRDS(file)
  if (check_session && !is.null(attr(mmo, "saved_session_info"))) {
    saved_si <- attr(mmo, "saved_session_info")
    if (verbose) {
      message("mmo was saved with R: ", saved_si$R.version$version.string)
      pkgs <- names(saved_si$otherPkgs)
      if (length(pkgs) > 0) message("Top packages at save-time: ", paste(head(pkgs, 20), collapse = ", "))
    }
  }
  return(mmo)
}


#' Print method for mmo objects
#' Provides a clean, human-readable overview of an `mmo` list object instead of
#' dumping the entire list when the object is printed in the console.
#' @param x An `mmo` object (a list with components such as `feature_data`,
#'   `metadata`, `pairwise`, etc.)
#' @param ... Additional arguments passed to other print methods (unused).
#' @return Invisibly returns `x` unchanged.
#' @export
print.mmo <- function(x, ...) {
  cat("MMO object\n")
  # Features
  if (!is.null(x$feature_data)) {
    cat("  Feature number: ",
        nrow(x$feature_data), "\n", sep = "")
  }

  # Samples & groups
  if (!is.null(x$metadata)) {
    n_samples <- nrow(x$metadata)
    n_groups  <- length(unique(x$metadata$group))
    cat("  ", n_samples, " samples in ", n_groups, " groups\n", sep = "")
  }

  # Components present
  cat("  MMO object contains: ",
      paste(names(x), collapse = ", "),
      "\n", sep = "")

  invisible(x)
}

#' HCplot
#'
#' Hierarchical clustering of samples from a precomputed beta-diversity matrix
#' and plotting as a phylogram with tip labels colored by species (or any grouping column).
#'
#' This function is intended for visualization (no cluster significance is implied).
#'
#' @param mmo The mmo object containing metadata in mmo$metadata
#' @param betadiv The beta diversity distance matrix, output of GetBetaDiversity()
#' @param outdir Output prefix for files (e.g., "output/HC"). If save_output=TRUE a PDF is saved.
#' @param group_col Metadata column name used to color tips (default: "Species_binomial")
#' @param sample_col Metadata column name containing sample IDs (default: "sample")
#' @param hclust_method hclust linkage method (default: "average"; alternatives: "complete","ward.D2")
#' @param palette Qualitative palette name for colorspace::qualitative_hcl (default: "Dark 3")
#' @param cex Tip label size (default: 0.6)
#' @param width PDF width (default: 10)
#' @param height PDF height (default: 7)
#' @param save_output Whether to save the plot to PDF (default: TRUE)
#' @return A list containing: hc (hclust), phy (phylo), tip_df (mapping), colors (named palette)
#' @export
#' @examplesIf FALSE
#' bet <- GetBetaDiversity(mmo, method='bray', normalization='Log', distance='dreams', filter_feature=FALSE)
#' HCplot(mmo, betadiv = bet, outdir = "output/HC_dreams_bray")
HCplot <- function(
    mmo,
    betadiv,
    outdir,
    group_col = "Species_binomial",
    sample_col = "sample",
    hclust_method = "average",
    palette = "Dark 3",
    cex = 0.6,
    width = 10,
    height = 7,
    save_output = TRUE
){
  .require_pkg("ape")
  .require_pkg("colorspace")

  metadata <- mmo$metadata
  if (is.null(metadata) || !is.data.frame(metadata))
    stop("mmo$metadata must be a data.frame.")

  if (!sample_col %in% names(metadata))
    stop("metadata is missing sample_col = '", sample_col, "'")
  if (!group_col %in% names(metadata))
    stop("metadata is missing group_col = '", group_col, "'")

  # Ensure betadiv has labels
  if (is.null(rownames(betadiv)) || is.null(colnames(betadiv)))
    stop("betadiv must have rownames and colnames equal to sample IDs.")

  # Convert to dist and hclust
  d <- as.dist(betadiv)
  hc <- stats::hclust(d, method = hclust_method)

  # Convert to phylo
  tr <- ape::as.phylo(hc)

  tip_ids <- tr$tip.label
  md_ids  <- as.character(metadata[[sample_col]])
  grp_map <- metadata[[group_col]]
  grp_vec <- grp_map[match(tip_ids, md_ids)]

  if (anyNA(grp_vec)) {
    bad <- tip_ids[is.na(grp_vec)]
    stop(
      "Group labels missing for some tree tips (ID mismatch between betadiv labels and metadata$",
      sample_col, "). Example missing IDs:\n",
      paste(head(bad, 25), collapse = "\n")
    )
  }
  grp_vec <- as.character(grp_vec)

  # Build palette
  grp_levels <- sort(unique(grp_vec))
  grp_cols <- setNames(colorspace::qualitative_hcl(length(grp_levels), palette = palette), grp_levels)
  tip_cols <- unname(grp_cols[grp_vec])

  tip_df <- data.frame(
    tip = tip_ids,
    group = grp_vec,
    color = tip_cols,
    stringsAsFactors = FALSE
  )

  # Plot
  main_title <- paste0("Hierarchical clustering (", hclust_method, ")")

  if (save_output) grDevices::pdf(paste0(outdir, "_HC.pdf"), width = width, height = height)
  op <- par(no.readonly = TRUE)
  on.exit({
    par(op)
    if (save_output) grDevices::dev.off()
  }, add = TRUE)

  par(mar = c(2, 2, 2, 12))  # wide right margin for labels
  plot(tr, type = "phylogram", cex = cex, tip.color = tip_cols, main = main_title)

  legend(
    "topleft",
    legend = grp_levels,
    col = unname(grp_cols[grp_levels]),
    pch = 15,
    cex = 0.6,
    bty = "n"
  )

  return(list(hc = hc, phy = tr, tip_df = tip_df, colors = grp_cols))
}


```


## R/250813_eCOMET_build_V3.R
```r
########################################################################################
# Define functions for data import and normalization
########################################################################################
# When this file is sourced directly (outside the package build), make sure the
# internal dependency checker exists so downstream calls to .require_pkg succeed.
if (!exists(".require_pkg", mode = "function")) {
  .require_pkg <- function(pkg) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      stop(pkg, " is required for this function. Install it with install.packages('", pkg, "').", call. = FALSE)
    }
  }
}

#' Import MZmine feature table and metadata to create a mmo object
#' @description
#' Reads an MZmine exported feature table (typically the full feature table) and a sample metadata table
#' to initialize an mmo object containing:
#' \itemize{
#'   \item \code{mmo$feature_data}: feature-by-sample abundance matrix (peak areas)
#'   \item \code{mmo$feature_info}: feature-level annotations (e.g., mz, rt, ranges, IDs)
#'   \item \code{mmo$metadata}: sample metadata with standardized \code{sample} and \code{group} columns
#' }
#' Sample columns in the MZmine table are matched to metadata using fuzzy string matching on area column names.
#'
#' @param mzmine_dir Path to the MZmine feature table CSV (should include feature-level columns and per-sample area columns)
#' @param metadata_dir Path to the metadata CSV file (must include sample_col and group_col)
#' @param group_col Column name in metadata used for grouping samples (e.g., treatment/species)
#' @param sample_col Column name in metadata used to identify and match samples to MZmine area columns
#' @param drop_missing_samples Logical. If FALSE (default), error when metadata samples are missing from
#' the MZmine table area columns. If TRUE, drop those samples from metadata (with a warning) and continue.
#' @param mz_col Optional m/z column name in the MZmine table (defaults to "mz" or "row m/z")
#' @param rt_col Optional RT column name in the MZmine table (defaults to "rt" or "row retention time")
#' @param max_distance Maximum edit distance used when fuzzy-matching metadata sample names to MZmine
#' area column names (default 5). Lower this for stricter matching.
#' @param feature_info_cols Character vector of feature-level columns to retain in \code{mmo$feature_info}.
#' Columns not present in the MZmine table are skipped with a warning.
#' @return A mmo object
#' @export
GetMZmineFeature <- function(mzmine_dir, metadata_dir, group_col, sample_col,
                             drop_missing_samples = FALSE,
                             mz_col = NULL, rt_col = NULL,
                             max_distance = 5,
                             feature_info_cols = c(
                               "id",
                               "rt", "rt_range:min", "rt_range:max",
                               "mz", "mz_range:min", "mz_range:max",
                               "feature_group",
                               "ion_identities:iin_id",
                               "ion_identities:ion_identities"
                             )) {

  mmo <- list()

  # MZmine table (feature-level columns + per-sample area columns)
  data <- read.csv(
    mzmine_dir,
    check.names = FALSE,
    stringsAsFactors = FALSE,
    na.strings = c("", "NA")
  )

  metadata <- read.csv(
    metadata_dir,
    check.names = FALSE,
    stringsAsFactors = FALSE,
    na.strings = c("", "NA")
  )

  if (missing(group_col) || !(group_col %in% names(metadata))) {
    stop("group_col must be provided and exist in the metadata file.", call. = FALSE)
  }
  if (missing(sample_col) || !(sample_col %in% names(metadata))) {
    stop("sample_col must be provided and exist in the metadata file.", call. = FALSE)
  }

  # --- detect mz / rt (or use overrides) ---
  if (is.null(mz_col)) {
    mz_col <- if ("mz" %in% names(data)) "mz"
    else if ("row m/z" %in% names(data)) "row m/z"
    else stop("No m/z column found (expected 'mz' or 'row m/z', or provide mz_col).", call. = FALSE)
  }
  if (is.null(rt_col)) {
    rt_col <- if ("rt" %in% names(data)) "rt"
    else if ("row retention time" %in% names(data)) "row retention time"
    else stop("No RT column found (expected 'rt' or 'row retention time', or provide rt_col).", call. = FALSE)
  }

  # --- stable feature key ---
  data <- data |>
    dplyr::mutate(feature = paste(.data[[mz_col]], .data[[rt_col]], sep = "_"))

  # --- sample names from metadata ---
  samples <- trimws(as.character(metadata[[sample_col]]))
  samples_core <- sub("\\.(mzML|mzXML|raw)$", "", samples, ignore.case = TRUE)

  # Helper: fuzzy-match MZmine "area" columns to metadata sample names
  find_area_columns <- function(data, samples_core, samples_full, max_distance = 5) {
    colnames_all <- names(data)

    area_idx <- grepl("area", colnames_all, ignore.case = TRUE)
    if (!any(area_idx)) {
      stop("No columns in the MZmine table contain the word 'area' (case-insensitive).", call. = FALSE)
    }
    candidates <- colnames_all[area_idx]

    strip_wrappers <- function(x) {
      x <- sub("^datafile[:.]", "", x)                                        # datafile: or datafile.
      x <- sub("(?i)( Peak area|:area|\\.area)$", "", x, perl = TRUE)         # suffix variants
      x <- sub("(?i)\\.(mzml|mzxml|raw)$", "", x, perl = TRUE)                # trailing extensions
      x
    }
    cand_core <- strip_wrappers(candidates)

    D <- utils::adist(samples_core, cand_core, ignore.case = TRUE)
    best_idx <- apply(D, 1L, which.min)
    best_d   <- D[cbind(seq_along(samples_core), best_idx)]
    keep <- is.finite(best_d) & best_d <= max_distance

    list(
      area_cols = candidates[best_idx[keep]],
      keep_idx = keep,
      missing_full = samples_full[!keep]
    )
  }

  match_res <- find_area_columns(
    data = data,
    samples_core = samples_core,
    samples_full = samples,
    max_distance = max_distance
  )

  missing_samples_full <- match_res$missing_full
  keep_idx <- match_res$keep_idx
  area_columns <- match_res$area_cols

  if (length(area_columns) == 0) {
    stop(
      "No area columns matched any samples from metadata within max_distance.\n",
      "Check that you supplied an MZmine feature table containing per-sample area columns and that sample names correspond to metadata.",
      call. = FALSE
    )
  }

  if (any(duplicated(area_columns))) {
    dup <- unique(area_columns[duplicated(area_columns)])
    stop(
      "Multiple samples matched the same area column(s): ",
      paste(dup, collapse = ", "),
      ". Consider renaming columns or lowering max_distance.",
      call. = FALSE
    )
  }

  # --- handle missing samples (default ERROR with guidance; optional drop) ---
  if (length(missing_samples_full) > 0) {

    msg <- paste0(
      "Metadata contains ", length(missing_samples_full),
      " sample(s) that do not have matching 'area' columns in the MZmine table:\n",
      paste(missing_samples_full, collapse = ", "),
      "\n\nThis can occur if MZmine removed columns during processing (e.g., blank subtraction removing all features).\n\n",
      "To proceed anyway and drop these samples from metadata, re-run with `drop_missing_samples = TRUE`."
    )

    if (!isTRUE(drop_missing_samples)) {
      stop(msg, call. = FALSE)
    } else {
      warning(paste0(msg, "\n\nProceeding because `drop_missing_samples = TRUE`."), call. = FALSE)
    }
  }

  # Enforce alignment (either no missing, or user allowed dropping)
  metadata <- metadata[keep_idx, , drop = FALSE]
  samples <- samples[keep_idx]
  samples_core <- samples_core[keep_idx]

  # --- coerce area columns to numeric (remove commas) ---
  data[area_columns] <- lapply(
    data[area_columns],
    function(x) as.numeric(gsub(",", "", x))
  )

  # --- build feature abundance table (mmo$feature_data) ---
  if (!("id" %in% names(data))) {
    stop("No feature id column identified in the MZmine table (expected column 'id').", call. = FALSE)
  }

  feature_df <- data |>
    dplyr::select(.data$id, .data$feature, dplyr::all_of(area_columns)) |>
    dplyr::rename_with(~ samples_core, .cols = dplyr::all_of(area_columns))

  feature_df$id <- gsub(" ", "", as.character(feature_df$id))

  # --- build feature info table (mmo$feature_info) ---
  # minimum required to be a useful feature_info
  required_min <- c("id", mz_col, rt_col)
  missing_min <- setdiff(required_min, names(data))
  if (length(missing_min) > 0) {
    stop(
      "The MZmine table is missing required feature-level columns: ",
      paste(missing_min, collapse = ", "),
      call. = FALSE
    )
  }

  # user-requested columns, but allow them to be absent (warn + skip)
  present_info <- intersect(feature_info_cols, names(data))
  absent_info  <- setdiff(feature_info_cols, names(data))
  if (length(absent_info) > 0) {
    warning(
      "Some requested feature_info columns were not present in the MZmine table and were skipped: ",
      paste(absent_info, collapse = ", "),
      call. = FALSE
    )
  }

  # Ensure key columns exist and are included
  present_info <- unique(c(present_info, "id", "feature"))

  feature_info <- data[, present_info, drop = FALSE]
  feature_info$id <- gsub(" ", "", as.character(feature_info$id))

  # Enforce column order: id, feature, then the rest
  col_order <- c("id", "feature", setdiff(names(feature_info), c("id", "feature")))
  feature_info <- feature_info[, col_order, drop = FALSE]
  rownames(feature_info) <- NULL

  # --- finalize metadata and output ---
  metadata$sample <- samples_core
  metadata$sample_full_exact <- samples
  metadata$group <- as.factor(metadata[[group_col]])

  mmo$feature_data <- feature_df
  mmo$feature_info <- feature_info
  mmo$metadata <- metadata

  class(mmo) <- "mmo"

  message("MMO object created.")
  message(paste0("Feature number: ", nrow(mmo$feature_data)))
  message(paste0(nrow(mmo$metadata), " samples in ", length(unique(mmo$metadata$group)), " groups"))

  return(mmo)
}




#' Switch the group column in the mmo object
#'
#' @description
#' This function switches the group column in the metadata of the mmo object to a new specified column.
#' The new group column must exist in the metadata file.
#' @param mmo The mmo object
#' @param new_group_col The name of the new group column in the metadata file
#' @return The mmo object with the updated group column
#' @export
#' @examplesIf FALSE
#' mmo <- SwitchGroup(mmo, new_group_col = "genotype")
SwitchGroup <- function(mmo, new_group_col) {
  if (missing(new_group_col) || !(new_group_col %in% colnames(mmo$metadata))) {
    stop("new_group_col must be provided and must exist in the metadata file.")
  }
  mmo$metadata$group <- as.factor(mmo$metadata[[new_group_col]])
  print(paste0('Group column switched to ', new_group_col))
  print(paste0(length(unique(mmo$metadata$group)), ' groups in total'))
  print(paste0('The list of groups are: ', paste(levels(mmo$metadata$group), collapse = ', ')))
  return(mmo)
}

#' Adding annotation from SIRIUS to the mmo object
#'
#' @description
#' This function reads SIRIUS structure identification and formula summary files,
#' and adds the annotations to the mmo object.
#' @param mmo The mmo object
#' @param canopus_structuredir Path to the SIRIUS structure_identification.tsv file
#' @param canopus_formuladir Path to the SIRIUS canopus_formula_summary.tsv file
#' @return The mmo object with SIRIUS annotations added
#' @export
#' @examplesIf FALSE
#' mmo <- AddSiriusAnnot(mmo,
#'  canopus_structuredir = "path/to/structure_identification.tsv",
#'  canopus_formuladir = "path/to/canopus_formula_summary.tsv"
#' )
#'
AddSiriusAnnot <- function(mmo, canopus_structuredir, canopus_formuladir){
  structure_identifications <- readr::read_tsv(canopus_structuredir, show_col_types = FALSE)
  structure_identifications$mappingFeatureId <- gsub(" ", "", structure_identifications$mappingFeatureId)
  canopus_formula_summary <- readr::read_tsv(canopus_formuladir, show_col_types = FALSE)
  canopus_formula_summary$mappingFeatureId <- gsub(" ", "", canopus_formula_summary$mappingFeatureId)
  siriused_ids <- unique(union(structure_identifications$mappingFeatureId, canopus_formula_summary$mappingFeatureId))
  sirius_df <- mmo$feature_data |> dplyr::select(.data$id, .data$feature)
  sirius_df <- sirius_df |>
  left_join(structure_identifications, by = c("id" = "mappingFeatureId"), multiple = "last") |>
  left_join(canopus_formula_summary, by = c("id" = "mappingFeatureId"), multiple = "last")
  mmo$sirius_annot <- sirius_df
  print('SIRIUS annotation added to mmo$sirius_annot')
  print("Duplicated annotation might be occurred in SIRIUS. Inspect the raw data to check the annotation")
  return(mmo)
}

#' Filter CANOPUS / SIRIUS annotations in an ecomet mmo object by probability threshold
#'
#' Applies a minimum-probability cutoff to selected CANOPUS (NPClassifier / ClassyFire)
#' annotation levels inside an ecomet \code{mmo} object. The function reads a chosen
#' annotation table from \code{mmo[[input]]} (default \code{"sirius_annot"}), flags
#' annotations below \code{threshold} by setting them to \code{NA}, and stores the result
#' as a new element on \code{mmo} named \code{"sirius_annot_filtered_<suffix>"}.
#'
#' Rows are never dropped. "Removing" an annotation means setting the annotation value
#' (and optionally its probability column) to \code{NA}.
#'
#' For each annotation column (e.g., \code{"NPC#pathway"}), the function looks for an
#' associated probability column using common SIRIUS export naming:
#' \itemize{
#'   \item \code{"<header> Probability"}
#'   \item \code{"<header> probability"}
#'   \item \code{"<header>Probability"}
#' }
#'
#' @param mmo An ecomet mmo object containing \code{mmo[[input]]} (a data.frame).
#' @param input Character. Name of the element on \code{mmo} to filter. Defaults to \code{"sirius_annot"}.
#'
#' @param pathway_level Character vector of one or more annotation header(s) to filter.
#'   Valid options include:
#'   \itemize{
#'     \item \code{"All"}
#'     \item \code{"All_NPC"}
#'     \item \code{"All_ClassyFire"}
#'     \item \code{"NPC#pathway"}
#'     \item \code{"NPC#superclass"}
#'     \item \code{"NPC#class"}
#'     \item \code{"ClassyFire#superclass"}
#'     \item \code{"ClassyFire#class"}
#'     \item \code{"ClassyFire#subclass"}
#'     \item \code{"ClassyFire#level 5"}
#'     \item \code{"ClassyFire#most specific class"}
#'   }
#'   Special values:
#'   \itemize{
#'     \item \code{"All"} expands to all NPC + ClassyFire levels listed above.
#'     \item \code{"All_NPC"} expands to NPC levels only.
#'     \item \code{"All_ClassyFire"} expands to ClassyFire levels only.
#'   }
#'
#' @param threshold Decimal between 0 and 1. Annotations with probability < threshold are flagged to \code{NA}.
#' @param na_prob Logical. If \code{TRUE} (default), also set the corresponding probability value to \code{NA}.
#'
#' @param suffix Optional character string appended to the created element name:
#'   \code{"sirius_annot_filtered_<suffix>"}. If \code{NULL} (default), a suffix is auto-generated.
#'
#' @param overwrite Logical. If \code{FALSE} (default) and the target element already exists on \code{mmo},
#'   the function errors to avoid accidental overwrites.
#'
#' @param verbose Logical. If \code{TRUE}, prints a concise summary including counts of
#'   non-missing annotations before and after filtering.
#'
#' @return The updated \code{mmo} object, with a new element \code{mmo[[paste0("sirius_annot_filtered_", suffix)]]}.
#'
#' @examples
#' \dontrun{
#' mmo <- filter_canopus_annotations(mmo, input = "sirius_annot",
#'                                  pathway_level = "NPC#pathway", threshold = 0.9,
#'                                  suffix = "NPC_pathway_0.9", verbose = TRUE)
#'
#' mmo <- filter_canopus_annotations(mmo, input = "sirius_annot_filtered_NPC_pathway_0.9",
#'                                  pathway_level = "All_NPC", threshold = 0.95,
#'                                  suffix = "All_NPC_0.95", verbose = TRUE)
#' }
#'
#' @export
filter_canopus_annotations <- function(
    mmo,
    input = "sirius_annot",
    pathway_level = "NPC#pathway",
    threshold = 0.9,
    na_prob = TRUE,
    suffix = NULL,
    overwrite = FALSE,
    verbose = TRUE
) {
  # Basic checks
  if (is.null(mmo) || !is.list(mmo)) {
    stop("`mmo` must be a list-like ecomet object.", call. = FALSE)
  }
  if (!is.character(input) || length(input) != 1L || is.na(input) || !nzchar(input)) {
    stop("`input` must be a single, non-empty character string.", call. = FALSE)
  }
  if (!(input %in% names(mmo)) || !is.data.frame(mmo[[input]])) {
    stop("`mmo[['", input, "']]` must exist and be a data.frame.", call. = FALSE)
  }
  if (!is.numeric(threshold) || length(threshold) != 1L || is.na(threshold) ||
      threshold < 0 || threshold > 1) {
    stop("`threshold` must be a single numeric value in [0, 1].", call. = FALSE)
  }

  df <- mmo[[input]]

  # Allowed levels and expansions
  npc_levels <- c("NPC#pathway", "NPC#superclass", "NPC#class")
  cf_levels  <- c("ClassyFire#superclass", "ClassyFire#class", "ClassyFire#subclass",
                  "ClassyFire#level 5", "ClassyFire#most specific class")
  all_levels <- c(npc_levels, cf_levels)
  allowed <- c("All", "All_NPC", "All_ClassyFire", all_levels)

  if (is.list(pathway_level)) pathway_level <- unlist(pathway_level, use.names = FALSE)
  pathway_level <- as.character(pathway_level)

  # Expand selectors
  if (any(pathway_level %in% "All")) {
    pathway_level <- unique(c(setdiff(pathway_level, "All"), all_levels))
  }
  if (any(pathway_level %in% "All_NPC")) {
    pathway_level <- unique(c(setdiff(pathway_level, "All_NPC"), npc_levels))
  }
  if (any(pathway_level %in% "All_ClassyFire")) {
    pathway_level <- unique(c(setdiff(pathway_level, "All_ClassyFire"), cf_levels))
  }

  bad <- setdiff(pathway_level, allowed)
  if (length(bad) > 0) {
    stop("Unknown `pathway_level` value(s): ", paste0(bad, collapse = ", "), call. = FALSE)
  }

  # Helper: find probability column variants for a given header
  find_prob_col <- function(df, header) {
    candidates <- c(
      paste0(header, " Probability"),
      paste0(header, " probability"),
      paste0(header, "Probability")
    )
    hit <- candidates[candidates %in% names(df)]
    if (length(hit) == 0) return(NA_character_)
    hit[[1]]
  }

  # Only operate on headers that exist as annotation columns
  present_headers <- pathway_level[pathway_level %in% names(df)]
  if (length(present_headers) == 0) {
    stop(
      "None of the requested `pathway_level` columns were found in `mmo[['", input, "']]`.\n",
      "Requested: ", paste(pathway_level, collapse = ", "),
      call. = FALSE
    )
  }

  # Pair each header with a probability column; skip levels without prob col
  prob_cols <- vapply(present_headers, function(h) find_prob_col(df, h), character(1))
  no_prob <- present_headers[is.na(prob_cols)]
  if (length(no_prob) > 0) {
    warning(
      "Probability column not found for: ",
      paste0(no_prob, collapse = ", "),
      "\nExpected e.g. '<header> Probability'. These levels will be skipped.",
      call. = FALSE
    )
    keep_idx <- !is.na(prob_cols)
    present_headers <- present_headers[keep_idx]
    prob_cols <- prob_cols[keep_idx]
  }
  if (length(present_headers) == 0) {
    stop("No usable (header + probability) pairs were found for filtering.", call. = FALSE)
  }

  # Auto suffix if not provided (sanitize for safe-ish $ access)
  if (is.null(suffix) || is.na(suffix) || !nzchar(suffix)) {
    base <- pathway_level[[1]]
    base <- gsub("#", "_", base, fixed = TRUE)
    base <- gsub("[^A-Za-z0-9_\\.]+", "_", base)
    thr  <- formatC(threshold, format = "f", digits = 2)
    suffix <- paste0(base, "_", thr)
  }

  target_name <- paste0("sirius_annot_filtered_", suffix)
  if (!overwrite && (target_name %in% names(mmo))) {
    stop(
      "An element named '", target_name, "' already exists on `mmo`.\n",
      "Set `overwrite = TRUE` or choose a different `suffix`.",
      call. = FALSE
    )
  }

  # Count non-missing annotations BEFORE (across all selected levels)
  count_nonmissing <- function(vec) {
    v <- vec
    if (!is.character(v)) v <- as.character(v)
    sum(!is.na(v) & nzchar(v))
  }
  before_count <- sum(vapply(present_headers, function(h) count_nonmissing(df[[h]]), integer(1)))

  # Filter: set annotations (and optionally probs) to NA where prob < threshold OR missing prob
  out <- df

  removed_total <- 0L
  for (j in seq_along(present_headers)) {
    h <- present_headers[[j]]
    pcol <- prob_cols[[j]]

    p <- suppressWarnings(as.numeric(out[[pcol]]))
    ann <- out[[h]]
    ann_chr <- if (is.character(ann)) ann else as.character(ann)

    failing <- is.na(ann_chr) | !nzchar(ann_chr) | is.na(p) | (p < threshold)

    was_present <- !is.na(ann_chr) & nzchar(ann_chr)
    removed_here <- sum(was_present & failing)
    removed_total <- removed_total + removed_here

    out[[h]][failing] <- NA
    if (isTRUE(na_prob)) out[[pcol]][failing] <- NA_real_
  }

  # Count non-missing annotations AFTER (across all selected levels)
  after_count <- sum(vapply(present_headers, function(h) count_nonmissing(out[[h]]), integer(1)))

  mmo[[target_name]] <- out

  if (verbose) {
    message(
      "filter_canopus_annotations(): stored as mmo[['", target_name, "']]\n",
      "Input: mmo[['", input, "']]\n",
      "Levels filtered: ", paste(present_headers, collapse = ", "), "\n",
      "Threshold (kept >=): ", threshold, "\n",
      "Non-missing annotations (before -> after): ", before_count, " -> ", after_count, "\n",
      "Removed annotations below threshold: ", removed_total
    )
  }

  mmo
}



#' Filter SIRIUS structure (CSI:FingerID) annotations by COSMIC confidence score
#'
#' Applies a minimum COSMIC confidence cutoff to SIRIUS structure predictions inside an
#' ecomet \code{mmo} object. The function reads a chosen annotation table from
#' \code{mmo[[input]]} (default \code{"sirius_annot"}), flags structure annotations below
#' \code{threshold} by setting selected structure-identification fields to \code{NA},
#' and stores the result as a new element on \code{mmo} named
#' \code{"sirius_annot_filtered_<suffix>"}.
#'
#' Rows are never dropped. "Removing" a structure means setting selected fields
#' (e.g., SMILES/InChI/name/InChIkey2D) to \code{NA}.
#'
#' @param mmo An ecomet mmo object containing \code{mmo[[input]]} (a data.frame).
#' @param input Character. Name of the element on \code{mmo} to filter. Defaults to \code{"sirius_annot"}.
#'
#' @param cosmic_mode Which COSMIC column to use. One of \code{"exact"} or \code{"approx"}.
#' @param threshold Numeric. Keep structures with COSMIC >= threshold.
#'
#' @param fields Character vector of columns to NA-out when COSMIC < threshold.
#'   If \code{"auto"} (default), uses a reasonable default set if present in the table.
#'
#' @param na_cosmic Logical. If \code{TRUE} (default), also set the COSMIC value to \code{NA}
#'   when the structure is filtered out.
#'
#' @param suffix Optional character string appended to the created element name.
#' @param overwrite Logical. If \code{FALSE} (default) and the target element already exists, error.
#' @param verbose Logical. If \code{TRUE}, prints a concise summary.
#'
#' @return The updated \code{mmo} object, with a new element \code{mmo[[paste0("sirius_annot_filtered_", suffix)]]}.
#'
#' @examples
#' \dontrun{
#' mmo <- filter_cosmic_structure(mmo, input = "sirius_annot",
#'                               cosmic_mode = "approx", threshold = 0.5,
#'                               suffix = "COSMIC_exact_0.5", verbose = TRUE)
#' }
#'
#' @export
filter_cosmic_structure <- function(
    mmo,
    input = "sirius_annot",
    cosmic_mode = c("exact", "approx"),
    threshold = 0.5,
    fields = "auto",
    na_cosmic = TRUE,
    suffix = NULL,
    overwrite = FALSE,
    verbose = TRUE
) {
  # Basic checks
  if (is.null(mmo) || !is.list(mmo)) {
    stop("`mmo` must be a list-like ecomet object.", call. = FALSE)
  }
  if (!is.character(input) || length(input) != 1L || is.na(input) || !nzchar(input)) {
    stop("`input` must be a single, non-empty character string.", call. = FALSE)
  }
  if (!(input %in% names(mmo)) || !is.data.frame(mmo[[input]])) {
    stop("`mmo[['", input, "']]` must exist and be a data.frame.", call. = FALSE)
  }
  cosmic_mode <- match.arg(cosmic_mode)

  if (!is.numeric(threshold) || length(threshold) != 1L || is.na(threshold)) {
    stop("`threshold` must be a single non-missing numeric value.", call. = FALSE)
  }

  df <- mmo[[input]]

  cosmic_col <- switch(
    cosmic_mode,
    exact  = "ConfidenceScoreExact",
    approx = "ConfidenceScoreApproximate"
  )

  if (!(cosmic_col %in% names(df))) {
    stop(
      "COSMIC column '", cosmic_col, "' not found in `mmo[['", input, "']]`.",
      call. = FALSE
    )
  }

  # Determine fields to blank when failing
  if (length(fields) == 1L && identical(fields, "auto")) {
    candidate_fields <- c(
      # core structure / identifiers often present in SIRIUS exports
      "smiles", "InChI", "InChIkey2D", "name",
      # database linkage / provenance
      "links", "pubchemids", "dbflags",
      # ranking/scoring columns (structure side)
      "structurePerIdRank", "CSI:FingerIDScore",
      # optional: formula/overall scores that are often carried along
      "SiriusScore", "SiriusScoreNormalized",
      # COSMIC columns (optionally NA'd below)
      "ConfidenceScoreExact", "ConfidenceScoreApproximate"
    )
    fields_to_na <- intersect(candidate_fields, names(df))
  } else {
    fields <- as.character(fields)
    fields_to_na <- intersect(fields, names(df))
    if (length(fields_to_na) == 0) {
      stop("None of the requested `fields` were found in `mmo[['", input, "']]`.", call. = FALSE)
    }
  }

  # Helper: count "non-missing structure annotation" for reporting
  count_nonmissing <- function(vec) {
    v <- vec
    if (!is.character(v)) v <- as.character(v)
    sum(!is.na(v) & nzchar(v))
  }

  # Choose an indicator column for "structure exists" (best-effort)
  indicator_col <- if ("smiles" %in% names(df)) {
    "smiles"
  } else if ("InChI" %in% names(df)) {
    "InChI"
  } else if ("name" %in% names(df)) {
    "name"
  } else {
    cosmic_col
  }

  before_count <- count_nonmissing(df[[indicator_col]])

  out <- df

  # Parse COSMIC, handling character, NA, and +/-Inf
  cosmic <- suppressWarnings(as.numeric(out[[cosmic_col]]))

  ind <- out[[indicator_col]]
  ind_chr <- if (is.character(ind)) ind else as.character(ind)
  has_struct <- !is.na(ind_chr) & nzchar(ind_chr)

  # Fail if structure present but COSMIC missing/non-finite/below threshold
  failing <- has_struct & (is.na(cosmic) | !is.finite(cosmic) | (cosmic < threshold))

  removed_total <- sum(failing, na.rm = TRUE)

  if (removed_total > 0) {
    for (col in fields_to_na) {
      out[[col]][failing] <- NA
    }
    if (isTRUE(na_cosmic)) {
      out[[cosmic_col]][failing] <- NA_real_
    }
  }

  after_count <- count_nonmissing(out[[indicator_col]])

  # Auto suffix if not provided
  if (is.null(suffix) || is.na(suffix) || !nzchar(suffix)) {
    thr <- formatC(threshold, format = "f", digits = 2)
    suffix <- paste0("COSMIC_", cosmic_mode, "_", thr)
  }
  suffix <- gsub("[^A-Za-z0-9_\\.]+", "_", suffix)

  target_name <- paste0("sirius_annot_filtered_", suffix)
  if (!overwrite && (target_name %in% names(mmo))) {
    stop(
      "An element named '", target_name, "' already exists on `mmo`.\n",
      "Set `overwrite = TRUE` or choose a different `suffix`.",
      call. = FALSE
    )
  }

  mmo[[target_name]] <- out

  if (verbose) {
    message(
      "filter_cosmic_structure(): stored as mmo[['", target_name, "']]\n",
      "Input: mmo[['", input, "']]\n",
      "COSMIC mode: ", cosmic_mode, " (column: ", cosmic_col, ")\n",
      "Threshold (kept >=): ", threshold, "\n",
      "Structure indicator column: ", indicator_col, "\n",
      "Non-missing structures (before -> after): ", before_count, " -> ", after_count, "\n",
      "Removed structures below threshold: ", removed_total, "\n",
      "Fields NA'd: ", paste(fields_to_na, collapse = ", ")
    )
  }

  mmo
}



#' Add custom annotations to an mmo object
#'
#' @description
#' Match features to a custom DB by m/z (ppm) and RT (minutes) tolerances and
#' attach a list-column of candidate compound IDs per feature.
#'
#' @param mmo An `mmo` object created by `GetMZmineFeature()`.
#' @param DB_file CSV path with at least columns `compound`, `mz`, `rt`.
#' @param mztol m/z tolerance in ppm (default 5).
#' @param rttol RT tolerance in minutes (default 0.5).
#' @return The same `mmo` object with `mmo$custom_annot` (id, feature, custom_annot).
#' @export
#' @examplesIf FALSE
#' mmo <- AddCustomAnnot(mmo, DB_file = "path/to/custom_db.csv", mztol = 5, rttol = 0.5)
AddCustomAnnot <- function(mmo, DB_file, mztol = 5, rttol = 0.5) {
  DB <- read.csv(DB_file, stringsAsFactors = FALSE)

  DB <- dplyr::mutate(
    DB,
    mz = as.numeric(.data$mz),
    rt = as.numeric(.data$rt)
  )

  # Parse "feature" (formatted like "mz_rt") into numeric mz/rt columns
  feature_annot <- mmo$feature_data |>
    tidyr::separate(
      col = "feature",
      into = c("mz", "rt"),
      sep = "_",
      remove = FALSE,
      convert = TRUE
    )

  # For each feature, collect matching DB compounds within tolerances
  annotated_features <- dplyr::mutate(
    feature_annot,
    custom_annot = purrr::map2(.data$mz, .data$rt, function(mzi, rti) {
      dplyr::filter(
        DB,
        abs(mzi - .data$mz) / mzi * 1e6 <= mztol,
        abs(rti - .data$rt) <= rttol
      ) |>
        dplyr::pull(.data$compound)
    })
  )

  mmo$custom_annot <- dplyr::select(
    .data$annotated_features,
    .data$id, .data$feature, .data$custom_annot
  )

  message("Custom annotation added to mmo$custom_annot using ", DB_file)
  mmo
}


#' Replace zero and NA values in the mmo object
#'
#' This function replaces zero and NA values in the feature data of the mmo object.
#' Run this function before MassNormalization(), LogNormalization(), MeancenterNormalization(), or ZNormalization().
#'
#' @param mmo The mmo object
#' @param method The method to use for replacement. Options are 'one' (replace with 1) or 'half_mean' (replace with half of the smallest non-zero value in the row)
#' @return The mmo object with replaced values in the feature data (mmo$feature_data)
#' @export
#' @examplesIf FALSE
#' mmo <- ReplaceZero(mmo, method = 'one')
# ReplaceZero <- function(mmo, method = 'one') {
#   df <- mmo$feature_data
#   df[] <- apply(df, 1, function(row) {
#     # Convert the row to numeric, ignoring non-numeric columns
#     numeric_row <- as.numeric(row[-c(1, 2)])  # Skip 'id' and 'feature' columns
#     # Get the smallest non-zero, non-NA value in the row
#     smallest_value <- min(numeric_row[numeric_row > 0], na.rm = TRUE)
#     # Replace 0 and NA with half of the smallest_value
#     row[-c(1, 2)] <- sapply(numeric_row, function(x) {
#       if (is.na(x) || x == 0) {
#         if (method == 'one') {
#           return(1)
#         } else if (method == 'half_mean') {
#           return(smallest_value / 2)
#         }
#       } else {
#         return(x)
#       }
#     })
#
#     return(row)
#   }) |>
#     t() |>
#     as.data.frame()  # Convert back to dataframe
#   mmo$feature_data <- df
#   print(paste('Missing values were filled with', method))
#   return(mmo)
# }
ReplaceZero <- function(mmo, method = "one") {
  df <- mmo$feature_data

  # assume first two cols are id, feature; everything else is numeric-ish
  id_feat <- df[, 1:2]
  num_df  <- df[, -(1:2), drop = FALSE]

  # force numeric matrix (without dragging id/feature in)
  num_mat <- as.matrix(sapply(num_df, as.numeric))

  new_mat <- t(apply(num_mat, 1, function(numeric_row) {
    # smallest non-zero, non-NA
    smallest_value <- suppressWarnings(
      min(numeric_row[numeric_row > 0], na.rm = TRUE)
    )

    # replace per element
    vapply(numeric_row, function(x) {
      if (is.na(x) || x == 0) {
        if (method == "one") {
          1
        } else if (method == "half_mean") {
          smallest_value / 2
        } else {
          x
        }
      } else {
        x
      }
    }, numeric(1))
  }))

  # rebuild data.frame with original id/feature + numeric matrix
  num_df_out <- as.data.frame(new_mat, stringsAsFactors = FALSE)
  names(num_df_out) <- names(num_df)

  df_out <- cbind(id_feat, num_df_out)

  mmo$feature_data <- df_out
  message(sprintf("Missing values were filled with %s", method))
  mmo
}
#' Convert feature abundances to presence / absence
#'
#' This function converts the feature abundance matrix in an mmo object
#' into a binary presence/absence matrix and stores it as a new component
#' of the mmo object (mmo$feature_presence).
#'
#' A feature is considered present (1) if its abundance is greater than
#' a specified threshold, and absent (0) otherwise.
#'
#' This function does NOT overwrite mmo$feature_data.
#'
#' @param mmo The mmo object
#' @param threshold Numeric threshold for presence (default = 1).
#'   Values > threshold are set to 1, values <= threshold or NA are set to 0.
#'
#' @return The mmo object with a new presence/absence table
#'   stored in mmo$feature_presence
#'
#' @export
#'
#' @examplesIf FALSE
#' mmo <- FeaturePresence(mmo, threshold = 1)
FeaturePresence <- function(mmo, threshold = 1) {

  df <- mmo$feature_data

  # assume first two columns are id and feature
  id_feat <- df[, 1:2]
  num_df  <- df[, -(1:2), drop = FALSE]

  # force numeric matrix
  num_mat <- as.matrix(sapply(num_df, as.numeric))

  # convert to presence / absence
  pa_mat <- ifelse(num_mat > threshold, 1, 0)

  # rebuild data.frame
  pa_df <- as.data.frame(pa_mat, stringsAsFactors = FALSE)
  names(pa_df) <- names(num_df)

  df_out <- cbind(id_feat, pa_df)

  # store as new slot
  mmo$feature_presence <- df_out

  message(
    sprintf(
      "Feature presence/absence matrix created using threshold > %s",
      threshold
    )
  )

  return(mmo)
}



#' Use sample mass in the metadata file to normalize the peak area
#'
#' This function normalizes the peak area in the feature data of the mmo object by the mass of each sample, provided in the metadata.
#' The feature data is replaced by (original value * mean mass) / sample mass.
#'
#' @param mmo The mmo object
#' @return The mmo object with normalized feature data (mmo$feature_data)
#' @export
#' @examplesIf FALSE
#' mmo <- MassNormalization(mmo)
MassNormalization <- function(mmo){
  normalized_df <- mmo$feature_data
  metadata <- mmo$metadata
  mean_mass <- mean(mmo$metadata$mass)
  for (sample_col in colnames(mmo$feature_data)[-c(1,2)]) {
    sample_metadata <- metadata[metadata$sample == sample_col, ]
    mass <- sample_metadata$mass
    normalized_df[[sample_col]] <- as.numeric(mmo$feature_data[[sample_col]])*mean_mass/mass
  }
  mmo$feature_data <- normalized_df
  print("Peak area are normalized by sample mass")
  return(mmo)
}

#' Log-normalize the peak area in the mmo object
#'
#' This function applies log2 transformation to the peak area in the feature data of the mmo object.
#' Run ReplaceZero() before this function to avoid -Inf values.
#'
#' @param mmo The mmo object
#' @return The mmo object with log-normalized feature data (mmo$log)
#' @export
#' @examplesIf FALSE
#' mmo <- LogNormalization(mmo)
LogNormalization <- function(mmo){
  feature_data_only <- mmo$feature_data[,-(1:2)]
  log_data <- log2(feature_data_only)
  log_df <- cbind(mmo$feature_data[, 1:2], log_data)
  mmo$log <- log_df
  print('Log-normalized values were added to mmo$log')
  return(mmo)
}

#' Mean-center the peak area in the mmo object
#'
#' This function applies mean-centering to the peak area in the feature data of the mmo object.
#'
#' @param mmo The mmo object
#' @return The mmo object with mean-centered feature data (mmo$meancentered)
#' @export
#' @examplesIf FALSE
#' mmo <- MeancenterNormalization(mmo)
MeancenterNormalization <- function(mmo){
  feature_data_only <- mmo$feature_data[,-(1:2)]
  mean_centered_data <- t(apply(feature_data_only, 1, function(x) x - mean(x, na.rm = TRUE)))
  mean_centered_df <- cbind(mmo$feature_data[, 1:2], mean_centered_data)
  mmo$meancentered <- mean_centered_df
  print('Meancentered values were added to mmo$meancentered')
  return(mmo)
}

#' Z-normalize the peak area in the mmo object
#'
#' This function applies Z-score normalization to the peak area in the feature data of the mmo object.
#'
#' @param mmo The mmo object
#' @return The mmo object with Z-normalized feature data (mmo$zscore)
#' @export
#' @examplesIf FALSE
#' mmo <- ZNormalization(mmo)
ZNormalization <- function(mmo){
  feature_data_only <- mmo$feature_data[,-(1:2)]
  zscore_df <- t(apply(feature_data_only, 1, function(x) {
    (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
  }))
  zscore_df <- cbind(mmo$feature_data[, 1:2], zscore_df)
  mmo$zscore <- zscore_df
  print('Z-score values were added to mmo$zscore')
  return(mmo)
}


#' Add chemical distance matrices to the mmo object
#'
#' This function reads cosine, DREAMS, and MS2DeepScore molecular networking outputs from MZmine,
#' then transform the similarity to distance and adds the dissimilarity matrices to the mmo object.
#'
#' @param mmo The mmo object
#' @param cos_dir Path to the cosine similarity CSV file from MZMine (molecular networking)
#' @param dreams_dir Path to the DREAMS similarity CSV file from MZMine (molecular networking)
#' @param m2ds_dir Path to the MS2DeepScore similarity CSV file from MZMine (molecular networking)
#' @return The mmo object with dissimilarity matrices added (mmo$cos.dissim, mmo$dreams.dissim, mmo$m2ds.dissim)
#' @export
#' @examplesIf FALSE
#' mmo <- AddChemDist(mmo,
#'  cos_dir = "path/to/cosine_similarity.csv",
#'  dreams_dir = "path/to/dreams_similarity.csv",
#'  m2ds_dir = "path/to/ms2deepscore_similarity.csv"
#' )
AddChemDist <- function(mmo, cos_dir = NULL, dreams_dir = NULL, m2ds_dir = NULL) {
  .require_pkg("data.table")
  add_dissim_matrix <- function(mmo, sim_dir, slot_name) {
    # Fast read
    sim <- data.table::fread(sim_dir, col.names = c("cluster1", "cluster2", "metric", "similarity", "etc"))
    sim$dissimilarity <- 1 - sim$similarity

    # Ensure cluster IDs are clean characters
    sim$cluster1 <- trimws(as.character(sim$cluster1))
    sim$cluster2 <- trimws(as.character(sim$cluster2))

    # Build mapping
    clusters <- unique(c(sim$cluster1, sim$cluster2))
    cluster_index <- stats::setNames(seq_along(clusters), clusters)

    # Map clusters to integer indices
    i <- cluster_index[sim$cluster1]
    j <- cluster_index[sim$cluster2]

    # Check for problems
    if (anyNA(i) || anyNA(j)) {
      bad <- unique(c(sim$cluster1[is.na(i)], sim$cluster2[is.na(j)]))
      stop("Cluster IDs not found in mapping: ", paste(bad, collapse = ", "))
    }

    # Preallocate full dense matrix
    n <- length(clusters)
    dissim_mat <- matrix(1, nrow = n, ncol = n)
    diag(dissim_mat) <- 0

    # Fill dissimilarities
    dissim_mat[cbind(i, j)] <- sim$dissimilarity
    dissim_mat[cbind(j, i)] <- sim$dissimilarity

    # Add names
    dimnames(dissim_mat) <- list(clusters, clusters)

    # Reduce memory footprint
    mode(dissim_mat) <- "single"

    mmo[[slot_name]] <- dissim_mat
    message(slot_name, " added to mmo")
    return(mmo)
  }

  if (!is.null(cos_dir))    mmo <- add_dissim_matrix(mmo, cos_dir,    "cos.dissim")
  if (!is.null(dreams_dir)) mmo <- add_dissim_matrix(mmo, dreams_dir, "dreams.dissim")
  if (!is.null(m2ds_dir))   mmo <- add_dissim_matrix(mmo, m2ds_dir,   "m2ds.dissim")

  if (is.null(cos_dir) && is.null(dreams_dir) && is.null(m2ds_dir)) {
    stop("Please provide at least one valid directory.")
  }

  return(mmo)
}


#' Reorder samples in the mmo object based on group order
#'
#' This function reorders the samples in the mmo object based on a specified group order.
#' The function updates the order of samples in the feature data, log-normalized data, z-score data, and mean-centered data.
#' Use this function before plotting heatmaps or other visualizations to ensure consistent group ordering.
#'
#' @param mmo The mmo object
#' @param group_order A vector specifying the desired order of groups
#' @return The mmo object with reordered samples
#' @export
#' @examplesIf FALSE
#' mmo <- ReorderGroups(mmo, group_order = c("Control", "Treatment1", "Treatment2"))
ReorderGroups <- function(mmo, group_order) {
  metadata <- mmo$metadata
  # Get sample names in the specified group order
  ordered_samples <- unlist(lapply(group_order, function(g) metadata$sample[metadata$group == g]))
  # Reorder columns: id, feature, then ordered samples
  mmo$feature_data <- mmo$feature_data |>
    dplyr::select(.data$id, .data$feature, all_of(ordered_samples))
  mmo$log <- mmo$log |>
    dplyr::select(.data$id, .data$feature, all_of(ordered_samples))
  mmo$zscore <- mmo$zscore |>
    dplyr::select(.data$id, .data$feature, all_of(ordered_samples))
  mmo$meancentered <- mmo$meancentered |>
    dplyr::select(.data$id, .data$feature, all_of(ordered_samples))
  return(mmo)
}

#' Filter an MGF file to keep only spectra for features present in mmo$feature_data$id
#'
#' Create a new \code{.mgf} file that contains only spectra (ION blocks) whose
#' \code{FEATURE_ID} occurs in \code{mmo$feature_data$id}. This is useful for keeping
#' your spectral library in sync with the features currently stored in an \code{mmo}
#' object (e.g., after subsetting, filtering, or rebuilding an \code{mmo}).
#'
#' Each spectrum in an MGF is represented by a \code{BEGIN IONS ... END IONS} block.
#' This function keeps or discards entire blocks based on the integer value in the
#' \code{FEATURE_ID=} header line. All blocks (MS1 and MS2) are kept for a retained
#' feature, including multiple MS2 blocks if present.
#'
#' @param mmo An ecomet \code{mmo} object containing a required \code{feature_data}
#'   table with an \code{id} column (\code{mmo$feature_data$id}).
#'
#' @param mgf_path Character. Path to the input \code{.mgf} file.
#'
#' @param output_path Character or NULL. Path to write the filtered \code{.mgf}.
#'   If \code{NULL} (default), the output name is derived from \code{mgf_path} by
#'   appending \code{_filtered} before the \code{.mgf} extension (or adding
#'   \code{_filtered.mgf} if no extension is present).
#'
#' @param chunk_lines Integer. Number of lines read per iteration. Larger values are
#'   typically faster but use more memory. Default is \code{100000L}.
#'
#' @param verbose Logical. If \code{TRUE} (default), prints a short progress summary
#'   and final counts.
#'
#' @return Invisibly returns a list with:
#' \itemize{
#'   \item \code{output_path}: path to the filtered MGF
#'   \item \code{blocks_total}: total \code{BEGIN IONS} blocks encountered
#'   \item \code{blocks_kept}: number of blocks written to \code{output_path}
#'   \item \code{lines_read}: total lines read from \code{mgf_path}
#' }
#'
#' @examples
#' \dontrun{
#' # Write "<input>_filtered.mgf" containing only FEATURE_IDs present in mmo$feature_data$id
#' filter_mgf_to_mmo(mmo, "spectra.mgf")
#'
#' # Write to a custom file name
#' filter_mgf_to_mmo(mmo, "spectra.mgf", output_path = "spectra_mmo_only.mgf")
#' }
#'
#' @export
filter_mgf_to_mmo <- function(
    mmo,
    mgf_path,
    output_path = NULL,
    chunk_lines = 100000L,
    verbose = TRUE
) {
  # --- checks ---
  if (is.null(mmo) || !is.list(mmo)) {
    stop("`mmo` must be a list-like ecomet object.", call. = FALSE)
  }
  if (!("feature_data" %in% names(mmo)) || !is.data.frame(mmo$feature_data)) {
    stop("`mmo$feature_data` must exist and be a data.frame.", call. = FALSE)
  }
  if (!("id" %in% names(mmo$feature_data))) {
    stop("`mmo$feature_data$id` must exist.", call. = FALSE)
  }
  if (!is.character(mgf_path) || length(mgf_path) != 1L || !nzchar(mgf_path) || !file.exists(mgf_path)) {
    stop("`mgf_path` must be an existing file path.", call. = FALSE)
  }
  if (!is.null(output_path)) {
    if (!is.character(output_path) || length(output_path) != 1L || !nzchar(output_path)) {
      stop("`output_path` must be NULL or a non-empty character string.", call. = FALSE)
    }
  } else {
    if (grepl("\\.mgf$", mgf_path, ignore.case = TRUE)) {
      output_path <- sub("\\.mgf$", "_filtered.mgf", mgf_path, ignore.case = TRUE)
    } else {
      output_path <- paste0(mgf_path, "_filtered.mgf")
    }
  }

  # --- build ID lookup (fast membership checks) ---
  ids <- mmo$feature_data$id
  ids_num <- suppressWarnings(as.integer(as.character(ids)))
  ids_num <- ids_num[!is.na(ids_num)]
  if (length(ids_num) == 0) {
    stop(
      "No usable (integer) IDs found in `mmo$feature_data$id`.\n",
      "MGF filtering expects FEATURE_ID-like integers.",
      call. = FALSE
    )
  }
  keep_ids <- unique(ids_num)

  # Environment hash set for O(1) membership
  keep_env <- new.env(parent = emptyenv(), hash = TRUE)
  for (k in keep_ids) keep_env[[as.character(k)]] <- TRUE

  # --- streaming filter ---
  in_con  <- file(mgf_path, open = "r", encoding = "UTF-8")
  on.exit(try(close(in_con), silent = TRUE), add = TRUE)
  out_con <- file(output_path, open = "w", encoding = "UTF-8")
  on.exit(try(close(out_con), silent = TRUE), add = TRUE)

  begin_line <- "BEGIN IONS"
  end_line   <- "END IONS"
  key_prefix <- "FEATURE_ID="

  inside_block <- FALSE
  block_lines <- character(0)
  decided_keep <- NA  # logical once FEATURE_ID parsed
  blocks_total <- 0L
  blocks_kept  <- 0L
  lines_read_total <- 0L

  parse_feature_id <- function(line) {
    if (!startsWith(line, key_prefix)) return(NA_integer_)
    val <- substr(line, nchar(key_prefix) + 1L, nchar(line))
    suppressWarnings(as.integer(val))
  }

  if (verbose) {
    message(
      "filter_mgf_to_mmo():\n",
      "- Input MGF:  ", mgf_path, "\n",
      "- Output MGF: ", output_path, "\n",
      "- Using IDs:  mmo$feature_data$id (n unique = ", length(keep_ids), ")\n",
      "- Chunk lines: ", chunk_lines
    )
  }

  repeat {
    chunk <- readLines(in_con, n = chunk_lines, warn = FALSE)
    if (length(chunk) == 0) break
    lines_read_total <- lines_read_total + length(chunk)

    for (line in chunk) {
      if (!inside_block) {
        if (identical(line, begin_line)) {
          inside_block <- TRUE
          block_lines <- line
          decided_keep <- NA
        }
        next
      }

      block_lines <- c(block_lines, line)

      if (is.na(decided_keep)) {
        fid <- parse_feature_id(line)
        if (!is.na(fid)) {
          decided_keep <- isTRUE(keep_env[[as.character(fid)]])
        }
      }

      if (identical(line, end_line)) {
        blocks_total <- blocks_total + 1L

        if (isTRUE(decided_keep)) {
          writeLines(block_lines, out_con, sep = "\n")
          blocks_kept <- blocks_kept + 1L
        }

        inside_block <- FALSE
        block_lines <- character(0)
        decided_keep <- NA
      }
    }

    if (verbose && blocks_total > 0L && (blocks_total %% 5000L == 0L)) {
      message("... processed blocks: ", blocks_total, " | kept: ", blocks_kept)
    }
  }

  if (verbose) {
    message(
      "Done.\n",
      "- Lines read:   ", format(lines_read_total, big.mark = ","), "\n",
      "- Blocks total: ", format(blocks_total, big.mark = ","), "\n",
      "- Blocks kept:  ", format(blocks_kept, big.mark = ","), "\n",
      "- Kept fraction: ", if (blocks_total > 0) sprintf("%.3f", blocks_kept / blocks_total) else "NA"
    )
  }

  invisible(list(
    output_path = output_path,
    blocks_total = blocks_total,
    blocks_kept = blocks_kept,
    lines_read = lines_read_total
  ))
}



#' Annotate mmo$feature_info with MS2 presence and MS2 block counts from an MGF
#'
#' Scan an \code{.mgf} file and summarize MS/MS availability for each feature in
#' \code{mmo$feature_info}. The function adds two columns:
#' \itemize{
#'   \item \code{ms2}: \code{TRUE} if the MGF contains at least one \code{MSLEVEL=2}
#'         block for that \code{id}; otherwise \code{FALSE}.
#'   \item \code{count_ms2}: number of \code{MSLEVEL=2} blocks for that \code{id}.
#' }
#'
#' This is useful for quickly identifying which features have MS/MS spectra available
#' (and how many replicate MS2 spectra exist) before downstream annotation, networking,
#' or library-building steps.
#'
#' @param mmo An ecomet \code{mmo} object containing a required \code{feature_info}
#'   table with an \code{id} column (\code{mmo$feature_info$id}).
#'
#' @param mgf_path Character. Path to the input \code{.mgf} file.
#'
#' @param chunk_lines Integer. Number of lines read per iteration. Larger values are
#'   typically faster but use more memory. Default is \code{100000L}.
#'
#' @param overwrite Logical. If \code{FALSE} (default) and \code{ms2} and/or \code{count_ms2}
#'   already exist in \code{mmo$feature_info}, the function errors. Set \code{overwrite = TRUE}
#'   to replace existing columns.
#'
#' @param verbose Logical. If \code{TRUE} (default), prints a brief summary of how many
#'   MS2 blocks were found and how many features have MS2.
#'
#' @return The updated \code{mmo} object with \code{mmo$feature_info$ms2} and
#'   \code{mmo$feature_info$count_ms2} added (or overwritten if \code{overwrite = TRUE}).
#'
#' @examples
#' \dontrun{
#' # Add ms2 + count_ms2 columns to mmo$feature_info
#' mmo <- annotate_feature_info_ms2_from_mgf(mmo,
#'        "spectra.mgf")
#'
#' # Overwrite existing columns if you re-run on a different MGF
#' mmo <- annotate_feature_info_ms2_from_mgf(mmo,
#'        "spectra_new.mgf", overwrite = TRUE)
#' }
#'
#' @export
annotate_feature_info_ms2_from_mgf <- function(
    mmo,
    mgf_path,
    chunk_lines = 100000L,
    overwrite = FALSE,
    verbose = TRUE
) {
  # --- checks ---
  if (is.null(mmo) || !is.list(mmo)) {
    stop("`mmo` must be a list-like ecomet object.", call. = FALSE)
  }
  if (!("feature_info" %in% names(mmo)) || !is.data.frame(mmo$feature_info)) {
    stop("`mmo$feature_info` must exist and be a data.frame.", call. = FALSE)
  }
  if (!("id" %in% names(mmo$feature_info))) {
    stop("`mmo$feature_info$id` must exist.", call. = FALSE)
  }
  if (!is.character(mgf_path) || length(mgf_path) != 1L || !nzchar(mgf_path) || !file.exists(mgf_path)) {
    stop("`mgf_path` must be an existing file path.", call. = FALSE)
  }
  if (!is.logical(overwrite) || length(overwrite) != 1L || is.na(overwrite)) {
    stop("`overwrite` must be TRUE or FALSE.", call. = FALSE)
  }

  if (!overwrite) {
    if ("ms2" %in% names(mmo$feature_info) || "count_ms2" %in% names(mmo$feature_info)) {
      stop(
        "Columns already exist in mmo$feature_info: ",
        paste(intersect(c("ms2", "count_ms2"), names(mmo$feature_info)), collapse = ", "),
        "\nSet overwrite = TRUE to overwrite them.",
        call. = FALSE
      )
    }
  }

  # IDs we care about
  ids <- mmo$feature_info$id
  ids_num <- suppressWarnings(as.integer(as.character(ids)))
  ok <- !is.na(ids_num)
  if (!any(ok)) {
    stop("No usable (integer) IDs found in `mmo$feature_info$id`.", call. = FALSE)
  }
  ids_num <- ids_num[ok]
  keep_ids <- unique(ids_num)

  # Environment for fast membership: only count IDs present in feature_info
  id_env <- new.env(parent = emptyenv(), hash = TRUE)
  for (k in keep_ids) id_env[[as.character(k)]] <- TRUE

  # Counts stored in an environment too (sparse)
  count_env <- new.env(parent = emptyenv(), hash = TRUE)

  # --- streaming parse ---
  in_con <- file(mgf_path, open = "r", encoding = "UTF-8")
  on.exit(try(close(in_con), silent = TRUE), add = TRUE)

  begin_line <- "BEGIN IONS"
  end_line   <- "END IONS"
  fid_prefix <- "FEATURE_ID="
  ms_prefix  <- "MSLEVEL="

  inside_block <- FALSE
  block_fid <- NA_integer_
  block_is_ms2 <- FALSE
  saw_fid <- FALSE
  saw_ms <- FALSE

  blocks_total <- 0L
  blocks_ms2_total <- 0L
  lines_read_total <- 0L

  parse_int_after_prefix <- function(line, prefix) {
    if (!startsWith(line, prefix)) return(NA_integer_)
    val <- substr(line, nchar(prefix) + 1L, nchar(line))
    suppressWarnings(as.integer(val))
  }

  if (verbose) {
    message(
      "annotate_feature_info_ms2_from_mgf():\n",
      "- MGF: ", mgf_path, "\n",
      "- Feature IDs: mmo$feature_info$id (n unique = ", length(keep_ids), ")\n",
      "- Chunk lines: ", chunk_lines
    )
  }

  repeat {
    chunk <- readLines(in_con, n = chunk_lines, warn = FALSE)
    if (length(chunk) == 0) break
    lines_read_total <- lines_read_total + length(chunk)

    for (line in chunk) {
      if (!inside_block) {
        if (identical(line, begin_line)) {
          inside_block <- TRUE
          block_fid <- NA_integer_
          block_is_ms2 <- FALSE
          saw_fid <- FALSE
          saw_ms <- FALSE
        }
        next
      }

      # Inside a block: look only for FEATURE_ID and MSLEVEL
      if (!saw_fid && startsWith(line, fid_prefix)) {
        fid <- parse_int_after_prefix(line, fid_prefix)
        if (!is.na(fid)) {
          block_fid <- fid
          saw_fid <- TRUE
        }
        next
      }

      if (!saw_ms && startsWith(line, ms_prefix)) {
        ms <- parse_int_after_prefix(line, ms_prefix)
        if (!is.na(ms) && ms == 2L) {
          block_is_ms2 <- TRUE
        }
        saw_ms <- TRUE
        next
      }

      if (identical(line, end_line)) {
        blocks_total <- blocks_total + 1L

        # Count only if:
        # - it's MS2
        # - FEATURE_ID parsed
        # - FEATURE_ID is in our feature_info set
        if (block_is_ms2 && !is.na(block_fid) && isTRUE(id_env[[as.character(block_fid)]])) {
          blocks_ms2_total <- blocks_ms2_total + 1L
          key <- as.character(block_fid)
          cur <- count_env[[key]]
          if (is.null(cur)) cur <- 0L
          count_env[[key]] <- cur + 1L
        }

        inside_block <- FALSE
      }
    }
  }

  # Build count vector aligned to feature_info rows
  fi <- mmo$feature_info
  fi_ids_num <- suppressWarnings(as.integer(as.character(fi$id)))

  count_ms2 <- integer(nrow(fi))
  for (i in seq_len(nrow(fi))) {
    fid <- fi_ids_num[[i]]
    if (!is.na(fid)) {
      v <- count_env[[as.character(fid)]]
      if (!is.null(v)) count_ms2[[i]] <- as.integer(v)
    }
  }
  ms2 <- count_ms2 > 0L

  fi$ms2 <- ms2
  fi$count_ms2 <- count_ms2
  mmo$feature_info <- fi

  if (verbose) {
    message(
      "Done.\n",
      "- Lines read: ", format(lines_read_total, big.mark = ","), "\n",
      "- Blocks total: ", format(blocks_total, big.mark = ","), "\n",
      "- MS2 blocks counted (in feature_info): ", format(blocks_ms2_total, big.mark = ","), "\n",
      "- Features with MS2: ", sum(ms2, na.rm = TRUE), " / ", nrow(fi)
    )
  }

  mmo
}






#' Filter an mmo object by samples, groups, and/or features
#'
#' @description
#' Subset all components of an mmo object (feature tables, metadata, distance
#' matrices, and annotations) to a given set of samples, groups, and/or
#' feature IDs. Filtering is applied consistently across all slots present
#' in \code{mmo}.
#'
#' Optionally, if an \code{mgf_path} is provided, a filtered MGF is written
#' containing only spectra for the retained features (using \code{filter_mgf_to_mmo()}).
#'
#' @param mmo A list-like mmo object as returned by \code{GetMZmineFeature()}.
#' @param sample_list Optional character vector of sample IDs (matching
#'   \code{sample_col} in \code{mmo$metadata}) to retain.
#' @param group_list Optional character vector of group labels (matching
#'   \code{group_col} in \code{mmo$metadata}) to retain. Mutually exclusive with
#'   \code{sample_list}.
#' @param feature_list Optional character vector of feature IDs to retain.
#'   If \code{NULL}, features are determined from \code{feature_data} and optionally
#'   filtered by \code{drop_empty_feat}.
#' @param sample_col Column name in \code{mmo$metadata} containing sample IDs.
#'   Default is \code{"sample"}.
#' @param group_col Column name in \code{mmo$metadata} containing group labels.
#'   Default is \code{"group"}.
#' @param drop_empty_feat Logical; if \code{TRUE} (default) drop features with no
#'   non-zero values in the retained samples.
#' @param empty_threshold Optional numeric threshold used to define “empty”
#'   features. If \code{NULL} (default), the smallest positive, non-NA intensity
#'   in the retained samples is used. Features are kept if they have at least
#'   one value > threshold across retained samples.
#'
#' @param mgf_path Optional character. If provided, an MGF file will be filtered
#'   to retained features using \code{filter_mgf_to_mmo()}.
#' @param output_path Character or NULL. Passed to \code{filter_mgf_to_mmo()}.
#'   If \code{NULL} (default), output is \code{"<input>_filtered.mgf"}.
#'
#' @return A filtered mmo object with the same structure as \code{mmo}, but
#'   restricted to the requested samples / groups / features. If \code{mgf_path}
#'   is provided, the returned object also includes \code{mmo_filtered$mgf_filtered_path}.
#' @export
#'
#' @examples
#' \dontrun{
#' mmo_sub <- filter_mmo(mmo, group_list = c("Species1", "Species2"))
#'
#' # Also write a filtered mgf:
#' mmo_sub <- filter_mmo(mmo, group_list = c("Species1", "Species2"),
#'                       mgf_path = "spectra.mgf")
#' }
filter_mmo <- function(mmo,
                       sample_list  = NULL,
                       group_list   = NULL,
                       feature_list = NULL,
                       sample_col   = "sample",
                       group_col    = "group",
                       drop_empty_feat   = TRUE,
                       empty_threshold   = NULL,
                       mgf_path          = NULL,
                       output_path       = NULL) {

  # ------------------------------------------------------------------
  # 0. Basic checks on arguments
  # ------------------------------------------------------------------
  if (is.null(sample_list) && is.null(group_list) && is.null(feature_list)) {
    stop("Must provide at least one of 'sample_list', 'group_list', or 'feature_list'.", call. = FALSE)
  }
  if (!is.null(sample_list) && !is.null(group_list)) {
    stop("Provide exactly one of 'sample_list' or 'group_list', not both.", call. = FALSE)
  }
  if (!"metadata" %in% names(mmo)) stop("mmo$metadata must be present.", call. = FALSE)
  if (!"feature_data" %in% names(mmo)) stop("mmo$feature_data must be present.", call. = FALSE)

  meta <- mmo$metadata
  if (!is.data.frame(meta)) stop("mmo$metadata must be a data.frame.", call. = FALSE)
  if (!sample_col %in% names(meta)) stop(sprintf("sample_col '%s' not present in metadata.", sample_col), call. = FALSE)
  if (!is.null(group_list) && !group_col %in% names(meta)) {
    stop(sprintf("group_col '%s' not present in metadata.", group_col), call. = FALSE)
  }

  # ------------------------------------------------------------------
  # 1. Determine which samples to keep
  # ------------------------------------------------------------------
  all_samples <- as.character(meta[[sample_col]])

  if (!is.null(sample_list)) {
    keep_samples <- intersect(all_samples, as.character(sample_list))
    if (length(keep_samples) == 0L) {
      stop("None of the supplied sample IDs in 'sample_list' are present in the mmo object.", call. = FALSE)
    }
  } else if (!is.null(group_list)) {
    idx <- meta[[group_col]] %in% group_list
    keep_samples <- as.character(meta[[sample_col]][idx])
    if (length(keep_samples) == 0L) {
      stop("No samples found for the requested 'group_list'.", call. = FALSE)
    }
  } else {
    keep_samples <- all_samples
  }

  # ------------------------------------------------------------------
  # 2. Filter feature_data and decide which features to keep
  # ------------------------------------------------------------------
  feat_abund <- mmo[["feature_data"]]
  if (!is.data.frame(feat_abund) || !all(c("id", "feature") %in% names(feat_abund))) {
    stop("mmo$feature_data must be a data.frame with columns 'id' and 'feature'.", call. = FALSE)
  }

  sample_cols_present <- intersect(keep_samples, names(feat_abund))
  col_keep <- c("id", "feature", sample_cols_present)
  feat_abund_filtered <- feat_abund[, col_keep, drop = FALSE]

  auto_features <- as.character(feat_abund_filtered$id)

  if (drop_empty_feat && length(sample_cols_present) > 0L) {
    num_mat <- as.matrix(
      suppressWarnings(
        sapply(feat_abund_filtered[, sample_cols_present, drop = FALSE], as.numeric)
      )
    )
    if (!is.matrix(num_mat)) num_mat <- matrix(num_mat, nrow = nrow(feat_abund_filtered))

    positive_vals <- num_mat[num_mat > 0 & !is.na(num_mat)]

    if (is.null(empty_threshold)) {
      if (length(positive_vals) == 0L) {
        threshold <- Inf
        nonempty_idx <- rep(FALSE, nrow(num_mat))
        message("drop_empty_feat = TRUE, but no positive intensities found; all features are treated as empty.")
      } else {
        min_val <- min(positive_vals)
        threshold <- min_val
        message(sprintf("Removing empty features based on min_val = %g", min_val))
        nonempty_idx <- apply(num_mat, 1, function(x) any(x > threshold, na.rm = TRUE))
      }
    } else {
      threshold <- empty_threshold
      message(sprintf("Removing empty features using user threshold = %g", threshold))
      nonempty_idx <- apply(num_mat, 1, function(x) any(x > threshold, na.rm = TRUE))
    }

    auto_features <- auto_features[nonempty_idx]
    feat_abund_filtered <- feat_abund_filtered[nonempty_idx, , drop = FALSE]
  }

  if (!is.null(feature_list)) {
    feature_list <- as.character(feature_list)
    features_keep <- intersect(auto_features, feature_list)
    if (length(features_keep) == 0L) {
      stop("No overlap between 'feature_list' and features present in mmo$feature_data.", call. = FALSE)
    }
    feat_abund_filtered <- feat_abund_filtered[feat_abund_filtered$id %in% features_keep, , drop = FALSE]
  } else {
    features_keep <- auto_features
  }

  # ------------------------------------------------------------------
  # 3. Helpers to filter common slot types
  # ------------------------------------------------------------------
  filter_feature_sample_table <- function(df, keep_ids, keep_samples) {
    if (!is.data.frame(df)) return(df)
    if (!all(c("id", "feature") %in% names(df))) return(df)
    samp <- intersect(keep_samples, names(df))
    cols <- c("id", "feature", samp)
    out <- df[, cols, drop = FALSE]
    out[out$id %in% keep_ids, , drop = FALSE]
  }

  filter_feature_df_by_id <- function(df, keep_ids) {
    if (!is.data.frame(df)) return(df)
    if (!("id" %in% names(df))) return(df)
    df[df$id %in% keep_ids, , drop = FALSE]
  }

  filter_square_feature_matrix <- function(mat, keep_ids) {
    if (!is.matrix(mat) && !inherits(mat, "Matrix")) return(mat)
    rn <- rownames(mat); cn <- colnames(mat)
    if (is.null(rn) || is.null(cn)) return(mat)
    # only treat as square feature-feature matrix if row/col names overlap a lot with keep_ids
    if (nrow(mat) != ncol(mat)) return(mat)
    keep_r <- rn %in% keep_ids
    keep_c <- cn %in% keep_ids
    if (!any(keep_r) || !any(keep_c)) return(mat)
    mat[keep_r, keep_c, drop = FALSE]
  }

  # ------------------------------------------------------------------
  # 4. Build filtered mmo (preserve *all* slots, filtered where appropriate)
  # ------------------------------------------------------------------
  mmo_filtered <- mmo

  # Required slots
  mmo_filtered$feature_data <- feat_abund_filtered
  mmo_filtered$metadata <- meta[meta[[sample_col]] %in% keep_samples, , drop = FALSE]

  # Standard feature×sample tables if present
  for (nm in c("log", "zscore", "meancentered")) {
    if (nm %in% names(mmo_filtered)) {
      mmo_filtered[[nm]] <- filter_feature_sample_table(mmo_filtered[[nm]], features_keep, keep_samples)
    }
  }

  # Filter feature_info if present
  if ("feature_info" %in% names(mmo_filtered)) {
    mmo_filtered$feature_info <- filter_feature_df_by_id(mmo_filtered$feature_info, features_keep)
  }

  # Pairwise tables (feature-level data.frames with id)
  if ("pairwise" %in% names(mmo_filtered)) {
    mmo_filtered$pairwise <- filter_feature_df_by_id(mmo_filtered$pairwise, features_keep)
  }

  # Any “annotation-like” feature-level data.frame with an id column:
  # - this catches sirius_annot AND any sirius_annot_filtered_* you’ve created,
  #   plus other feature-level tables you add in the future.
  for (nm in names(mmo_filtered)) {
    obj <- mmo_filtered[[nm]]

    # Skip those we handled explicitly above
    if (nm %in% c("feature_data", "metadata", "log", "zscore", "meancentered", "feature_info", "pairwise")) next

    # Feature-level data.frames: subset rows by id
    if (is.data.frame(obj) && "id" %in% names(obj)) {
      mmo_filtered[[nm]] <- obj[obj$id %in% features_keep, , drop = FALSE]
      next
    }

    # Square feature-feature matrices: subset by row/col names
    if (is.matrix(obj) || inherits(obj, "Matrix")) {
      mmo_filtered[[nm]] <- filter_square_feature_matrix(obj, features_keep)
      next
    }
  }

  # Preserve class
  class(mmo_filtered) <- class(mmo)

  # ------------------------------------------------------------------
  # 5. Optional: filter an MGF in the same call
  # ------------------------------------------------------------------
  if (!is.null(mgf_path)) {
    if (!is.character(mgf_path) || length(mgf_path) != 1L || !nzchar(mgf_path) || !file.exists(mgf_path)) {
      stop("`mgf_path` must be a single existing file path.", call. = FALSE)
    }
    mgf_res <- filter_mgf_to_mmo(
      mmo = mmo_filtered,
      mgf_path = mgf_path,
      output_path = output_path,
      verbose = FALSE
    )
    mmo_filtered$mgf_filtered_path <- mgf_res$output_path
  }

  message("MMO object was subset")
  message(paste0("Feature number: ", nrow(mmo_filtered$feature_data)))
  message(paste0(nrow(mmo_filtered$metadata), " samples in ",
                 length(unique(mmo_filtered$metadata[[group_col]])), " groups"))

  mmo_filtered
}



########################################################################################
# Define functions for supporting analysis
########################################################################################

#' Retrieve feature data from the mmo object, with normalization options
#'
#' This function retrieves the feature data from the mmo object based on the specified normalization method.
#'
#' @param mmo The mmo object
#' @param normalization The normalization method to use. Options are 'None', 'Log', 'Meancentered', or 'Z'
#' @return The feature data corresponding to the specified normalization method
#' @export
#' @examplesIf FALSE
#' feature_data <- GetNormFeature(mmo, normalization = 'Log')
GetNormFeature <- function(mmo, normalization){
  if (normalization == 'None'){
    feature <- mmo$feature_data
  } else if (normalization == 'Log'){
    feature <- mmo$log
  } else if (normalization == 'Meancentered'){
    feature <- mmo$meancentered
  } else if (normalization == 'Z'){
    feature <- mmo$zscore
  } else {
    print('The normalization should be None, Log, Meancentered, or Z')
  }
  return(feature)
}


#' Get the distance matrix from the mmo object based on the specified distance metric
#'
#' This function retrieves the distance matrix from the mmo object based on the specified distance metric.
#'
#' @param mmo The mmo object
#' @param distance The distance metric to use. Options are 'dreams', 'cosine', or 'm2ds'
#' @return The distance matrix corresponding to the specified distance metric
#' @export
#' @examplesIf FALSE
#' distance_matrix <- GetDistanceMat(mmo, distance = 'dreams')
GetDistanceMat <- function(mmo, distance = 'dreams'){
  if (distance == 'dreams'){
    distance_matrix <- mmo$dreams.dissim
  } else if (distance == 'cosine'){
    distance_matrix <- mmo$cos.dissim
  } else if (distance == 'm2ds'){
    distance_matrix <- mmo$m2ds.dissim
  }
  return(distance_matrix)
}

#' Convert feature names to IDs in the mmo object
#'
#' This function converts feature names to their corresponding IDs in the mmo object.
#'
#' @param mmo The mmo object
#' @param feature_names A vector of feature names to convert
#' @return A vector of feature IDs corresponding to the input feature names
#' @export
#' @examplesIf FALSE
#' feature_ids <- FeatureToID(mmo, feature_names = c("100.0_5.0", "150.0_10.0"))
#' feature_ids <- FeatureToID(mmo, feature_names = mmo$feature_data$feature[1:10])
#' feature_ids <- FeatureToID(mmo,
#'  feature_names = Glucosinolates
#' ) # if Glucosinolates is a vector of feature names
FeatureToID <- function(mmo, feature_names) {
  feature_data <- mmo$feature_data
  feature_ids <- feature_data |>
    filter(.data$feature %in% feature_names) |>
    dplyr::select(.data$feature, .data$id)
  # Match the order of feature_names
  feature_ids <- feature_ids$id[match(feature_names, feature_ids$feature)]
  return(feature_ids)
}

#' Convert feature IDs to names in the mmo object
#'
#' This function converts feature IDs to their corresponding names in the mmo object.
#'
#' @param mmo The mmo object
#' @param feature_ids A vector of feature IDs to convert
#' @return A vector of feature names corresponding to the input feature IDs
#' @export
#' @examplesIf FALSE
#' feature_names <- IDToFeature(mmo, feature_ids = c("1219", "2250", "3360"))
#' feature_names <- IDToFeature(mmo, feature_ids = mmo$feature_data$id[1:10])
#' feature_names <- IDToFeature(mmo,
#'  feature_ids = FeatureToID(mmo, feature_names = Glucosinolates)
#' ) # if Glucosinolates is a vector of feature names
IDToFeature <- function(mmo, feature_ids) {
  feature_data <- mmo$feature_data
  feature_names <- feature_data |>
    filter(.data$id %in% feature_ids) |>
    dplyr::select(.data$id, .data$feature)
  # Match the order of feature_ids
  feature_names <- feature_names$feature[match(feature_ids, feature_names$id)]
  return(feature_names)
}

#' Calculate group means from the mmo object
#'
#' This function calculates and returns a dataframe of mean feature values for each group in the mmo object, with options for normalization and filtering.
#' Use SwitchGroup() to change the grouping variable before running this function.
#'
#' @param mmo The mmo object
#' @param normalization The normalization method to use. Options are 'None', 'Log', 'Meancentered', or 'Z'
#' @param filter_feature Boolean to filter features based on a provided list (default: FALSE)
#' @param feature_list A vector of feature names to filter (default: NULL)
#' @param filter_group Boolean to filter groups based on a provided list (default: FALSE)
#' @param group_list A vector of group names to filter (default: NULL)
#' @return A data frame containing the mean feature values for each group
#' @export
#' @examplesIf FALSE
#' group_means <- GetGroupMeans(mmo, normalization = 'Log')
#' group_means <- GetGroupMeans(mmo,
#'  normalization = 'None',
#'  filter_feature = TRUE, feature_list = Glucosinolates
#' ) # if Glucosinolates is a vector of feature names
#' group_means <- GetGroupMeans(mmo,
#'  normalization = 'Z',
#'  filter_group = TRUE,
#'  group_list = c("Control", "Treatment1")
#' )
#' group_means <- GetGroupMeans(mmo,
#'  normalization = 'Meancentered',
#'  filter_feature = TRUE, feature_list = Glucosinolates,
#'  filter_group = TRUE, group_list = c("Control", "Treatment1")
#' ) # if Glucosinolates is a vector of feature names
GetGroupMeans <- function(mmo, normalization = 'None', filter_feature = FALSE, feature_list = NULL, filter_group = FALSE, group_list = NULL) {
  feature_data <- GetNormFeature(mmo, normalization = normalization)
  metadata <- mmo$metadata

  # Melt the feature data to long format
  long_feature_data <- feature_data |>
    tidyr::pivot_longer(
      cols = -c(.data$id, .data$feature),                 # all columns except id and feature
      names_to = "sample",                    # old column names go here
      values_to = "feature_value"             # values go here
    )

  colnames(long_feature_data) <- c('id', 'feature', 'sample', 'feature_value')

  # Merge with metadata to get group information
  merged_data <- merge(long_feature_data, metadata[, c('sample', 'group')], by = 'sample')
  if (filter_group == TRUE){
    merged_data <- merged_data |> filter(.data$group %in% group_list)
  }
  # Calculate group means
  group_means <- merged_data |>
    dplyr::group_by(.data$group, .data$id) |>
    dplyr::summarise(mean_value = mean(.data$feature_value, na.rm = TRUE), .groups = "drop") |>
    tidyr::pivot_wider(
      names_from = .data$group,
      values_from = .data$mean_value
    )

  if (filter_feature) {
    group_means <- group_means |>
      dplyr::filter(.data$id %in% FeatureToID(mmo, feature_list))
  }
  return(group_means)
}

#' Calculate log2 fold change for a given control group
#'
#' This function calculates and returns a dataframe of log2 fold change values for each group compared to a specified control group.
#' Takes inputs from GetGroupMeans() function.
#'
#' @param group_means A data frame containing the mean feature values for each group
#' @param control_group The name of the control group to compare against
#' @return A data frame with log2 fold change values for each group compared to the control group
#' @export
#' @examplesIf FALSE
#' fold_change <- GetLog2FoldChange(GetGroupMeans(mmo,
#'                  normalization = 'Log'),
#'                  control_group = 'Control')
GetLog2FoldChange <- function(group_means, control_group) {
  control_means <- group_means[[control_group]]
  fold_change <- group_means |>
    mutate(across(-.data$id, ~ log2(. / control_means)))

  return(fold_change)
}


#' Perform ANOVA and Tukey's HSD test on the mmo object
#'
#' This function performs ANOVA and Tukey's HSD test on the feature data of the mmo object,
#' Returns a list of ANOVA results, Tukey's HSD results, Tukey's significance letters, and Dunnett's test results.
#'
#' @param df The data frame containing the feature data and metadata
#' @param formula The formula for the ANOVA test, e.g., "feature ~ group"
#' @return A list containing the ANOVA results, Tukey's HSD results, Tukey's significance letters, and Dunnett's test results
#' @export
#' @examplesIf FALSE
#' anova_results <- anova_tukey_dunnett(df = merged_data, formula = "feature_value ~ group")
anova_tukey_dunnett <- function(df, formula) {
  .require_pkg("DescTools")
  .require_pkg("multcompView")
  aov_res <- aov(as.formula(formula), data = df)
  tukey_res <- TukeyHSD(aov_res)
  tukey_sig <- multcompView::multcompLetters4(aov_res, tukey_res)
  dunnett_res <- DescTools::DunnettTest(as.formula(formula), data = df)
  return(list(aov_res = aov_res, tukey_res = tukey_res, tukey_sig = tukey_sig, dunnett_res = dunnett_res))
}

#' Write results of anova_tukey_dunnett to a CSV file
#'
#' This function writes the results of ANOVA and Tukey's HSD test to a CSV file.
#'
#' @param anova_data A list containing the results of ANOVA and Tukey's HSD test
#' @param outdir The output directory where the results will be saved
#' @param way The type of ANOVA test to perform. Options are 'oneway' or 'twoway'
#' @export
#' @examplesIf FALSE
#' write_anova(anova_data = anova_results, outdir = "anova_tukey_results.csv", way = 'oneway')
#'
write_anova <- function(anova_data, outdir, way='oneway'){
  way_num <- switch(way, oneway = 1, twoway = 3)
  # Perform ANOVA and Tukey HSD
  aov_res <- anova_data$aov_res
  tukey_res <- anova_data$tukey_res
  tukey_sig <- anova_data$tukey_sig[way_num]
  dunnett_res <- anova_data$dunnett_res

  # Save ANOVA and Tukey HSD results
  anova_df <- as.data.frame(summary(aov_res)[[1]])
  anova_df$Comparison <- rownames(anova_df)
  tukey_df <- as.data.frame(tukey_res[way_num])
  tukey_df$Comparison <- rownames(tukey_df)
  sig_letter <- as.data.frame(unlist(tukey_sig))
  sig_letter$Comparison <- rownames(sig_letter)
  dunnett_df <- as.data.frame(dunnett_res[[1]])
  dunnett_df$comp <- rownames(dunnett_df)

  # Create a combined results data frame
  combined_df <- dplyr::bind_rows(
    dplyr::tibble(Test = "ANOVA", anova_df),
    dplyr::tibble(Test = "Tukey", tukey_df),
    dplyr::tibble(Test = 'sig', sig_letter),
    dplyr::tibble(Test = 'Dunnett', dunnett_df)
  )
  readr::write_csv(combined_df, file = outdir)
}

#' Perform PERMANOVA and pairwise comparisons
#'
#' This function performs PERMANOVA on the given data and metadata, with options for filtering groups.
#' It also conducts post-hoc pairwise comparisons and adjusts p-values for multiple testing.
#' The function returns the PERMANOVA results, raw pairwise comparison results, and matrices of adjusted p-values, F values, and R square for pairwise comparisons
#'
#' @param data A data frame or distance matrix for PERMANOVA
#' @param metadata A data frame containing sample metadata, including a 'group' column
#' @param mode The mode of the input data: 'data' for raw data or 'distance' for a distance matrix
#' @param filter_group Boolean to filter groups based on a provided list (default: FALSE)
#' @param group_list A vector of group names to filter (default: NULL)
#' @param permutations The number of permutations for the PERMANOVA test (default: 5000)
#' @return A list containing the PERMANOVA results, raw pairwise comparison results, and matrices of adjusted p-values, F values, and R square for pairwise comparisons
#' @export
#' @examplesIf FALSE
#' permanova_results <- permanova_stat(
#'  data = feature_data, metadata = mmo$metadata,
#'  mode = 'data', filter_group = TRUE, group_list = c("Control", "Treatment1"),
#'  permutations = 5000
#' )
#' permanova_results <- permanova_stat(
#'  data = betadiv, metadata = mmo$metadata,
#'  mode = 'distance', permutations = 10000
#' )
permanova_stat <- function(data, metadata, mode, filter_group = FALSE, group_list = NULL, permutations = 5000){
  .require_pkg("vegan")
  .require_pkg("stringr")
  .require_pkg("pairwiseAdonis")
  #Perform PERMANOVA
  if (mode == 'data'){
    dist_mat <- stats::dist(data)
  } else if (mode == 'distance'){
    dist_mat <- as.dist(data)
  } else {
    stop("Invalid mode for adonis2. Please use 'data' or 'distance'")
  }
  dist_mat <- dist(data)
  metadata <- metadata[match(rownames(data), metadata$sample), ]
  if (filter_group == TRUE){
    metadata <- metadata |> filter(.data$group %in% group_list)
    dist_mat <- as.dist(as.matrix(dist_mat)[metadata$sample, metadata$sample])
  }
  permanova_res <- vegan::adonis2(dist_mat ~ group, data = metadata, permutations = permutations)
  #Post-hoc
  pairwise_permanova <- pairwiseAdonis::pairwise.adonis2(dist_mat ~ group, data = metadata, permutations = permutations)
  # Multiple test correction for pairwise p-values
  pvals <- sapply(pairwise_permanova[-1], function(x) x[1,5])
  pvals_adj <- p.adjust(pvals, method = "BH")
  # Add adjusted p-values to pairwise_permanova
  for (i in seq_along(pvals_adj)) {
    pairwise_permanova[[i+1]]$padj <- pvals_adj[i]
  }
  #Organize posthoc results for visual
  pairwise_p_matrix <- matrix(NA, nrow = length(unique(metadata$group)), ncol = length(unique(metadata$group)))
  rownames(pairwise_p_matrix) <- unique(metadata$group)
  colnames(pairwise_p_matrix) <- unique(metadata$group)
  for (i in 2:length(pairwise_permanova)){
    group1 <- stringr::str_split(names(pairwise_permanova)[i], '_vs_')[[1]][1]
    group2 <- stringr::str_split(names(pairwise_permanova)[i], '_vs_')[[1]][2]
    pval <- pairwise_permanova[[i]][1,6]
    pairwise_p_matrix[group2, group1] <- pval
  }
  # Organize posthoc F values for visualization
  pairwise_F_matrix <- matrix(NA, nrow = length(unique(metadata$group)), ncol = length(unique(metadata$group)))
  rownames(pairwise_F_matrix) <- unique(metadata$group)
  colnames(pairwise_F_matrix) <- unique(metadata$group)
  for (i in 2:length(pairwise_permanova)){
    group1 <- stringr::str_split(names(pairwise_permanova)[i], '_vs_')[[1]][1]
    group2 <- stringr::str_split(names(pairwise_permanova)[i], '_vs_')[[1]][2]
    Fval <- pairwise_permanova[[i]][1,4]
    pairwise_F_matrix[group2, group1] <- Fval
  }
  # Organize posthoc R^2 values for visualization
  pairwise_R2_matrix <- matrix(NA, nrow = length(unique(metadata$group)), ncol = length(unique(metadata$group)))
  rownames(pairwise_R2_matrix) <- unique(metadata$group)
  colnames(pairwise_R2_matrix) <- unique(metadata$group)
  for (i in 2:length(pairwise_permanova)){
    group1 <- stringr::str_split(names(pairwise_permanova)[i], '_vs_')[[1]][1]
    group2 <- stringr::str_split(names(pairwise_permanova)[i], '_vs_')[[1]][2]
    R2val <- pairwise_permanova[[i]][1,3]
    pairwise_R2_matrix[group2, group1] <- R2val
  }
  return(list(permanova_res = permanova_res, pairwise_raw = pairwise_permanova, pairwise_p_matrix = pairwise_p_matrix, pairwise_F_matrix = pairwise_F_matrix, pairwise_R2_matrix = pairwise_R2_matrix))
}

########################################################################################
# Define functions for pairwise comparison and visualization
########################################################################################

#' Perform pairwise comparison between two groups in the mmo object
#'
#' This function performs pairwise comparison between two groups in the mmo object,
#' calculating log2 fold change and adjusted p-values for given comparison of two groups.
#' The function adds the results to the mmo$pairwise data frame.
#'
#' @param mmo The mmo object
#' @param group1 The name of the nominator group
#' @param group2 The name of the denominator group
#' @param correction The method for multiple comparison correction. Options are 'BH', 'holm', 'bonferroni', etc. Inherits from p.adjust() (default: 'BH')
#' @return The mmo object with pairwise comparison results added to mmo$pairwise
#' @export
#' @examplesIf FALSE
#' mmo <- PairwiseComp(mmo, group1 = 'Control', group2 = 'Treatment1')
PairwiseComp <- function(mmo, group1, group2, correction = 'BH'){
  feature <- mmo$feature_data
  metadata <- mmo$metadata
  #Get sample names
  group1_samples <- metadata |> filter(.data$group == group1) |> pull(sample)
  group2_samples <- metadata |> filter(.data$group == group2) |> pull(sample)
  #Get data from the samples
  group1_data <- feature |> dplyr::select(.data$id, .data$feature, all_of(group1_samples))
  group2_data <- feature |> dplyr::select(.data$id, .data$feature, all_of(group2_samples))
  #Make empty column
  log2FC <- numeric(nrow(.data$feature))
  pval <- numeric(nrow(.data$feature))
  #Pairwise comparison
  for (i in 1:nrow(.data$feature)){
    group1_value <- as.numeric(group1_data[i, -c(1,2)])
    group2_value <- as.numeric(group2_data[i, -c(1,2)])

    group1_mean <- mean(group1_value, na.rm = TRUE)
    group2_mean <- mean(group2_value, na.rm = TRUE)
    log2FC[i] <- log2(group2_mean/group1_mean)

    pval[i] <- tryCatch(
      expr = {
        p <- t.test(group1_value, group2_value, na.rm = TRUE)$p.value
        p
      },
      error = function(e)
      {
        return(1)
      }
    )

    # ttest <- t.test(group1_value, group2_value, na.rm = TRUE)

    # pval[i] <- ttest$p.value
  }
  padj <- p.adjust(pval, method = correction)
  #Store in results
  results <- data.frame(
    log2FC= log2FC,
    padj = padj
  )
  names(results) <- c(paste(group1, "vs", group2, "log2FC", sep = "_"), paste(group1, "vs", group2, "padj", sep = "_"))
  #Add pairwise results to the mmo object
  mmo$pairwise <- cbind(mmo$pairwise, results)
  print(paste(group2, '/', group1, 'comparison was completed'))
  return(mmo)
}


#' Generates lists of DAMs (Differentially Accumulated Metabolites) for each comparison in the mmo object
#'
#' This function generates lists of upregulated and downregulated DAMs for each pairwise comparison in the mmo object.
#' It uses log2 fold change and adjusted p-value thresholds to determine significance.
#' Make sure to run PairwiseComp() for all desired comparisons before using this function.
#'
#' @param mmo The mmo object with pairwise comparison matrix
#' @param fc_cutoff The threshold of log2 fold change to be considered significant (default: 0.5849625, which is log2(1.5))
#' @param pval_cutoff The threshold of adjusted p-value to be considered significant (default: 0.05)
#' @return A list containing two lists: DAMs_up and DAMs_down
#' @export
#' @examplesIf FALSE
#' dams <- GetDAMs(mmo, fc_cutoff = 0.5849625, pval_cutoff = 0.05)
#' dams_up <- dams$DAMs_up
#' dams_down <- dams$DAMs_down
GetDAMs <- function(mmo, fc_cutoff = 0.5849625, pval_cutoff = 0.05) {
  # Generate the list of comparisons automatically by looking up mmo$pairwise
  comparison_columns <- colnames(mmo$pairwise)
  log2FC_columns <- grep("log2FC", comparison_columns, value = TRUE)
  comparisons <- unique(sub("log2FC", "", log2FC_columns))
  comparisons <- sub("_$", "", comparisons)  # Remove trailing underscore from comparisons
  # Make list of DAMs for up and downregulation for each comparison
  DAMs_up <- list()
  DAMs_down <- list()
  for (comp in comparisons) {
    group1 <- strsplit(comp, "_vs_")[[1]][1]
    group2 <- strsplit(comp, "_vs_")[[1]][2]
    DAMs_up[[paste(comp, "up", sep = ".")]] <- filter(mmo$pairwise, get(paste(comp, "log2FC", sep = "_")) > fc_cutoff & get(paste(comp, "padj", sep = "_")) < pval_cutoff)$feature
    DAMs_down[[paste(comp, "down", sep = ".")]] <- filter(mmo$pairwise, get(paste(comp, "log2FC", sep = "_")) < -fc_cutoff & get(paste(comp, "padj", sep = "_")) < pval_cutoff)$feature
  }
  names(DAMs_up) <- paste(comparisons, "up", sep = ".")
  names(DAMs_down) <- paste(comparisons, "down", sep = ".")
  return(list(DAMs_up = DAMs_up, DAMs_down = DAMs_down))
}



#' Volcano plot for visualizing differential metabolite analysis results
#'
#' This function generates a volcano plot using data from mmo$pairwise (PairwiseComp(mmo, 'group1', 'group2') should be precended),
#' highlighting upregulated and downregulated features based on log2 fold change and adjusted p-value
#'
#' @param mmo The mmo object with pairwise comparison matrix
#' @param comp The comparison to visualize, e.g., 'group1_vs_group2
#' @param topk The number of top features to label in the plot (default: 10)
#' @param pthr The threshold of adjusted p-value to be considered significant (default: 0.05)
#' @param outdir The output file path for the volcano plot (default: 'volcano.png')
#' @param height The height of the output plot in inches (default: 5)
#' @param width The width of the output plot in inches (default: 5)
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @return A list containing the volcano plot and the data used to generate it
#' @export
#' @examplesIf FALSE
#' VolcanoPlot(
#'  mmo, comp = 'Control_vs_Treatment1',
#'  topk = 10, pthr = 0.05,
#'  outdir = 'volcano_con_tre1.png', height = 5, width = 5
#' )
VolcanoPlot <- function(mmo, comp, topk = 10, pthr = 0.05, outdir = 'volcano.png', height = 5, width = 5, save_output = TRUE){
  .require_pkg("ggrepel")
  VolData <- mmo$pairwise |> dplyr::select(.data$feature,all_of(c(paste(comp, 'log2FC', sep = '_'), paste(comp, 'padj', sep = '_'))))
  colnames(VolData) <- c('feature', 'log2FC', 'padj')
  VolData <- VolData |>
    mutate(
      Expression = dplyr::case_when(log2FC >= 1 & padj <= pthr ~ "Up-regulated",
                            log2FC <= -1 & padj <= pthr ~ "Down-regulated",
                            TRUE ~ "Not significant")
      )

  top_features <- dplyr::bind_rows(
    VolData |>
      filter(.data$Expression =='Up-regulated')  |>
      arrange(dplyr::desc(abs(.data$log2FC)), .data$padj) |>
      head(topk),
    VolData |>
      filter(.data$Expression == 'Down-regulated') |>
      arrange(dplyr::desc(abs(.data$log2FC)), .data$padj) |>
      head(topk)
  )

  plot <- ggplot(VolData, aes(x = .data$log2FC, y = -log(.data$padj, 10))) +
    geom_point(aes(color = .data$Expression), size = 0.4)+
    xlab(expression("log"[2]*"FC")) +
    ylab(expression("-log"[10]*"FDR"))+
    scale_color_manual(values = c("dodgerblue3", "gray50", "firebrick3")) +
    guides(colour = guide_legend(override.aes = list(size=1.5))) +
    theme_classic()+
    ggrepel::geom_label_repel(data = top_features,
                    mapping = aes(.data$log2FC, -log(.data$padj,10), label = .data$feature),
                    size = 2)

  plot
  if (save_output){
    ggsave(outdir, height = height, width = width)
    readr::write_csv(VolData, paste0(outdir, '_volcano_data.csv'))
  }
  return(list(plot = plot, df = VolData))
}

########################################################################################
# Define functions for multivariate analysis
########################################################################################


#' Plots PCA and performs PERMANOVA
#'
#' This function performs PCA analysis and generates a PCA plot with optional filtering of features and groups.
#' It also conducts PERMANOVA and saves the results to CSV files.
#'
#' @param mmo The mmo object with feature data and metadata
#' @param color A vector of colors for the groups in the plot. Make sure the names correspond to the group names in metadata
#' @param outdir The output file path for the PCA plot (default: 'PCA')
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'Z')
#' @param filter_feature Boolean to filter features by feature_list (default: FALSE)
#' @param feature_list A vector of feature names to filter (default: NULL)
#' @param filter_group Boolean to filter groups by group_list (default: FALSE)
#' @param group_list A vector of group names to filter (default: NULL)
#' @param label Boolean to indicate whether to label points with sample names (default: TRUE)
#' @param save_output Boolean; if TRUE (default) write plot (.pdf) and PERMANOVA
#'   tables using `outdir` as prefix. If FALSE, nothing is written.
#' @return A list with elements `plot` (ggplot), `df` (raw data to generate plots),
#'   and `permanova` (results from `permanova_stat`).
#' @export
#' @examplesIf FALSE
#' PCAplot(
#'  mmo, color = c("Control" = "blue", "Treatment1" = "red", "Treatment2" = "green"),
#'  outdir = 'PCA_plot', normalization = 'None',
#'  filter_feature = FALSE, filter_group = FALSE, label = FALSE
#' )
#' PCAplot(
#'  mmo, color = c("Control" = "blue", "Treatment1" = "red"),
#'  outdir = 'PCA_plot', normalization = 'Z',
#'  filter_feature = TRUE, feature_list = Glucosinolates,
#'  filter_group = TRUE, group_list = c("Control", "Treatment1"), label = TRUE
#' )
PCAplot <- function(mmo, color, outdir = 'PCA', normalization = 'Z', filter_feature = FALSE, feature_list = NULL, filter_group = FALSE, group_list = NULL, label = TRUE, save_output = TRUE){
  .require_pkg("ggrepel")
  .require_pkg("stats")
  metadata <- mmo$metadata
  feature <- GetNormFeature(mmo, normalization)
  if (filter_feature == TRUE){
    feature <- feature |> filter(.data$feature %in% feature_list)
  }
  # Perform PCA on normalized feature data
  feature_data_pca <- feature[, -(1:2)]
  feature_data_pca <- t(feature_data_pca) # samples as rows, features as columns
  pca_res <- stats::prcomp(feature_data_pca, scale. = TRUE)
  pca_df <- as.data.frame(pca_res$x)
  pca_df$group <- metadata$group[match(rownames(pca_df), metadata$sample)]

  if (filter_group == TRUE){
    pca_df <- pca_df |> filter(.data$group %in% group_list)
  }
  if (label == TRUE){
    plot <- ggplot(pca_df, aes(x = .data$PC1, y = .data$PC2, color = .data$group, label = rownames(pca_df))) +
      geom_point(size = 3) +
      ggrepel::geom_label_repel(aes(label = rownames(pca_df)), size = 3) +
      theme_classic() +
      labs(x = "PC1", y = "PC2") +
      scale_color_manual(values = color)+
      stat_ellipse(aes(group = .data$group), level = 0.90)
  } else {
    plot <- ggplot(pca_df, aes(x = .data$PC1, y = .data$PC2, color = .data$group)) +
      geom_point(size = 3) +
      # geom_label_repel(aes(label = rownames(pca_df)), size = 3) +
      theme_classic() +
      labs(x = "PC1", y = "PC2") +
      scale_color_manual(values = color)+
      stat_ellipse(aes(group = .data$group), level = 0.90)
  }
  permanova <- permanova_stat(feature_data_pca, metadata, mode = 'data', filter_group = filter_group, group_list = group_list)
  plot
  if (isTRUE(save_output)) {
    ggsave(paste0(outdir, '.pdf'), width = 6, height = 6)
    readr::write_csv(permanova$permanova_res, paste0(outdir, '_permanova_results.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_raw), paste0(outdir, '_pairwise_permanova_results.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_p_matrix), paste0(outdir, '_pairwise_permanova_pvalue_matrix.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_F_matrix), paste0(outdir, '_pairwise_permanova_Fvalue_matrix.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_R2_matrix), paste0(outdir, '_pairwise_permanova_R2_matrix.csv'))
  }

  return(invisible(list(plot = plot, df = pca_df, permanova = permanova)))
}




#' PLS-DA plot with feature loadings
#'
# This function performs PLS-DA analysis and generates a PLS-DA plot with feature loadings.
#'
#' @param mmo The mmo object with feature data and metadata
#' @param color A vector of colors for the groups in the plot. Make sure the names correspond to the group names in metadata
#' @param topk The number of top features to display in the plot (default: 10)
#' @param outdir The output file path for the PLS-DA plot
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'Z')
#' @param filter_feature Boolean to filter features by feature_list (default: FALSE)
#' @param feature_list A vector of feature names to filter (default: NULL)
#' @param filter_group Boolean to filter groups by group_list (default: FALSE)
#' @param group_list A vector of group names to filter (default: NULL)
#' @param save_output Boolean; if TRUE (default) write plot (.pdf) and loadings
#'   tables using `outdir` as prefix. If FALSE, nothing is written.
#' @return A list with elements `plot` (ggplot), `df` (raw data to generate plots),
#'   and `loadings` (loadings for PLSDA).
#' @export
#' @examplesIf FALSE
#' PLSDAplot(
#'  mmo, color = c("Control" = "blue", "Treatment1" = "red", "Treatment2" = "green"),
#'  topk = 10, outdir = 'PLSDA_plot.pdf', normalization = 'Z',
#'  filter_feature = FALSE, filter_group = FALSE
#' )
#' PLSDAplot(
#'  mmo, color = c("Control" = "blue", "Treatment1" = "red"),
#'  topk = 5, outdir = 'PLSDA_plot.pdf', normalization = 'Log',
#'  filter_feature = TRUE, feature_list = Glucosinolates,
#'  filter_group = TRUE, group_list = c("Control", "Treatment1")
#' )
PLSDAplot <- function(mmo, color, topk = 10, outdir, normalization = 'Z', filter_feature = FALSE, feature_list = NULL, filter_group = FALSE, group_list = NULL, save_output = TRUE) {
  .require_pkg("caret")
  .require_pkg("ggrepel")

  metadata <- mmo$metadata
  #Get appropriate feature by normalization parameter
  feature <- GetNormFeature(mmo, normalization)

  # All feature or filtered feature
  if (filter_feature == TRUE){
    feature <- feature |> filter(feature %in% feature_list)
  }

  X <- t(as.matrix(feature[, -(1:2)]))
  Y <- c()
  for (col in colnames(feature)[-c(1,2)]){
    Y <- append(Y, metadata[metadata$sample == col, ]$group)
  }
  Y <- as.factor(Y)

  plsda_model <- caret::plsda(X, Y, ncomp = 2)
  scores <- plsda_model$scores[, 1:2]
  plsda_df <- data.frame(Comp1 = scores[, 1], Comp2 = scores[, 2], Group = Y)
  loadings <- plsda_model$loadings
  loadings_comp1 <- loadings[, 1]
  loadings_comp2 <- loadings[, 2]
  if (filter_feature == FALSE){
    loadings_df <- data.frame(Feature = mmo$feature_data$feature,
                            Comp1_Loading = loadings_comp1,
                            Comp2_Loading = loadings_comp2)
  } else {
    loadings_df <- data.frame(Feature = feature_list,
                            Comp1_Loading = loadings_comp1,
                            Comp2_Loading = loadings_comp2)
  }


  top_features <- loadings_df |>
  mutate(abs_loading_comp1 = abs(.data$Comp1_Loading),
         abs_loading_comp2 = abs(.data$Comp2_Loading)) |>
  arrange(dplyr::desc(.data$abs_loading_comp1 + .data$abs_loading_comp2)) |>
  head(topk)
  loading_scale <- 1
  if (topk > 0){
  loading_scale <- max(abs(scores))/(4*max(abs(top_features$Comp1_Loading)))
  }

  if (filter_group == TRUE){
    plsda_df <- plsda_df |> filter(.data$Group %in% group_list)
  }

 plot <-  ggplot(plsda_df, aes(x = .data$Comp1, y = .data$Comp2, color = .data$Group)) +
    geom_point(size = 3) +
    theme_classic() +
    stat_ellipse(level = 0.90) +
    ggtitle("PLS-DA Plot") +
    labs(x = "Component 1", y = "Component 2") +
    scale_color_manual(values = color) +
    theme(legend.position = "right")+
    geom_segment(data = top_features,
                aes(x = 0, y = 0, xend = .data$Comp1_Loading * loading_scale, yend = .data$Comp2_Loading * loading_scale),  # Scale the arrows
                arrow = grid::arrow(length = grid::unit(0.3, "cm")), color = "grey", linewidth = 1) +
    # Add labels for the top 10 features
    ggrepel::geom_text_repel(data = top_features,
              aes(x = .data$Comp1_Loading * loading_scale, y = .data$Comp2_Loading * loading_scale, label = .data$Feature),
              color = "black", vjust = 1.5, size = 3)
  plot
  if (save_output) {
    ggsave(paste0(outdir, 'PLSDA_plot.pdf'), height = 6, width = 6)
    readr::write_csv(loadings_df, paste0(outdir, 'PLSDA_loadings.csv'))
  }
  return(list(plot = plot, df = plsda_df, loadings = loadings_df))
}

#' Generate input files to be used for pheatmap from the mmo object
#'
#' This function generates heatmap inputs from the mmo object, including fold change or mean values,
#' distance matrix, and row labels for custom-annotated features.
#'
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param filter_feature Boolean to filter features by feature_list (default: FALSE)
#' @param feature_list A vector of feature names to filter (default: NULL)
#' @param filter_group Boolean to filter groups by group_list (default: FALSE)
#' @param group_list A vector of group names to filter (default: NULL)
#' @param summarize The summarization method to use. Options are 'fold_change' or 'mean' (default: 'mean')
#' @param control_group The group to use as control for fold change calculation (default: 'ctrl')
#' @param normalization The normalization method to use. Options are 'None', 'Log', 'Meancentered', or 'Z'
#' @param distance The distance metric to use. Options are 'dreams', 'cosine', or 'm2ds' (default: 'dreams')
#' @return A list containing the following elements:
#' - FC_matrix: A matrix of fold change or mean values
#' - dist_matrix: A distance matrix based on the specified distance metric
#' - row_label: A vector of row labels for custom-annotated features (See AddCustomAnnot()). If no custom annotation is available, feature IDs are used.
#' - heatmap_data: A data frame containing the heatmap data with feature IDs and values
#' @export
#' @examplesIf FALSE
#' # Generate heatmap inputs to visualize fold change values with log normalization and dreams distance
#' heatmap_inputs <- GenerateHeatmapInputs(
#'  mmo, summarize = 'fold_change', control_group = 'Control',
#'  normalization = 'None', distance = 'dreams'
#' )
#' # Generate heatmap inputs to visualize mean values
#' heatmap_inputs <- GenerateHeatmapInputs(
#'  mmo, summarize = 'mean', normalization = 'None', distance = 'dreams'
#' )
#' # The resulting list contains FC_matrix, dist_matrix, row_label, and heatmap_data
#' # A heatmap can be generated using pheatmap
#' # 'clustering_distance_rows' option make the dendrogram follows chemical distances of features.
#' #  -Delete this option to visualize the heatmap following cannonical clustering
#' pheatmap(mat = heatmap_inputs$FC_matrix,
#'     cluster_rows = TRUE, #do not change
#'     clustering_distance_rows = heatmap_inputs$dist_matrix,
#'     cluster_cols = TRUE,
#'     clustering_method = "average", #UPGMA
#'     show_rownames = TRUE,
#'     show_colnames = TRUE,
#'     cellwidth = 25,
#'     cellheight = 0.05,
#'     treeheight_row = 100,
#'     fontsize_row = 3,
#'     fontsize_col = 15,
#'     scale = 'none',
#'     annotation_names_row = TRUE,
#'     labels_row = heatmap_inputs$row_label,
#'     )
GenerateHeatmapInputs <- function(mmo, filter_feature = FALSE, feature_list = NULL,
                                filter_group = FALSE, group_list = NULL,
                                summarize = 'mean', control_group = 'ctrl',
                                normalization = 'None', distance = 'dreams') {
  # 12.1.1. Get summarized data (group mean or FC)
  if (filter_group){
    group_means <- GetGroupMeans(mmo, normalization = normalization, filter_group = TRUE, group_list = group_list)
  } else {
    group_means <- GetGroupMeans(mmo, normalization = normalization)
  }
  if (summarize == 'fold_change'){
    fold_change <- GetLog2FoldChange(group_means, control_group = control_group)
    heatmap_data <- fold_change
    heatmap_data[[control_group]] <- NULL
  } else if(summarize == 'mean'){
    heatmap_data <- group_means
  }
  # 12.1.2. Filter features
  # Determine distance metric
  distance_matrix <- GetDistanceMat(mmo, distance = distance)
  heatmap_data <- heatmap_data |> filter(id %in% rownames(distance_matrix)) # remove features not in distance matrix

  # make matrix for heatmap
  FC_matrix <- as.matrix(heatmap_data[,-1])
  rownames(FC_matrix) <- heatmap_data$id
  # Reorder the rows of distance_matrix to match the order of FC_matrix_
  distance_matrix <- distance_matrix[rownames(FC_matrix), rownames(FC_matrix)]
  dist_matrix <- as.dist(distance_matrix)

  row_label <- rownames(FC_matrix)
  if (filter_feature){
    filter_list <- feature_list
    filter_id <- FeatureToID(mmo, filter_list)
    filter_id <- filter_id[filter_id %in% rownames(distance_matrix)] # remove custom-annotated but not in the distance matrix
    filter_distance <- distance_matrix[filter_id, filter_id]
    heatmap_data <- heatmap_data |> filter(id %in% filter_id)

    # make matrix for heatmap
    FC_matrix <- as.matrix(heatmap_data[,-1])
    rownames(FC_matrix) <- heatmap_data$id


    # Reorder the rows of distance_matrix to match the order of FC_matrix_
    filter_distance <- filter_distance[rownames(FC_matrix), rownames(FC_matrix)]
    dist_matrix <- as.dist(filter_distance)
    #Label custm-annotated features
    row_label <- rownames(FC_matrix)
    for (i in 1:length(rownames(FC_matrix))){
      id <- rownames(FC_matrix)[i]
      custom_annot <- mmo$custom_annot$custom_annot[mmo$custom_annot$id == id]
      if (length(custom_annot[[1]]) > 0) {
        row_label[i] <- custom_annot[[1]]
      }
    }
  }
  return(list(FC_matrix = FC_matrix, dist_matrix = dist_matrix, row_label = row_label, heatmap_data = heatmap_data))
}

#' PlotNPCStackedBar
#'
#' This function generates a stacked bar plot showing the count of features in each group categorized by NPC_pathway.
#' It uses the mmo object with sirius annotation and normalized data.
#' Make sure you don't run ReplaceZero() before using this function, as it may remove presence/absence information.
#'
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param group_col The column name in metadata to use for grouping samples
#' @param outdir The output file path for the stacked bar plot (e.g., 'NPC_stacked_bar.png')
#' @param width The width of the output plot
#' @param height The height of the output plot
#' @param save_output boolean, whether to save the output plot
#' @return A list containing the stacked bar plot and the data used to generate it
#' @export
#' @examplesIf FALSE
#' PlotNPCStackedBar(
#'  mmo, group_col = 'treatment',
#'  outdir = 'NPC_stacked_bar.png', width = 6, height = 3
#' )
PlotNPCStackedBar <- function(mmo, group_col, outdir, width = 6, height = 3, save_output = TRUE) {
  mmo <- SwitchGroup(mmo, group_col)
  feature_data <- mmo$feature_data
  metadata <- mmo$metadata

  # For each group, get features present in any sample
  group_features <- lapply(unique(metadata$group), function(grp) {
    samples <- metadata |> filter(.data$group == grp) |> pull(.data$sample)
    present <- feature_data |> dplyr::select(all_of(samples))
    feature_data$feature[base::rowSums(!is.na(present) & present > 0) > 0]
  })
  names(group_features) <- unique(metadata$group)

  # Build long data frame: feature, group, NPC_pathway
  annot <- mmo$sirius_annot[, c("feature", "NPC#pathway")]
  colnames(annot) <- c("feature", "NPC_pathway")

  bar_df <- do.call(rbind, lapply(names(group_features), function(grp) {
    data.frame(
      feature = group_features[[grp]],
      group = grp,
      stringsAsFactors = FALSE
    )
  }))
  bar_df <- merge(bar_df, annot, by = "feature", all.x = TRUE)
  bar_df <- bar_df[!is.na(bar_df$NPC_pathway) & bar_df$NPC_pathway != "", ]

  # Count features per group and NPC_pathway
  plot_df <- bar_df |>
    dplyr::group_by(.data$group, .data$NPC_pathway) |>
    dplyr::summarise(count = dplyr::n(), .groups = "drop")

  # Set colors for NPC_pathway
  npc_pathways <- unique(plot_df$NPC_pathway)
  .require_pkg("RColorBrewer")
  bar_colors <- setNames(RColorBrewer::brewer.pal(min(length(npc_pathways), 8), "Set2"), npc_pathways)

  # Plot stacked bar by NPC_pathway
  plot <- ggplot(plot_df, aes(x = .data$group, y = .data$count, fill = .data$NPC_pathway, label = .data$count)) +
    geom_bar(stat = "identity", position = "stack") +
    geom_text(aes(group = .data$NPC_pathway), position = position_stack(vjust = 0.5), size = 3, color = "white", fontface = "bold") +
    scale_fill_manual(values = bar_colors) +
    coord_flip() +
    labs(x = "Group", y = "Feature Count", fill = "NPC Pathway") +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  if (save_output){
    ggsave(paste0(outdir, 'NPC_stacked_bar.pdf'), width = width, height = height)
    readr::write_csv(plot_df, paste0(outdir, 'NPC_stacked_bar.csv'))
  }
  return(list(plot = plot, df = plot_df))
}

#' Enrichment analysis for Canopus-predicted terms
#'
#' This function performs enrichment analysis for Canopus-predicted terms on a given list of features.
#'
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param list_test A vector containing names of features to analyze
#' @param pthr The threshold for adjusted p-value to be considered significant (default: 0.1)
#' @param sig A logical value indicating whether to return only significant terms (default: TRUE)
#' @param term_level The level of term to use for enrichment analysis
#'               Options are 'NPC_pathway', 'NPC_superclass', 'NPC_class', 'ClassyFire_superclass', 'ClassyFire_class',
#'              'ClassyFire_subclass', 'ClassyFire_level5', or 'ClassyFire_most_specific' (default: 'NPC_pathway')
#' @param representation The representation type for enrichment analysis. Options are 'greater' for overrepresentation (default: 'greater')
#' @param pval pvalue options-pval or fdr (default: 'pval')
#' @return A data frame containing the enrichment results, including term level,
#'        term name, subset count, total count, fold enrichment, p-value, and adjusted p-value (FDR)
#' @export
#' @examplesIf FALSE
#' # Perform enrichment analysis for a list of features using NPC_pathway level
#' sig_terms <- CanopusLevelEnrichmentAnal(
#'  mmo, list_test = c("feature1", "feature2"), pthr = 0.1,
#'  sig = TRUE, term_level = 'NPC_pathway', representation = 'greater'
#' )
#' # Perform enrichment analysis for a list of features using
#' # ClassyFire_class level and return all terms
#' all_terms <- CanopusLevelEnrichmentAnal(
#'  mmo, list_test = c("feature1", "feature2"), pthr = 0.1,
#'  sig = FALSE, term_level = 'ClassyFire_class', representation = 'greater'
#' )
CanopusLevelEnrichmentAnal <- function(mmo,list_test, pthr = 0.1, sig=TRUE, term_level = 'NPC_pathway', representation = 'greater', pval = 'pval'){
  all_feature <- mmo$sirius_annot
  subset_feature <- mmo$sirius_annot |> filter(.data$feature %in% list_test)
  # print(paste('total features:', nrow(all_feature), 'list_test features:', nrow(subset_feature)))
  # Select the appropriate term level for enrichment analysis
  if (term_level == "NPC_pathway") {
    all_feature$classifications_split <- all_feature[['NPC#pathway']]
    subset_feature$classifications_split <- subset_feature[['NPC#pathway']]
  } else if (term_level == "NPC_superclass") {
    all_feature$classifications_split <- all_feature[['NPC#superclass']]
    subset_feature$classifications_split <- subset_feature[['NPC#superclass']]
  } else if (term_level == "NPC_class") {
    all_feature$classifications_split <- all_feature[['NPC#class']]
    subset_feature$classifications_split <- subset_feature[['NPC#class']]
  } else if (term_level == "ClassyFire_superclass") {
    all_feature$classifications_split <- all_feature[['ClassyFire#superclass']]
    subset_feature$classifications_split <- subset_feature[['ClassyFire#superclass']]
  } else if (term_level == "ClassyFire_class") {
    all_feature$classifications_split <- all_feature[['ClassyFire#class']]
    subset_feature$classifications_split <- subset_feature[['ClassyFire#class']]
  } else if (term_level == "ClassyFire_subclass") {
    all_feature$classifications_split <- all_feature[['ClassyFire#subclass']]
    subset_feature$classifications_split <- subset_feature[['ClassyFire#subclass']]
  } else if (term_level == "ClassyFire_level5") {
    all_feature$classifications_split <- all_feature[['ClassyFire#level 5']]
    subset_feature$classifications_split <- subset_feature[['ClassyFire#level 5']]
  } else if (term_level == "ClassyFire_most_specific") {
    all_feature$classifications_split <- all_feature[['ClassyFire#most specific class']]
    subset_feature$classifications_split <- subset_feature[['ClassyFire#most specific class']]
  } else {
    stop("Invalid term level. Please choose a valid term level.")
  }

  total_term_counts <- table(unlist(all_feature$classifications_split))
  subset_term_counts <- table(unlist(subset_feature$classifications_split))

  total_term_counts['None'] <- sum(is.na(all_feature$classifications_split))
  subset_term_counts['None'] <- sum(is.na(subset_feature$classifications_split))

  # Perform enrichment analysis using Fisher's exact test
  enrichment_results <- sapply(names(subset_term_counts), function(term) {
    contingency_matrix <- matrix(c(
      subset_term_counts[[term]],
      sum(subset_term_counts) - subset_term_counts[[term]],
      total_term_counts[[term]],
      sum(total_term_counts) - total_term_counts[[term]]
    ), nrow = 2, byrow = TRUE)
    fisher.test(contingency_matrix, alternative = representation)$p.value
  })
  # Adjust p-values for multiple testing
  adjusted_pvalues <- p.adjust(enrichment_results, method = "fdr")
  # Create a results dataframe
  results <- data.frame(
    term_level = term_level,
    term = names(enrichment_results),
    subsetcount = as.numeric(subset_term_counts[names(enrichment_results)]),
    totalcount = as.numeric(total_term_counts[names(enrichment_results)]),
    foldenrichment = (as.numeric(subset_term_counts[names(enrichment_results)]) / length(subset_feature))/(as.numeric(total_term_counts[names(enrichment_results)]) / nrow(all_feature)),
    pval = enrichment_results,
    fdr = adjusted_pvalues
  )
  results <- results |> filter(.data$term != 'None')
  # Filter for significantly enriched terms
  if(pval == 'pval'){
    significant_terms <- results |>
      filter(.data$pval < pthr) |>
      arrange(.data$pval)
  } else if (pval == 'fdr'){
    significant_terms <- results |>
      filter(.data$fdr < pthr) |>
      arrange(.data$fdr)
  } else {
    stop("Invalid pval option. Please choose 'pval' or 'fdr'.")
  }
  if(sig==TRUE){
    return(significant_terms)
  }else{
    return(results)
  }
}

#' Generate a plot for enrichment analysis of Canopus-predicted terms
#'
#' This function generates a plot for enrichment analysis of Canopus-predicted terms,
#' showing fold enrichment, p-value, and subset count for each term level.
#'
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param feature_list A vector containing names of features to analyze
#' @param pthr The threshold for adjusted p-value to be considered significant (default: 0.05)
#' @param outdir The output file path for the enrichment plot
#' @param height The height of the output plot in inches (default: 5)
#' @param width The width of the output plot in inches (default: 5)
#' @param pval pvalue options-pval or fdr (default: 'pval')
#' @param save_output boolean, whether to save the output plot (default: TRUE)
#' @return A list containing the enrichment plot and the enrichment results
#' @export
#' @examplesIf FALSE
#' CanopusListEnrichmentPlot(
#'  mmo, feature_list = DAMs_up$control_vs_treatment1.up,
#'  pthr = 0.05, outdir = 'canopus_enrichment_plot.pdf',
#'  height = 5, width = 5
#' )
#'
CanopusListEnrichmentPlot <- function(mmo, feature_list, pthr = 0.05, outdir, height = 5, width = 5, pval = 'pval', save_output = TRUE){
  term_levels = c('NPC_class', 'NPC_superclass', 'NPC_pathway', 'ClassyFire_superclass', 'ClassyFire_class', 'ClassyFire_subclass', 'ClassyFire_level5', 'ClassyFire_most_specific')
  sig.canopus <- data.frame(term = character(),  term_level = character(),subsetcount = double(), totalcount = double(), foldenrichment = double(), pval = double(), fdr = double())
  for (term_level in term_levels){
    sig.canopus <- rbind(sig.canopus, CanopusLevelEnrichmentAnal(mmo, feature_list, pthr = pthr, sig = TRUE, term_level = term_level, representation = 'greater', pval = pval))
  }
  sig.canopus <- sig.canopus |> arrange(dplyr::desc(.data$foldenrichment))
  plot <- ggplot(sig.canopus, aes(x = .data$foldenrichment, y = reorder(.data$term, .data$foldenrichment), color = -log(.data$fdr), size = .data$subsetcount)) +
    geom_point() +
    scale_color_gradient(low = 'grey', high = 'red') +
    theme_classic()+
    facet_grid(term_level ~ ., scales = 'free_y', space = 'free', switch = 'y')+
    xlim(0,max(sig.canopus$foldenrichment+1))
    #facet_wrap(~term_level, ncol = 1, scales = 'free_y', strip.position = 'right', shrink = TRUE)
  plot

  if (save_output){
    ggsave(paste0(outdir, 'enrichment.pdf'), height = height, width = width)
    readr::write_csv(sig.canopus, paste0(outdir, 'enrichment.csv'))
  }
  return(list(plot = plot, df = sig.canopus))
}

#' Generate a plot for enrichment analysis of Canopus-predicted terms across multiple levels
#'
#' This function generates a plot for enrichment analysis of Canopus-predicted terms across multiple levels,
#' showing fold enrichment, p-value, and subset count for each term level.
#'
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param feature_list A vector containing names of features to analyze
#' @param pthr The threshold for adjusted p-value to be considered significant (default: 0.05)
#' @param outdir The output file path for the enrichment plot
#' @param height The height of the output plot in inches (default: 5)
#' @param width The width of the output plot in inches (default: 5)
#' @param topn The number of top terms to display in the plot (default: 5)
#' @param pval pvalue options-pval or fdr (default: 'pval')
#' @param save_output boolean, whether to save the output plot (default: TRUE)
#' @return A list containing the enrichment plot and the enrichment results
#' @export
#' @examplesIf FALSE
#' CanopusListEnrichmentPlot_2(
#'  mmo, feature_list = DAMs_up$control_vs_treatment1.up,
#'  pthr = 0.05, outdir = 'canopus_enrichment_plot_topn.pdf',
#'  height = 5, width = 5, topn = 5
#' )
CanopusListEnrichmentPlot_2 <- function(mmo, feature_list, pthr = 0.05, outdir, height = 5, width = 5, topn = 5, pval = 'pval', save_output = TRUE){
  term_levels = c('NPC_class', 'NPC_superclass', 'NPC_pathway', 'ClassyFire_superclass', 'ClassyFire_class', 'ClassyFire_subclass', 'ClassyFire_level5', 'ClassyFire_most_specific')
  sig.canopus <- data.frame(term = character(),  term_level = character(),subsetcount = double(), totalcount = double(), foldenrichment = double(), pval = double(), fdr = double())
  for (term_level in term_levels){
    sig.canopus <- rbind(sig.canopus, CanopusLevelEnrichmentAnal(mmo, feature_list, pthr = pthr, sig = TRUE, term_level = term_level, representation = 'greater', pval = pval))
  }
  sig.canopus$term <- paste(sig.canopus$term, ';', sig.canopus$term_level)
  sig.canopus <- sig.canopus |> dplyr::slice_max(order_by = -.data$pval, n = topn)
  sig.canopus <- sig.canopus |> dplyr::arrange(dplyr::desc(.data$foldenrichment))
  plot <- ggplot(sig.canopus, aes(x = .data$foldenrichment, y = reorder(.data$term, .data$foldenrichment), color = -log(.data$fdr), size = .data$subsetcount)) +
    geom_point() +
    scale_color_gradient(low = 'grey', high = 'red') +
    theme_classic()+
    xlim(0,max(sig.canopus$foldenrichment+1))+
    ylab('Chemical Class')
  plot
  if (save_output){
    ggsave(outdir, height = height, width = width)
    readr::write_csv(sig.canopus, paste0(outdir, 'enrichment.csv'))
  }
  return(list(plot = plot, df = sig.canopus))
}

#' Generate a plot for enrichment analysis of Canopus-predicted terms at a specific level using a list of vectors of features
#'
#' This function generates a plot for enrichment analysis of Canopus-predicted terms at a specific level,
#' showing fold enrichment, p-value, and subset count for each term.
#'
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param comp.list A list to analyze, where each element is a vector of feature names
#' @param term_level The level of term to use for enrichment analysis.
#'               Options are 'NPC_pathway', 'NPC_superclass', 'NPC_class',
#'              'ClassyFire_superclass', 'ClassyFire_class', 'ClassyFire_subclass',
#'             'ClassyFire_level5', or 'ClassyFire_most_specific' (default: 'NPC_pathway')
#' @param pthr The threshold for adjusted p-value to be considered significant (default: 0.1)
#' @param representation The representation type for enrichment analysis. Options are 'greater' for overrepresentation (default: 'greater')
#' @param outdir The output directory for saving the plot and the enrichment results (default: 'enrichment')
#' @param height The height of the output plot in inches (default: 5)
#' @param width The width of the output plot in inches (default: 5)
#' @param pval pvalue options-pval or fdr (default: 'pval')
#' @param save_output boolean, whether to save the output plot (default: TRUE)
#' @return A list containing the enrichment plot and the enrichment results
#' @export
#' @examplesIf FALSE
#' # Perform enrichment analysis for multiple comparisons using NPC_pathway level
#' comp.list <- list(
#'   comparison1 = DAMs_up$control_vs_treatment1.up,
#'   comparison2 = DAMs_up$control_vs_treatment2.up
#' )
#' CanopusLevelEnrichmentPlot(
#'  mmo, comp.list = comp.list, term_level = 'NPC_pathway',
#'  pthr = 0.1, representation = 'greater', outdir = 'enrichment_plot',
#'  height = 5, width = 5
#' )
CanopusLevelEnrichmentPlot <- function(mmo = mmo, comp.list, term_level = 'NPC_pathway',pthr = 0.1, representation = 'greater', outdir = 'enrichment', height = 5, width = 5, pval = 'pval', save_output = TRUE){
  df.EA <- data.frame()
  sig.terms <- c()
  for(list in names(comp.list)){
    # Calculate enrichment score for all terms
    res <- CanopusLevelEnrichmentAnal(mmo = mmo, list_test = comp.list[[list]],sig=FALSE, pthr = pthr, representation = representation, term_level = term_level, pval = pval)
    res <- res |> mutate(comp = list)
    df.EA <- dplyr::bind_rows(df.EA, res)
    # get terms that are at least once enriched in one comparison
    res.sig <- CanopusLevelEnrichmentAnal(mmo = mmo, list_test = comp.list[[list]],sig=TRUE, pthr = pthr, representation = representation, term_level = term_level, pval = pval)
    sig.terms <- append(sig.terms, res.sig$term)
  }
  sig.terms <- unique(sig.terms)
  df.EA.sig <- df.EA |> filter(.data$term %in% sig.terms)
  if (pval == 'pval'){
    df.EA.sig <- df.EA.sig |>
      mutate(label = cut(
        .data$pval,
        breaks = c(0,0.001, 0.01, 0.05, 0.1, 1),
        labels = c("***", "**", "*", ".", "")
      ))
    plot <- ggplot(data = df.EA.sig, aes(x = .data$comp, y = .data$term, label = .data$label))+
      geom_point(aes(size = .data$subsetcount, color = .data$pval))+
      geom_text()+
      scale_size_area(name = 'Count', max_size = 10)+
      scale_color_gradient2(low = 'red', high = 'grey', mid = 'grey', midpoint = 0.4)+
      theme_minimal()+
      theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.5))+
      xlab('Comparisons')+
      ylab('Chemical classes')
  } else if (pval == 'fdr'){
    df.EA.sig <- df.EA.sig |>
      mutate(label = cut(
        .data$fdr,
        breaks = c(0,0.001, 0.01, 0.05, 0.1, 1),
        labels = c("***", "**", "*", ".", "")
      ))
    plot <- ggplot(data = df.EA.sig, aes(x = .data$comp, y = .data$term, label = .data$label))+
      geom_point(aes(size = .data$subsetcount, color = .data$fdr))+
      geom_text()+
      scale_size_area(name = 'Count', max_size = 10)+
      scale_color_gradient2(low = 'red', high = 'grey', mid = 'grey', midpoint = 0.4)+
      theme_minimal()+
      theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.5))+
      xlab('Comparisons')+
      ylab('Chemical classes')
  }
  plot
  if (save_output){
    ggsave(paste0(outdir, '.pdf'), width = width, height = height)
    readr::write_csv(df.EA, paste0(outdir, '.csv'))
    readr::write_csv(df.EA.sig, paste0(outdir, '_sig.csv'))
  }
  return(list(plot = plot, df = df.EA))
}

#' Generate a plot for enrichment analysis of Canopus-predicted terms across all levels
#'
#' This function generates a plot for enrichment analysis of Canopus-predicted terms across all levels,
#' showing fold enrichment, p-value, and subset count for each term level.
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param comp.list A list to analyze, where each element is a vector of feature names
#' @param terms The terms to analyze. Options are 'all_terms', 'NPC', 'ClassyFire', or 'custom' (default: 'all_terms')
#' @param term_levels list of custom term levels to use
#' @param pthr The threshold for adjusted p-value to be considered significant (default: 0.1)
#' @param representation The representation type for enrichment analysis. Options are 'greater' for overrepresentation (default: 'greater')
#' @param outdir The output directory for saving the plot and the enrichment results (default: 'enrichment')
#' @param height The height of the output plot in inches (default: 10)
#' @param width The width of the output plot in inches (default: 8)
#' @param pval pvalue options-pval or fdr (default: 'pval')
#' @param save_output boolean, whether to save the output plot (default: TRUE)
#' @return A list of the plot and the enrichment results
#' @export
#' @examplesIf FALSE
#' comp.list <- list(
#'   comparison1 = DAMs_up$control_vs_treatment1.up,
#'   comparison2 = DAMs_up$control_vs_treatment2.up
#' )
#' CanopusAllLevelEnrichmentPlot(
#'  mmo, comp.list = comp.list, terms = 'all_terms',
#'  pthr = 0.1, representation = 'greater', outdir = 'enrichment_all_levels',
#'  height = 10, width = 8
#' )
#' CanopusAllLevelEnrichmentPlot(
#'  mmo, comp.list = comp.list, terms = 'NPC',
#'  pthr = 0.1, representation = 'greater', outdir = 'enrichment_NPC_levels',
#'  height = 10, width = 8
#' )
#' CanopusAllLevelEnrichmentPlot(
#'  mmo, comp.list = comp.list, terms = 'ClassyFire',
#'  pthr = 0.1, representation = 'greater', outdir = 'enrichment_ClassyFire_levels',
#'  height = 10, width = 8
#' )
CanopusAllLevelEnrichmentPlot <- function(mmo = mmo, comp.list, terms = 'all_terms', term_levels = NULL, pthr = 0.1, representation = 'greater', outdir = 'enrichment', height = 10, width = 8, pval = 'pval', save_output = TRUE){
  df.EA <- data.frame()
  sig.terms <- c()
  if(terms == 'all_terms'){
    term_levels = c('NPC_class', 'NPC_superclass', 'NPC_pathway', 'ClassyFire_superclass', 'ClassyFire_class', 'ClassyFire_subclass', 'ClassyFire_level5', 'ClassyFire_most_specific')
  } else if (terms == 'NPC'){
    term_levels = c('NPC_class', 'NPC_superclass', 'NPC_pathway')
  } else if (terms == 'ClassyFire'){
    term_levels = c('ClassyFire_superclass', 'ClassyFire_class', 'ClassyFire_subclass', 'ClassyFire_level5', 'ClassyFire_most_specific')
  } else if (terms == 'custom'){
    term_levels = term_levels
  }
  for(term_level in term_levels){
    for(list in names(comp.list)){
      # Calculate enrichment score for all terms
      res <- CanopusLevelEnrichmentAnal(mmo = mmo, list_test = comp.list[[list]],sig=FALSE, pthr = pthr, representation = representation, term_level = term_level, pval = pval)
      res <- res |> mutate(comp = list)
      df.EA <- dplyr::bind_rows(df.EA, res)
      # get terms that are at least once enriched in one comparison
      res.sig <- CanopusLevelEnrichmentAnal(mmo = mmo, list_test = comp.list[[list]],sig=TRUE, pthr = pthr, representation = representation, term_level = term_level, pval = pval)
      sig.terms <- append(sig.terms, res.sig$term)
    }
    sig.terms <- unique(sig.terms)
    df.EA.sig <- df.EA |> filter(.data$term %in% sig.terms)
    if (pval == 'pval'){
      df.EA.sig <- df.EA.sig |>
        mutate(label = cut(
          .data$pval,
          breaks = c(0,0.001, 0.01, 0.05, 0.1, 1),
          labels = c("***", "**", "*", ".", "")
        ))
      plot <- ggplot(data = df.EA.sig, aes(x = .data$comp, y = .data$term, label = .data$label))+
        geom_point(aes(size = .data$subsetcount, color = .data$pval))+
        geom_text()+
        scale_size_area(name = 'Count', max_size = 10)+
        scale_color_gradient2(low = 'red', high = 'grey', mid = 'grey', midpoint = 0.4)+
        theme_minimal()+
        theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.5))+
        xlab('Comparisons')+
        ylab('Chemical classes')+
        facet_grid(term_level ~ ., scales = 'free_y', space = 'free', switch = 'y')
    } else if (pval == 'fdr'){
      df.EA.sig <- df.EA.sig |>
        mutate(label = cut(
          .data$fdr,
          breaks = c(0,0.001, 0.01, 0.05, 0.1, 1),
          labels = c("***", "**", "*", ".", "")
        ))
      plot <- ggplot(data = df.EA.sig, aes(x = .data$comp, y = .data$term, label = .data$label))+
        geom_point(aes(size = .data$subsetcount, color = .data$fdr))+
        geom_text()+
        scale_size_area(name = 'Count', max_size = 10)+
        scale_color_gradient2(low = 'red', high = 'grey', mid = 'grey', midpoint = 0.4)+
        theme_minimal()+
        theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.5))+
        xlab('Comparisons')+
        ylab('Chemical classes')+
        facet_grid(term_level ~ ., scales = 'free_y', space = 'free', switch = 'y')
    }
  }
  plot
  if (save_output){
    ggsave(paste0(outdir, '.pdf'), width = width, height = height)
    readr::write_csv(df.EA, paste0(outdir, '.csv'))
    readr::write_csv(df.EA.sig, paste0(outdir, '_sig.csv'))
  }
  return(list(plot = plot, df = df.EA))
}


#' Metabolite Set Enrichment Analysis (MSEA)
#'
#' This function performs Metabolite Set Enrichment Analysis (MSEA) using the fgsea package.
#' It takes a ranked list of feature scores and tests for enrichment of metabolite sets based on Canopus-predicted terms.
#' The results are saved as a CSV file and a PDF plot.
#' @param mmo The mmo object with sirius annotation and normalized data
#' @param feature_name A vector of feature names corresponding to the feature scores
#' @param feature_score A vector of feature scores (e.g., log2 fold changes)
#' @param term_level The level of term to use for enrichment analysis.
#'               Options are 'NPC_pathway', 'NPC_superclass', 'NPC_class',
#'              'ClassyFire_superclass', 'ClassyFire_class', 'ClassyFire_subclass',
#'             'ClassyFire_level5', or 'ClassyFire_most_specific' (default: 'NPC_class')
#' @param pthr The threshold for adjusted p-value to be considered significant (default: 0.05)
#' @param outdir The directory to save the output files (default: 'MSEA')
#' @param width The width of the output plot in inches (default: 8)
#' @param height The height of the output plot in inches (default: 12)
#' @param sig A logical value indicating whether to return only significant terms (default: FALSE)
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @return A list of the plot and the enrichment results
#' @export
#' @examplesIf FALSE
#' # Perform MSEA using NPC_class level
#' MSEA(
#'  mmo, feature_name = rownames(DE_results), feature_score = DE_results$log2FoldChange,
#'  term_level = 'NPC_class', pthr = 0.05, outdir = 'MSEA_NPC_class',
#'  width = 8, height = 12, sig = FALSE
#' )
MSEA <- function(mmo, feature_name, feature_score, term_level = 'NPC_class', pthr = 0.05, outdir = 'MSEA', width = 8, height = 12, sig = FALSE, save_output = TRUE){
  # Create a named vector of feature scores
  .require_pkg("fgsea")
  ranked_list <- feature_score
  names(ranked_list) <- feature_name
  ranked_list <- sort(ranked_list, decreasing = TRUE)

  # Retrieve metabolite sets based on the specified term level
  if(term_level == 'NPC_class'){
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['NPC#class']])
  } else if (term_level == 'NPC_superclass'){
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['NPC#superclass']])
  } else if (term_level == 'NPC_pathway'){
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['NPC#pathway']])
  } else if (term_level == "ClassyFire_superclass") {
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['ClassyFire#superclass']])
  } else if (term_level == "ClassyFire_class") {
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['ClassyFire#class']])
  } else if (term_level == "ClassyFire_subclass") {
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['ClassyFire#subclass']])
  } else if (term_level == "ClassyFire_level5") {
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['ClassyFire#level 5']])
  } else if (term_level == "ClassyFire_most_specific") {
    metabolite_sets <- split(mmo$sirius_annot$feature, mmo$sirius_annot[['ClassyFire#most specific class']])
  } else {
    stop("Invalid term level. Please choose a valid term level.")
  }
  msea_res <- fgsea::fgsea(pathways = metabolite_sets,
                       stats    = ranked_list,
                       minSize  = 5,   # minimum number of features in a class
                       maxSize  = 1500,
                       nPermSimple = 10000)
  msea_res <- msea_res |> arrange(.data$padj)
  # readr::write_csv(msea_res, paste0(outdir,'_', term_level,'_results.csv'))
  if (sig) {
    msea_res <- msea_res |> filter(.data$padj < pthr)
  }
  plot <- ggplot(msea_res, aes(x = reorder(.data$pathway, .data$NES), y = .data$NES)) +
    geom_point(shape = 21, aes(color = .data$padj < 0.05, size = .data$size, fill = -log(.data$padj)), stroke = 1) +
    coord_flip() +
    geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
    scale_fill_gradient(low = "grey", high = "red") +
    scale_color_manual(values = c("TRUE" = 'black', "FALSE" = 'white')) +
    guides(shape = "none") +
    labs(x = "Metabolite Class", y = "Normalized Enrichment Score (NES)", title = "MSEA Results", color = "-log10(padj)", size = "Set Size") +
    theme_classic() +
    theme(legend.position = "top", axis.text.y = element_text(size = 6))
  plot
  if (save_output){
    ggsave(paste0(outdir,'_', term_level,'.pdf'), width = width, height = height)
    readr::write_csv(msea_res, paste0(outdir,'_', term_level,'_results.csv'))
  }
  return (list(plot = plot, df = msea_res))
}


#' FeaturePhenotypeCorrelation
#'
#' This function performs correlation analysis of a specific feature against a phenotype in the metadata.
#' It can use linear mixed models (LMM), simple linear regression (LM), or Pearson correlation.
#' The default regression line of the plot uses linear model
#'
#' @param mmo The mmo object with feature data and metadata
#' @param feature The name of the feature to analyze
#' @param phenotype The name of the phenotype  in the metadata
#' @param groups A vector of group names from the metadata containing phenotype data
#' @param model The type of regression model to use. Options are 'lmm' for linear mixed model, 'lm' for simple linear regression, or 'pearson' for Pearson correlation (default: 'lmm')
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'Z')
#' @param outdir The directory to save the output files
#' @param width The width of the output plot in inches (default: 6)
#' @param height The height of the output plot in inches (default: 6)
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @return A list of the plot and the raw data
#' @export

FeaturePhenotypeCorrelation <- function(mmo, feature, phenotype, groups, model = 'lm', normalization = 'Z', outdir = 'FeaturePhenotypeCorrelation', width = 6, height = 6, save_output = TRUE){
  .require_pkg("ggrepel")
  feature <- GetNormFeature(mmo, normalization)
  metadata <- mmo$metadata

  # Get phenotype phenotype from the metadata, get the feature value from the feature matrix, then combine
  phenotype.df <- data.frame(sample = metadata$sample, group = metadata$group, phenotype = metadata[,phenotype]) |> filter(.data$group %in% groups)
  feature_df <- data.frame(sample = colnames(feature[,-(1:2)]), feature_value = as.numeric(feature[feature$feature == feature, -(1:2)]))
  combined_df <- merge(phenotype.df, feature_df, by='sample')

  # Perform linear mixed model or simple linear regression
  if (model == 'lmm'){
    fit <- lme4::lmer(combined_df$phenotype ~ combined_df$feature_value + (1|combined_df$group))
    p_value <- summary(fit)$coefficients[2, 5]
  } else if (model == 'lm'){
    fit <- lm(combined_df$phenotype ~ combined_df$feature_value)
    p_value <- summary(fit)$coefficients[2, 4]
  } else if (model %in% c('pearson', 'spearman', 'kendall')){
    correlation <- cor.test(combined_df$phenotype, combined_df$feature_value, method = model)
    p_value <- correlation$p.value
  } else {
    stop("Invalid model type. Please use 'lmm', 'lm', 'pearson', 'spearman' or 'kendall'")
  }

  # Plot the fit using ggplot
  plot <-ggplot(combined_df, aes(x = .data$feature_value, y = .data$phenotype, color = .data$group)) +
    geom_point(size = 3) +
    geom_smooth(method = "lm", se = TRUE, color = "black") +
    ggrepel::geom_text_repel(aes(label = sample), size = 2.5, show.legend = FALSE) +
    theme_classic() +
    labs(title = paste("Regression of", feature, "against", phenotype, "phenotype"),
         x = "Feature Value",
         y = "phenotype") +
    theme(legend.position = "right") +
    annotate("text", x = Inf, y = Inf, label = paste("p-value:", signif(p_value, digits = 4)),
             hjust = 1.1, vjust = 1.1, size = 3, color = "black")
  plot
  if (save_output){
    ggsave(paste0(outdir,'_', feature,'_vs_', phenotype,'.pdf'), height = height, width = width)
    readr::write_csv(combined_df, paste0(outdir,'_', feature,'_vs_', phenotype,'_data.csv'))
  }
  return (list(plot = plot, df = combined_df))
}


#' Screen feature-phenotype correlation
#'
#' Use metadata-provided variables (any phenotypes or environmental variables) to screen feature-phenotype correlation
#' linear model, linear mixed model (using groups as random effect), or correlation (Pearson, Spearman, Kendall) are supported
#'
#' @param mmo The mmo object with feature data and metadata
#' @param phenotype The name of the phenotype in the metadata
#' @param groups A vector of group names from the metadata containing phenotype data
#' @param model The type of regression model to use. Options are 'lmm' for linear mixed model, 'lm' for simple linear regression, or 'pearson', 'spearman', 'kendall' for correlation (default: 'lm')
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'Z')
#' @return A list of the plot and the raw data
#' @export
ScreenFeaturePhenotypeCorrelation <- function(mmo, phenotype, groups, model = 'lm', normalization = 'None'){
  # Load feature and metadata
  feature <- GetNormFeature(mmo, normalization)
  metadata <- mmo$metadata
  # Generate df for analysis
  if (missing(groups)) {
    groups <- unique(metadata$group)
    message("'groups' is not provided, using all groups")
  }
  phenotype_df <- data.frame(sample = metadata$sample, group = metadata$group, phenotype = metadata[,phenotype]) |> filter(.data$group %in% groups)
  corr_res <- data.frame(feature = character(), coefficient = numeric(), p_value = numeric(), stringsAsFactors = FALSE)
  for (i in 1:nrow(feature)){
    feature_name <- feature$feature[i]
    feature_df <- data.frame(sample = colnames(feature[,-(1:2)]), feature_value = as.numeric(feature[i, -(1:2)]))
    combined_df <- merge(phenotype_df, feature_df, by='sample')
    if (model == 'lmm'){
      fit <- lme4::lmer(combined_df$phenotype ~ combined_df$feature_value + (1|combined_df$group))
      p_value <- summary(fit)$coefficients[2, 5]
      coefficient <- lme4::fixef(fit)[2]
    } else if (model == 'lm'){
      fit <- lm(combined_df$phenotype ~ combined_df$feature_value)
      coefficient <- summary(fit)$coefficients[2]
      p_value <- summary(fit)$coefficients[2, 4]
    } else if (model %in% c('pearson', 'spearman', 'kendall')){
      correlation <- cor.test(combined_df$phenotype, combined_df$feature_value, method = model)
      p_value <- correlation[[3]]
      coefficient <- correlation[[4]]
    } else {
      stop("Invalid model type. Please use 'lmm', 'lm', 'pearson', 'spearman' or 'kendall'")
    }
    corr_res <- rbind(corr_res, data.frame(
      feature = feature_name, coefficient = coefficient, p_value = p_value))
  }
  return (corr_res)
  print(paste0(normalization, '-normalized feature data screened using ', model))
}


#' GetPerformanceFeatureRegression
#'
#' This function performs linear regression analysis of all features against a phenotype performance in the metadata.
#' @param mmo The mmo object with feature data and metadata
#' @param phenotype The name of the phenotype performance in the metadata
#' @param groups A vector of group names from the metadata containing performance data
#' @param DAM.list A list of DAMs to tag features
#' @param comparisons A list of pairwise comparisons to add fold change columns
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @export
#' @return A data frame containing regression results for each feature, including effect size, p-value, and fold change columns for specified comparisons.
#'
GetPerformanceFeatureRegression <- function(mmo, phenotype, groups, DAM.list, comparisons, normalization = 'None'){
  feature <- GetNormFeature(mmo, normalization)
  metadata <- mmo$metadata

  # phenotype.sample <- metadata |> filter(group %in% groups) |> pull(sample)
  # phenotype.area <- feature |> dplyr::select(id, feature, all_of(phenotype.sample))

  performance.linreg <- data.frame(pval = double(), effect.size = double())
  phenotype.df <- data.frame(sample = metadata$sample, group = metadata$group, performance = metadata[,phenotype]) |> filter(.data$group %in% groups)

  regression_results <- data.frame(feature = character(), effect.size = numeric(), p_value = numeric(), is.Spec = logical(), stringsAsFactors = FALSE)
  for (i in 1:nrow(feature)) {
    feature_name <- feature$feature[i]
    feature_df <- data.frame(sample = colnames(feature[,-(1:2)]), feature_value = as.numeric(feature[i, -(1:2)]))
    combined_df <- merge(phenotype.df, feature_df, by='sample')

    fit <- lm(combined_df$performance ~ combined_df$feature_value)
    effect.size <- coef(fit)[2]
    p_value <- summary(fit)$coefficients[2, 4]
    tag <- "else"
    for (list_name in names(DAM.list)) {
      if (feature_name %in% DAM.list[[list_name]]) {
        tag <- list_name
      }
    }
    #is.Spec <- feature_name %in% target

    regression_results <- rbind(regression_results, data.frame(
      feature = feature_name, effect.size = effect.size, p_value = p_value, tag = tag
    ))
  }
  # Add FC columns to regression_results
  for (comparison in comparisons) {
    fc_column <- paste(comparison, "log2FC", sep = "_")
    regression_results[[fc_column]] <- mmo$pairwise[[fc_column]][match(regression_results$feature, mmo$pairwise$feature)]
  }
  return(regression_results)
}

#' GetPerformanceFeatureLMM
#'
#' This function performs linear mixed model analysis of all features against a phenotype performance in the metadata.
#'
#' @param mmo The mmo object with feature data and metadata
#' @param phenotype The name of the phenotype performance in the metadata
#' @param groups A vector of group names from the metadata containing performance data
#' @param DAM.list A list of DAMs to tag features
#' @param comparisons A list of pairwise comparisons to add fold change columns
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'Z')
#' @return A data frame containing regression results for each feature, including effect size, p-value, and fold change columns for specified comparisons.
#' @export
GetPerformanceFeatureLMM <- function(mmo, phenotype, groups, DAM.list, comparisons, normalization = 'Z'){
  feature <- GetNormFeature(mmo, normalization)
  # if (normalization == 'None'){
  #   feature <- mmo$feature_data
  # } else if (normalization == 'Log'){
  #   feature <- mmo$log
  # } else if (normalization == 'Meancentered'){
  #   feature <- mmo$meancentered
  # } else if (normalization == 'Z'){
  #   feature <- mmo$zscore
  # }
  metadata <- mmo$metadata

  # get phenotype performance data
  phenotype.df <- data.frame(sample = metadata$sample, group = metadata$group, performance = metadata[,phenotype]) |> filter(.data$group %in% groups)
  #create an empty dataframe to store regression results
  regression_results <- data.frame(feature = character(), effect.size = numeric(), p_value = numeric(), is.Spec = logical(), stringsAsFactors = FALSE)
  # iterate regression analysis
  for (i in 1:nrow(feature)) {
    # for each feature, generate phenotype performance X feature value data
    feature_name <- feature$feature[i]
    feature_df <- data.frame(sample = colnames(feature[,-(1:2)]), feature_value = as.numeric(feature[i, -(1:2)]))
    combined_df <- merge(phenotype.df, feature_df, by='sample')

    # linear mixed model
    lmm_fit <- lme4::lmer(performance ~ feature_value + (1|group), data = combined_df)
    fixed_effects <- lme4::fixef(lmm_fit)
    effect.size <- fixed_effects[2]
    p_value <- summary(lmm_fit)$coefficients[2, 5]

    #tag using DAM.list
    tag <- "else"
    for (list_name in names(DAM.list)) {
      if (feature_name %in% DAM.list[[list_name]]) {
        tag <- list_name
      }
    }

    regression_results <- rbind(regression_results, data.frame(
      feature = feature_name, effect.size = effect.size, p_value = p_value, tag = tag
    ))
  }
  # Add FC columns to regression_results
  for (comparison in comparisons) {
    fc_column <- paste(comparison, "log2FC", sep = "_")
    regression_results[[fc_column]] <- mmo$pairwise[[fc_column]][match(regression_results$feature, mmo$pairwise$feature)]
  }
  return(regression_results)
}

#' GetPerformanceFeatureCorrelation
#'
#'
#' This function calculates the Pearson correlation between each feature and a specified phenotype performance in the metadata.
#' @param mmo The mmo object with feature data and metadata
#' @param phenotype The name of the phenotype performance in the metadata
#' @param groups A vector of group names from the metadata containing performance data
#' @param DAM.list A list of DAMs to tag features
#' @param comparisons A list of pairwise comparisons to add fold change columns
#' @param cor_method The correlation method to use. Options are 'pearson', 'spearman', or 'kendall' (default: 'pearson')
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @return A data frame containing correlation results for each feature, including effect size (correlation coefficient), p-value, and fold change columns for specified comparisons.
#' @export
GetPerformanceFeatureCorrelation <- function(mmo, phenotype, groups, DAM.list, comparisons, cor_method = 'pearson', normalization = 'None'){
  feature <- GetNormFeature(mmo, normalization)
  metadata <- mmo$metadata

  # phenotype.sample <- metadata |> filter(group %in% groups) |> pull(sample)
  # phenotype.area <- feature |> dplyr::select(id, feature, all_of(phenotype.sample))

  performance.linreg <- data.frame(pval = double(), effect.size = double())
  phenotype.df <- data.frame(sample = metadata$sample, group = metadata$group, performance = metadata[,phenotype]) |> filter(.data$group %in% groups)

  regression_results <- data.frame(feature = character(), effect.size = numeric(), p_value = numeric(), is.Spec = logical(), stringsAsFactors = FALSE)
  for (i in 1:nrow(feature)) {
    feature_name <- feature$feature[i]
    feature_df <- data.frame(sample = colnames(feature[,-(1:2)]), feature_value = as.numeric(feature[i, -(1:2)]))
    combined_df <- merge(phenotype.df, feature_df, by='sample')
    cor <- cor.test(combined_df$performance, combined_df$feature_value, method = cor_method)
    pval <- cor[[3]]
    cor <- cor[[4]]
    tag <- "else"
    for (list_name in names(DAM.list)) {
      if (feature_name %in% DAM.list[[list_name]]) {
        tag <- list_name
      }
    }
    #is.Spec <- feature_name %in% target

    regression_results <- rbind(regression_results, data.frame(
      feature = feature_name, effect.size = cor, p_value = pval, tag = tag
    ))
  }
  # Add FC columns to regression_results
  for (comparison in comparisons) {
    fc_column <- paste(comparison, "log2FC", sep = "_")
    regression_results[[fc_column]] <- mmo$pairwise[[fc_column]][match(regression_results$feature, mmo$pairwise$feature)]
  }
  return(regression_results)
}


#' PlotFoldchangeResistanceRegression
#'
#' This function plots the regression results of a feature against a fold change in resistance, including
#' regression line, p-value, and R-squared value.
#'
#' @param performance_regression The regression results data frame containing effect size, fold change, and tag. The output from GetPerformanceFeatureRegression, GetPerformanceFeatureLMM, or GetPerformanceFeatureCorrelation.
#' @param fold_change The name of the fold change column in the performance_regression dataframe
#' @param color A vector of colors for the points in the plot
#' @param outdir The output file path for the regression plot
#' @param width The width of the output plot in inches (default: 6)
#' @param height The height of the output plot in inches (default: 6)
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @return A list containing the regression plot and the performance regression data frame
#' @export
PlotFoldchangeResistanceRegression <- function(performance_regression, fold_change, color, outdir, width = 6, height = 6, save_output = TRUE){
  ind_fit <- lm(data = performance_regression, formula = as.formula(paste("-effect.size ~", fold_change)))
  summary_fit <- summary(ind_fit)
  p_value <- summary_fit$coefficients[2, 4]
  r_squared <- summary_fit$r.squared

  plot <- ggplot(performance_regression, aes(x = !!rlang::sym(fold_change), y = -.data$effect.size)) +
    geom_point(size = 0.5, aes(color = .data$tag)) +
    geom_smooth(method = "lm", se = TRUE, color = "black", level = 0.95) +
    xlab(fold_change) +
    ylab('-effect.size') +
    scale_color_manual(values = color) +
    theme_classic() +
    annotate("text", x = Inf, y = Inf, label = paste("p-value:", round(p_value, 500), "\nR-squared:", round(r_squared, 4)),
            hjust = 1.1, vjust = 1.1, size = 3, color = "black")+
    geom_hline(yintercept = 0, linetype = "dashed", color = "black")
  plot
  if (save_output){
    ggsave(paste0(outdir, ".png"), plot, height = height, width = width)
    readr::write_csv(performance_regression, file = paste0(outdir, ".csv"))
  }
  return(list(plot = plot, df = performance_regression))
}

#' PlotFoldchangeResistanceRegression_t
#'
#' This function plots the regression results of a feature against a fold change in resistance, including
#' regression line, p-value, and R-squared value. Transposed version of PlotFoldchangeResistanceRegression.
#'
#' @param performance_regression The regression results data frame containing effect size, fold change, and tag. The output from GetPerformanceFeatureRegression, GetPerformanceFeatureLMM, or GetPerformanceFeatureCorrelation.
#' @param fold_change The name of the fold change column in the performance_regression dataframe
#' @param color A vector of colors for the points in the plot
#' @param output_dir The output file path for the regression plot
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @param width The width of the output plot in inches (default: 6)
#' @param height The height of the output plot in inches (default: 6)
#' @return A list containing the regression plot and the performance regression data frame
#' @export
PlotFoldchangeResistanceRegression_t <- function(performance_regression, fold_change, color, output_dir, save_output = TRUE, width = 6, height = 6){
  ind_fit <- lm(data = performance_regression, formula = as.formula(paste(fold_change, "~ -effect.size")))
  summary_fit <- summary(ind_fit)
  p_value <- summary_fit$coefficients[4]
  r_squared <- summary_fit$r.squared

  plot <- ggplot(performance_regression, aes(x = -.data$effect.size, y = !!rlang::sym(fold_change))) +
    geom_point(size = 0.5, aes(color = .data$tag)) +
    geom_smooth(method = "lm", se = TRUE, color = "black", level = 0.95) +
    xlab('-effect.size') +
    ylab(fold_change) +
    scale_color_manual(values = color) +
    theme_classic() +
    annotate("text", x = Inf, y = Inf, label = paste("p-value:", round(p_value, 500), "\nR-squared:", round(r_squared, 4)),
            hjust = 1.1, vjust = 1.1, size = 3, color = "black")+
    geom_hline(yintercept = 0, linetype = "dashed", color = "black")+
    geom_vline(xintercept = 0, linetype = "dashed", color = "black")
  if (save_output){
    ggsave(paste0(output_dir, ".png"), plot, height = height, width = width)
    readr::write_csv(performance_regression, file = paste0(output_dir, ".csv"))
  }
  return(list(plot = plot, df = performance_regression))
}

#' PlotFoldchangeResistanceQuad
#'
#' This function plots the fold change resistance in a quadrant plot, categorizing points into quadrants based on their effect size and fold change.
#' It also performs a binomial test to assess the distribution of points across quadrants.
#' @param performance_regression The regression results data frame containing effect size, fold change, and tag. The output from GetPerformanceFeatureRegression, GetPerformanceFeatureLMM, or GetPerformanceFeatureCorrelation.
#' @param fold_change The name of the fold change column in the performance_regression dataframe
#' @param color A vector of colors for the points in the plot
#' @param output_dir The output file path for the quadrant plot
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @param width The width of the output plot in inches (default: 6)
#' @param height The height of the output plot in inches (default: 6)
#' @return A list containing the quadrant plot and the performance regression data frame
#' @export
PlotFoldchangeResistanceQuad <- function(performance_regression, fold_change, color, output_dir, save_output = TRUE, width = 6, height = 6){
  performance_regression <- performance_regression |>
  mutate(
    quadrant = dplyr::case_when(
      -effect.size > 0 & !!rlang::sym(fold_change) > 0 ~ "Q1",
      -effect.size < 0 & !!rlang::sym(fold_change) < 0 ~ "Q3",
      -effect.size < 0 & !!rlang::sym(fold_change) > 0 ~ "Q2",
      -effect.size > 0 & !!rlang::sym(fold_change) < 0 ~ "Q4",
      TRUE ~ "Edge"             # For points on axes
    )
  )
  q_counts <- table(performance_regression$quadrant)
  q13 <- sum(q_counts[c("Q1", "Q3")], na.rm = TRUE)
  q24 <- sum(q_counts[c("Q2", "Q4")], na.rm = TRUE)
  binom_test <- binom.test(q13, q13+q24, p = 0.5, alternative = "two.sided")

  plot <- ggplot(performance_regression, aes(x = -.data$effect.size, y = !!sym(fold_change))) +
    geom_point(size = 0.5, aes(color = .data$tag)) +
    xlab('-effect.size') +
    ylab(fold_change) +
    scale_color_manual(values = color) +
    theme_classic() +
    annotate("text", x = Inf, y = Inf, label = paste("p-value:", round(binom_test[[3]], 500)),
            hjust = 1.1, vjust = 1.1, size = 3, color = "black")+
    geom_hline(yintercept = 0, linetype = "dashed", color = "black")+
    geom_vline(xintercept = 0, linetype = "dashed", color = "black")
  plot
  if (save_output){
    ggsave(paste0(output_dir, ".png"), plot, height = height, width = width)
    readr::write_csv(performance_regression, file = paste0(output_dir, ".csv"))
  }
  return(list(plot = plot, df = performance_regression))
}
################### Singlevariate analyses ###################

#' Generate barplots for each feature and perform ANOVA
#'
#' This function generates bar plots for a specified feature across different groups in the metadata, performing ANOVA and Tukey's HSD test for post-hoc analysis.
#'
#' @param mmo The mmo object containing metadata and feature data
#' @param ID_list A list of feature IDs to analyze. Use FeatureToID() to convert feature names to IDs.
#' @param outdir The output directory to save the bar plots and ANOVA results
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param filter_group A boolean indicating whether to filter the feature values by a specific group list (default: FALSE)
#' @param group_list A list of groups to filter the feature values by, if filter_group is TRUE (default: NULL)
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @param width The width of the output plot in inches (default: 6)
#' @param height The height of the output plot in inches (default: 6)
#' @export
#' @return A list containing the bar plot and the ANOVA results
#' @examplesIf FALSE
#' AnovaBarPlot(mmo, ID_list = c("ID_1", "ID_2"), outdir = "output_directory", normalization = 'Z')
#' AnovaBarPlot(
#'  mmo, ID_list = c("ID_1", "ID_2"), outdir = "output_directory", normalization = 'Z',
#'  filter_group = TRUE, group_list = c("Group1", "Group2")
#' )
AnovaBarPlot <- function(mmo, ID_list, outdir, normalization = 'None', filter_group = FALSE, group_list = NULL, save_output = TRUE, width = 6, height = 6) {
  .require_pkg("ggbeeswarm")
  # Extract metadata and feature data
  metadata <- mmo$metadata
  feature_data <- GetNormFeature(mmo, normalization)

  # Iterate through each feature ID
  for (target_id in ID_list) {
    # Extract feature values and merge with metadata
    feature_values <- feature_data |>
      filter(.data$id == target_id) |>
      dplyr::select(-.data$id, -.data$feature) |>
      t() |>
      as.data.frame()
    colnames(feature_values) <- "value"
    feature_values$sample <- rownames(feature_values)
    feature_values <- merge(feature_values, metadata, by = "sample")
    if (filter_group == TRUE){
      feature_values <- feature_values |> filter(.data$group %in% group_list)
    }
    # Perform ANOVA
    anova <- anova_tukey_dunnett(feature_values, 'value ~ group')



    # Generate bar plot
    plot <- ggplot(feature_values, aes(x = .data$group, y = .data$value, fill = .data$group)) +
      geom_bar(stat = "summary", fun = "mean", position = "dodge") +
      geom_errorbar(stat = "summary", fun.data = "mean_se", position = position_dodge(width = 0.9), width = 0.2) +
      ggbeeswarm::geom_beeswarm() +
      theme_classic() +
      labs(title = paste("Feature:", target_id), x = "Group", y = "Value") +
      theme(legend.position = "none", axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
    plot
    if (save_output){
      ggsave(file.path(outdir, paste0(target_id, "_barplot.pdf")), plot = plot, width = width, height = height)
      write_anova(anova, outdir = paste0(outdir,'/', target_id, '_anova.csv'), way = 'oneway')
    }
    return(list(plot = plot, anova = anova))
  }
}

#' ExportFeaturesToCSV
#'
#' This function exports selected features, their annotations, and pairwise comparisons to a CSV file.
#'
#' @param mmo The mmo object containing feature data, annotations, and pairwise comparisons
#' @param feature_list A list of feature names to filter and export
#' @param normalization The normalization method to use for feature data.
#'        Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param output_dir The output directory to save the CSV file
#' @export
#' @examplesIf FALSE
#' ExportFeaturesToCSV(mmo,
#'                     feature_list = Glucosinolates,
#'                      normalization = 'Z',
#'                      output_dir = 'output.csv')
#' ExportFeaturesToCSV(mmo, feature_list = DAMs_up$control_vs_treatment1.up,
#'                          normalization = 'None',
#'                           output_dir = 'output.csv')
#'
ExportFeaturesToCSV <- function(mmo, feature_list, normalization = 'None', output_dir){
  feature <- GetNormFeature(mmo, normalization = normalization) # Get normalized feature data
  # Filter the feature data, annotation, and DA analysis for the list provided
  selected_feature <- feature |> filter(feature %in% feature_list)
  selected_pairwise <- mmo$pairwise |> filter(feature %in% feature_list)
  # Merge all
  merged_df <- merge(mmo$sirius_annot, selected_feature, by = 'feature')
  merged_df <- merge(merged_df, selected_pairwise, by = 'feature')

  readr::write_csv(merged_df, output_dir)
}


#' GetRichness
#'
#' This function calculates the richness of features for each sample in the mmo object.
#' Richness is defined as the number of non-missing features observed in each sample.
#' @param mmo The mmo object containing feature data and metadata
#' @param filter_feature A boolean indicating whether to filter features based on a provided list (default: FALSE)
#' @param feature_list A list of features to include in the richness calculation if filter_feature is TRUE (default: NULL)
#' @return A data frame containing the richness for each sample, with columns for sample, richness, and group.
#' @export
GetRichness <- function(mmo, filter_feature = FALSE, feature_list = NULL) {
  feature_data <- mmo$feature_data
  if (filter_feature) {
    feature_data <- feature_data |> filter(.data$feature %in% feature_list)
  }
  richness <- apply(feature_data[, -(1:2)], 2, function(x) sum(!is.na(x)))

  metadata <- mmo$metadata
  groups <- c()
  for (col in colnames(feature_data)[-c(1, 2)]) {
    groups <- append(groups, metadata[metadata$sample == col, ]$group)
  }

  richness_df <- data.frame(sample = colnames(feature_data)[-c(1, 2)], richness = richness, group = groups)
  return(richness_df)
}

#' CalculateCumulativeRichness
#'
#' This function calculates the cumulative richness of features across groups in the metadata.
#' Cumulative richness is defined as the total number of unique features observed as groups are added sequentially.
#' @param mmo The mmo object containing feature data and metadata
#' @param groups A vector specifying the order of groups to consider for cumulative richness calculation
#' @return A data frame containing the cumulative richness for each group in the specified order, with columns for group and cumulative richness.
#' @export
#' @examplesIf FALSE
#' groups <- c("Control", "Treatment1", "Treatment2")
#' cumulative_richness <- CalculateCumulativeRichness(mmo, groups)
CalculateCumulativeRichness <- function(mmo, groups) {
  feature_data <- mmo$feature_data
  metadata <- mmo$metadata
  cumulative_richness <- numeric(length(groups))
  selected_features <- rep(FALSE, nrow(feature_data))
  for (i in seq_along(groups)) {
    selected_groups <- groups[1:i]
    selected_samples <- metadata |> filter(.data$group %in% selected_groups) |> pull(.data$sample)
    selected_data <- feature_data |> dplyr::select(all_of(selected_samples))
    selected_features <- selected_features | (rowSums(!is.na(selected_data)) > 0)
    cumulative_richness[i] <- sum(selected_features)
  }
  data.frame(group = groups, cumulative_richness = cumulative_richness)
}

#' BootstrapCumulativeRichness
#'
#' This function bootstraps the cumulative richness of features across groups in the metadata by randomizing the order of groups.
#' It performs multiple bootstrap iterations to estimate the mean and confidence intervals of cumulative richness at each step.
#' @param mmo The mmo object containing feature data and metadata
#' @param groups A vector of group names from the metadata to consider for cumulative richness calculation
#' @param n_boot The number of bootstrap iterations to perform (default: 1000)
#' @param ci The confidence interval width (e.g., 0.95 for 95% CI) (default: 0.95)
#' @return A data frame containing the mean cumulative richness and confidence intervals for each group index, with columns for group index, mean, lower CI, and upper CI.
#' @export
#' @examplesIf FALSE
#' groups <- c("Control", "Treatment1", "Treatment2")
#' bootstrapped_richness <- BootstrapCumulativeRichness(mmo, groups, n_boot = 1000, ci = 0.95)
BootstrapCumulativeRichness <- function(mmo, groups, n_boot = 1000, ci = 0.95) {
  # Bootstraps cumulative richness by randomizing group order within a direction
  # ci: confidence interval width (e.g., 0.5 for 25%-75%)
  lower_q <- (1 - ci) / 2
  upper_q <- 1 - lower_q
  n_groups <- length(groups)
  boot_mat <- matrix(NA, nrow = n_boot, ncol = n_groups)
  for (i in seq_len(n_boot)) {
    rand_order <- sample(groups)
    boot_mat[i, ] <- CalculateCumulativeRichness(mmo, rand_order)$cumulative_richness
  }
  # Each row is a bootstrap, each column is the cumulative richness after adding that many groups
  boot_df <- data.frame(
    group_index = rep(seq_len(n_groups), times = n_boot),
    bootstrap = rep(seq_len(n_boot), each = n_groups),
    richness = as.vector(t(boot_mat))
  )
  boot_summary <- boot_df |>
    dplyr::group_by(.data$group_index) |>
    dplyr::summarise(
      mean = mean(.data$richness),
      lower = stats::quantile(.data$richness, lower_q),
      upper = stats::quantile(.data$richness, upper_q)
    ) |>
    dplyr::ungroup()
  as.data.frame(boot_summary)
}

#' CalculateNullCumulativeRichness
#'
#' This function calculates the null model of cumulative richness by randomizing samples regardless of group.
#' It performs multiple bootstrap iterations to estimate the mean and confidence intervals of cumulative richness at each step.
#' @param mmo The mmo object containing feature data and metadata
#' @param n_boot The number of bootstrap iterations to perform (default: 1000)
#' @param n_groups The number of groups to simulate for cumulative richness calculation
#' @param ci The confidence interval width (e.g., 0.95 for 95% CI) (default: 0.95)
#' @return A data frame containing the mean cumulative richness and confidence intervals for each group index, with columns for group index, mean, lower CI, and upper CI.
#' @export
#' @examplesIf FALSE
#' null_richness <- CalculateNullCumulativeRichness(mmo, n_boot = 1000, n_groups = 5, ci = 0.95)
CalculateNullCumulativeRichness <- function(mmo, n_boot = 1000, n_groups, ci = 0.95) {
  # Null model: randomize samples regardless of group, then add samples one by one
  feature_data <- mmo$feature_data
  metadata <- mmo$metadata
  all_samples <- metadata$sample
  n_features <- nrow(feature_data)
  samples_per_group <- ceiling(length(all_samples) / n_groups)
  boot_mat <- matrix(NA, nrow = n_boot, ncol = n_groups)
  lower_q <- (1 - ci) / 2
  upper_q <- 1 - lower_q
  for (i in seq_len(n_boot)) {
    rand_samples <- sample(all_samples)
    selected_features <- rep(FALSE, n_features)
    for (j in seq_len(n_groups)) {
      end_idx <- min(j * samples_per_group, length(rand_samples))
      selected_data <- feature_data |> dplyr::select(all_of(rand_samples[1:end_idx]))
      selected_features <- selected_features | (rowSums(!is.na(selected_data)) > 0)
      boot_mat[i, j] <- sum(selected_features)
    }
  }
  boot_df <- data.frame(
    group_index = rep(seq_len(n_groups), times = n_boot),
    bootstrap = rep(seq_len(n_boot), each = n_groups),
    richness = as.vector(t(boot_mat))
  )
  boot_summary <- boot_df |>
    dplyr::group_by(.data$group_index) |>
    dplyr::summarise(
      mean = mean(.data$richness),
      lower = stats::quantile(.data$richness, lower_q),
      upper = stats::quantile(.data$richness, upper_q)
    ) |>
    dplyr::ungroup()
  as.data.frame(boot_summary)
}

#' CalcNormalizedAUC
#'
#' This function calculates the normalized area under the curve (AUC) for a cumulative richness curve.
#' The normalized AUC is computed by dividing the AUC by the maximum possible area, which is the product of the maximum group index and maximum cumulative richness.
#' @param curve A data frame containing the cumulative richness curve with columns for group index and cumulative richness
#' @return The normalized AUC value
#' @export
#' @examplesIf FALSE
#' curve <- CalculateCumulativeRichness(mmo, group =c("Control", "Treatment1", "Treatment2"))
#' norm_auc <- CalcNormalizedAUC(curve)
CalcNormalizedAUC <- function(curve) {
  curve$group_index <- seq_len(nrow(curve))
  x <- curve$group_index
  y <- curve$cumulative_richness
  auc <- sum(diff(x) * (utils::head(y, -1) + utils::tail(y, -1)) / 2)
  norm_auc <- auc / (max(x) * max(y))
  norm_auc
}

#' BootCumulRichnessAUC
#'
#' This function bootstraps the normalized area under the curve (AUC) for cumulative richness by randomizing the order of groups.
#' It performs multiple bootstrap iterations to estimate the distribution of normalized AUC values.
#' @param mmo The mmo object containing feature data and metadata
#' @param groups A vector of group names from the metadata to consider for cumulative richness calculation
#' @param n_boot The number of bootstrap iterations to perform (default: 500)
#' @return A numeric vector containing the normalized AUC values from each bootstrap iteration
#' @export
#' @examplesIf FALSE
#' groups <- c("Control", "Treatment1", "Treatment2")
#' bootstrapped_aucs <- BootCumulRichnessAUC(mmo, groups, n_boot = 500)
BootCumulRichnessAUC <- function(mmo, groups, n_boot = 500) {
  aucs <- numeric(n_boot)
  for (i in seq_len(n_boot)) {
    rand_order <- sample(groups)
    curve <- CalculateCumulativeRichness(mmo, rand_order)
    aucs[i] <- CalcNormalizedAUC(curve)
  }
  aucs
}

#' GetFunctionalHillNumber
#'
#' This function calculates the functional Hill number for a given mmo object, normalization method, and distance metric.
#' See https://nph.onlinelibrary.wiley.com/doi/full/10.1111/nph.18685 for details of the functional Hill number calculation.
#'
#' @param mmo The mmo object containing feature data and metadata
#' @param normalization The normalization method to use for feature data.
#'        Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param q The order of the Hill number to calculate (default: 1).
#'        Larger q values give more weight to evenness portion of the hill number over richness.
#' @param distance The distance metric to use for calculating dissimilarity.
#'        Options are 'dreams', 'm2ds', or 'cosine' (default: 'dreams')
#' @param filter_feature A boolean indicating whether to filter the feature data by a specific list (default: FALSE)
#' @param feature_list A list of feature names to filter the feature data by, if filter_feature is TRUE (default: NULL)
#' @return A data frame containing the functional Hill number for each group in the metadata, with columns for group and hill number.
#' @export
#' @examplesIf FALSE
#' hill_number <- GetFunctionalHillNumber(mmo,
#'                                        normalization = 'Z',
#'                                        q = 1, distance = 'dreams',
#'                                        filter_feature = FALSE)
#' hill_number <- GetFunctionalHillNumber(mmo, normalization = 'Z',
#'                                        q = 3, distance = 'dreams',
#'                                        filter_feature = TRUE,
#'                                        feature_list = Glucosinolates)
#
GetFunctionalHillNumber <- function(mmo, normalization = 'None',q = 1, distance = 'dreams', filter_feature = FALSE, feature_list = NULL){
  feature <- GetNormFeature(mmo, normalization = normalization)
  metadata <- mmo$metadata
  distance_matrix <- GetDistanceMat(mmo, distance = distance)
  # Scale the  distance matrix to be between 0 and 1

  if (filter_feature == TRUE){
    id_list <- FeatureToID(mmo, feature_list)
    id_list <- rownames(distance_matrix)[rownames(distance_matrix) %in% id_list]
    distance_matrix <- distance_matrix[id_list, id_list]
  }
  scaled_dissimilarity <- distance_matrix / max(distance_matrix)
  # Calculate the relative proportions of each feature and reorder them to match the order of the distance matrix
  q.feature <- feature |> filter(.data$id %in% colnames(scaled_dissimilarity))
  relative_proportions <- apply(q.feature[, -(1:2)], 2, function(x) x / sum(x))
  rownames(relative_proportions) <- q.feature$id
  relative_proportions <- relative_proportions[rownames(scaled_dissimilarity), ]
  scaled_dissimilarity <- as.matrix(scaled_dissimilarity)
  raoQ <- colSums(relative_proportions * (scaled_dissimilarity %*% relative_proportions))
  # Calculate Hill
  functional_hill_number <- c()
  if (q == 1){
    mask <- relative_proportions > 0
    Plog <- ifelse(mask, relative_proportions/raoQ * log(relative_proportions/raoQ), 0)
    DP <- scaled_dissimilarity %*% relative_proportions
    vals <- 2 * colSums(Plog * DP)
    functional_hill_number <- exp(-vals)
  } else {
    Pq <- (relative_proportions/raoQ)^q
    DPq <- scaled_dissimilarity %*% Pq
    vals <- colSums(Pq*DPq)
    functional_hill_number <- vals^(1/(1-q))
  }
  names(functional_hill_number) <- colnames(relative_proportions)
  # Get the group information
  groups <- c()
  for (col in colnames(feature)[-c(1, 2)]) {
    groups <- append(groups, metadata[metadata$sample == col, ]$group)
  }

  hill_df <- data.frame(group = groups, hill_number = functional_hill_number)
  return(hill_df)
}

#' GetHillNumbers
#'
#' This function calculates the Hill numbers for a given mmo object, normalization method, and order of the Hill number without considering feature dissimilarity.
#'
#'
#' @param mmo The mmo object containing feature data and metadata
#' @param normalization The normalization method to use for feature data.
#'        Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param q The order of the Hill number to calculate (default: 0)
#' @param filter_feature A boolean indicating whether to filter the feature data by a specific list (default: FALSE)
#' @param feature_list A list of feature names to filter the feature data by, if filter_feature is TRUE (default: NULL)
#' @return A data frame containing the Hill number for each group in the metadata, with columns for group and hill number.
#' @export
#' @examplesIf FALSE
#' hill_number <- GetHillNumbers(mmo, normalization = 'Z',
#'                 q = 1, filter_feature = FALSE)
#' hill_number <- GetHillNumbers(mmo, normalization = 'Z',
#'                 q = 2, filter_feature = TRUE,
#'                  feature_list = Glucosinolates)
GetHillNumbers <- function(mmo, normalization = 'None', q = 0, filter_feature = FALSE, feature_list = NULL) {
  feature <- GetNormFeature(mmo, normalization = normalization)
  if (filter_feature == TRUE) {
    feature <- feature |> filter(feature %in% feature_list)
  }
  metadata <- mmo$metadata

  hill_numbers <- apply(feature[, -(1:2)], 2, function(x) {
    p <- x / sum(x)
    if (q == 0) {
      return(length(p))
    } else if (q == 1) {
      return(exp(-sum(p * log(p))))
    } else {
      return((sum(p^q))^(1 / (1 - q)))
    }
  })

  groups <- c()
  for (col in colnames(feature)[-c(1, 2)]) {
    groups <- append(groups, metadata[metadata$sample == col, ]$group)
  }

  hill_df <- data.frame(group = groups, hill_number = hill_numbers)


  return(hill_df)
}

#' GetAlphaDiversity
#'
#' This function calculates the alpha diversity for a given mmo object, order of the Hill number, normalization method, mode (weighted or unweighted), distance metric, and optional feature filtering.
#' Unweighted mode uses Hill numbers without considering feature dissimilarity, while weighted mode uses functional Hill numbers that account for feature dissimilarity.
#'
#' @param mmo The mmo object containing feature data and metadata
#' @param q The order of the Hill number to calculate (default: 1)
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param mode The mode of diversity calculation. Options are 'weighted' or 'unweighted' for chemical distance(default: 'weighted')
#' @param distance The distance metric to use for calculating dissimilarity. Options are 'dreams', 'm2ds', or 'cosine' (default: 'dreams')
#' @param filter_feature A boolean indicating whether to filter the feature data by a specific list (default: FALSE)
#' @param feature_list A list of feature names to filter the feature data by, if filter_feature is TRUE (default: NULL)
#' @return A data frame containing the alpha diversity for each group in the metadata, with columns for group and alpha diversity value.
#' @export
#' @examplesIf FALSE
#' alpha_diversity <- GetAlphaDiversity(mmo, q = 1, normalization = 'None',
#'  mode = 'weighted', distance = 'dreams', filter_feature = FALSE)
#' alpha_diversity <- GetAlphaDiversity(mmo, q = 2, normalization = 'Z',
#'  mode = 'unweighted', filter_feature = TRUE, feature_list = Glucosinolates)
GetAlphaDiversity <- function(mmo, q = 1, normalization = 'None', mode = 'weighted', distance = 'dreams', filter_feature = FALSE, feature_list = NULL){
  if (mode == 'weighted'){
    GetFunctionalHillNumber(mmo, normalization = normalization, q = q, distance = distance, filter_feature = filter_feature, feature_list = feature_list)
  } else if (mode == 'unweighted'){
    GetHillNumbers(mmo, normalization = normalization, q = q, filter_feature = filter_feature, feature_list = feature_list)
  } else{
    print('mode should be weighted or unweighted')
  }
}

#' GetSpecializationIndex
#'
#' This function calculates the specialization index for a given mmo object, normalization method, and optional filtering by groups and features.
#'
#' @param mmo The mmo object containing feature data and metadata
#' @param normalization The normalization method to use for feature data.
#'        Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param filter_group A boolean indicating whether to filter the feature data by a specific group list (default: FALSE)
#' @param group_list A list of groups to filter the feature data by, if filter_group is TRUE (default: NULL)
#' @param filter_feature A boolean indicating whether to filter the feature data by a specific list (default: FALSE)
#' @param feature_list A list of feature names to filter the feature data by, if filter_feature is TRUE (default: NULL)
#' @export
#' @return A data frame containing the specialization index for each group in the metadata, with columns for group and specialization index.
#' @examplesIf FALSE
#' specialization_index <- GetSpecializationIndex(mmo,
#'                                                normalization = 'None',
#'                                                filter_group = FALSE)
#' specialization_index <- GetSpecializationIndex(mmo,
#'                                                normalization = 'Z',
#'                                                filter_group = TRUE,
#'                                                group_list = c('Control', 'Treatment1'),
#'                                                filter_feature = TRUE)
GetSpecializationIndex <- function(mmo, normalization = 'None', filter_group = FALSE, group_list = NULL, filter_feature = FALSE, feature_list = NULL){
  metadata <- mmo$metadata
  feature <- GetNormFeature(mmo, normalization)

  # All feature or filtered feature
  if (filter_feature == TRUE){
    feature <- feature |> filter(feature %in% feature_list)
  }
  if (filter_group == TRUE){
    samples <- c()
    for (group in group_list){
      samples <- append(samples, metadata |> filter(.data$group == !!group) |> pull(.data$sample))
    }
    feature <- feature |> dplyr::select(.data$id, .data$feature, all_of(samples))
  }

  # Get frequency matrix
  Pij <- feature[, -(1:2)]
  rownames(Pij) <- feature$feature
  Pij <- t(Pij)
  Pij <- Pij / rowSums(Pij)
  Pij[is.na(Pij)] <- 0

  # Get shannon diversity index
  # Pij.diversity <- Pij * log(Pij, base = 2)
  # Pij.diversity[is.na(Pij.diversity)] <- 0
  # Pij.diversity <- -rowSums(Pij.diversity)

  # Get specialization index
  Pi <- colSums(Pij)/nrow(Pij) # average frequency of each metabolite

  Si <- t((t(Pij)/Pi) * log((t(Pij)/Pi), base = 2)) # specialized degree
  Si[is.na(Si)] = 0
  Si <- colSums(Si)/ncol(Pij) # for each feature get average specialization index
  Pij.specialization <- colSums(t(Pij)*Si) # for each sample get specialization index
  # Retrieve group for each sample from metadata
  groups <- sapply(colnames(feature)[-c(1,2)], function(sample) {
    metadata$group[metadata$sample == sample]
  })
  output <- data.frame(group = groups, specialization = Pij.specialization)
}

#' GetBetaDiversity
#'
#' This function calculates the beta diversity for a given mmo object, method (Generalized Unifrac, bray, jaccard, or CSCS), normalization method, distance metric, and optional feature filtering.
#' Then it returns a distance matrix of beta diversity values.
#' The Generalized UniFrac and CSCS method requires a distance matrix of feature dissimilarity, which is calculated using the specified distance metric.
#' Bray-Curtis and Jaccard methods are calculated using the vegan package, not considering feature dissimilarity.
#'
#' @param mmo The mmo object containing feature data and metadata
#' @param method The method of beta diversity calculation. Options are 'Gen.Uni' for Generalized UniFrac, 'bray' for Bray-Curtis, 'jaccard' for Jaccard, or 'CSCS' for Compound Similarity and Chemical structural and compositional similarity (default: 'Gen.Uni')
#' @param normalization The normalization method to use for feature data. Options are 'None', 'Log', 'Meancentered', or 'Z' (default: 'None')
#' @param distance The distance metric to use for calculating dissimilarity. Options are 'dreams', 'm2ds', or 'cosine' (default: 'dreams')
#' @param filter_feature A boolean indicating whether to filter the feature data by a specific list (default: FALSE)
#' @param feature_list A list of feature names to filter the feature data by, if filter_feature is TRUE (default: NULL)
#' @param filter_group A boolean indicating whether to filter the feature data by a specific group list (default: FALSE)
#' @param group_list A list of groups to filter the feature data by, if filter_group is TRUE (default: NULL)
#' @return A distance matrix of beta diversity values between samples.
#' @export
#' @examplesIf FALSE
#' beta_diversity <- GetBetaDiversity(mmo, method = 'Gen.Uni',
#'  normalization = 'None', distance = 'dreams', filter_feature = FALSE)
#' beta_diversity <- GetBetaDiversity(mmo, method = 'bray',
#'  normalization = 'Z', filter_feature = TRUE, feature_list = Glucosinolates,
#'  filter_group = TRUE, group_list = c('Control', 'Treatment1'))
GetBetaDiversity <- function(mmo, method = 'Gen.Uni', normalization = 'None', distance = 'dreams', filter_feature = FALSE, feature_list = NULL, filter_group = FALSE, group_list = NULL){
  # Get compound distance and build tree for UniFrac
  scaled_dissimilarity <- GetDistanceMat(mmo, distance = distance) / max(GetDistanceMat(mmo, distance = distance))
  if (filter_feature == TRUE) {
    id_list <- FeatureToID(mmo, feature_list)
    scaled_dissimilarity <- scaled_dissimilarity[id_list, id_list]
  }
  compound_tree <- ape::as.phylo(hclust(as.dist(scaled_dissimilarity), method = "average"))

  # Get feature matrix of relative proportion
  metadata <- mmo$metadata
  feature <- GetNormFeature(mmo, normalization)
  if (filter_group == TRUE){
    samples <- c()
    for (group in group_list){
      samples <- append(samples, metadata |> filter(.data$group == !!group) |> pull(sample))
    }
    feature <- feature |> dplyr::select(.data$id, .data$feature, all_of(samples))
  }
  feature <- feature |> filter(.data$id %in% colnames(scaled_dissimilarity))
  relative_proportions <- apply(feature[, -(1:2)], 2, function(x) x / sum(x))
  rownames(relative_proportions) <- feature$id
  relative_proportions <- relative_proportions[rownames(scaled_dissimilarity), ] #reorder
  relative_proportions <- t(relative_proportions)
  # Calculate Generalized UniFrac
  if (method == 'Gen.Uni') {
    guni <- GUniFrac::GUniFrac(relative_proportions, compound_tree, alpha = c(0, 0.5, 1), verbose = TRUE)
    beta_div <- guni$unifracs
  } else if (method == 'bray') {
    beta_div <- as.matrix(vegan::vegdist(relative_proportions, method = 'bray'))
  } else if (method == 'jaccard') {
    beta_div <- as.matrix(vegan::vegdist(relative_proportions, method = 'jaccard'))
  } else if (method == 'CSCS') {
    CSS <- 1-GetDistanceMat(mmo, distance = distance)
    diag(CSS)
    q.feature <- GetNormFeature(mmo, normalization = normalization) |> filter(.data$id %in% colnames(CSS))
    relative_proportions <- apply(q.feature[, -(1:2)], 2, function(x) x / sum(x))
    CSCS_all <- t(relative_proportions) %*% CSS %*% relative_proportions

    sample_names <- colnames(relative_proportions)
    n_samples <- length(sample_names)
    CSCS_matrix <- matrix(NA, nrow = n_samples, ncol = n_samples)
    rownames(CSCS_matrix) <- sample_names
    colnames(CSCS_matrix) <- sample_names
    for (i in 1:n_samples) {
      for (j in 1:n_samples) {
        CSCS_matrix[i,j] <- CSCS_all[i, j] / max(CSCS_all[i, i], CSCS_all[j, j])
      }
    }
    beta_div <- 1-CSCS_matrix
  } else {
    stop("Invalid method. Please use 'Gen.Uni', 'bray' or 'jaccard'")
  }


  return(beta_div)
}


#' NMDSplot
#'
#' This function generates a Non-metric Multidimensional Scaling (NMDS) plot based on the provided beta diversity distance matrix.
#' It also performs PERMANOVA analysis to assess the significance of group differences and saves the results to CSV files.
#' @param mmo The mmo object containing metadata
#' @param betadiv The beta diversity distance matrix, output of GetBetaDiversity()
#' @param outdir The outdir for the output files
#' @param width The width of the output NMDS plot (default: 6)
#' @param height The height of the output NMDS plot (default: 6)
#' @param color A vector of colors for the groups in the plot
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @return A list containing the NMDS plot, the NMDS coordinates, and the PERMANOVA results
#' @export
#' @examplesIf FALSE
#' beta_diversity <- GetBetaDiversity(mmo, method = 'Gen.Uni',
#'  normalization = 'None', distance = 'dreams', filter_feature = FALSE)
#' # Use method = 'bray' or 'jaccard' if you want to use just feature abundance
#' # without considering feature spectral dissimilarity
#' NMDSplot(mmo, betadiv = beta_diversity, outdir = 'output/NMDS', width = 6, height = 6)
NMDSplot <- function(mmo, betadiv, outdir, width = 6, height = 6, color, save_output = TRUE){
  .require_pkg("vegan")
  .require_pkg("ggrepel")
  metadata <- mmo$metadata
  nmds <- vegan::metaMDS(betadiv, k = 2, try = 50, trymax = 100)

  # Extract NMDS coordinates
  nmds_coords <- as.data.frame(vegan::scores(nmds, display = "sites"))
  groups <- c()
  for (row in rownames(nmds_coords)) {
    groups <- append(groups, metadata[metadata$sample == row, ]$group)
  }
  nmds_coords$group <- groups

  # Plot NMDS
  plot <- ggplot(nmds_coords, aes(x = .data$NMDS1, y = .data$NMDS2, color = .data$group)) +
    geom_point(size = 3) +
    #geom_text_repel(aes(label = group), size = 3) +
    theme_classic() +
    stat_ellipse(level = 0.90) +
    labs(x = "NMDS1", y = "NMDS2") +
    scale_color_manual(values = color) +
    theme(legend.position = "right")
  plot
  permanova <- permanova_stat(betadiv, mmo$metadata, mode = 'distance')
  if (save_output){
    ggsave(paste0(outdir, '_NMDS.pdf'), height = height, width = width)
    readr::write_csv(permanova$permanova_res, paste0(outdir, '_permanova_results.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_raw), paste0(outdir, '_pairwise_permanova_results.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_p_matrix), paste0(outdir, '_pairwise_permanova_pvalue_matrix.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_F_matrix), paste0(outdir, '_pairwise_permanova_F_matrix.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_R2_matrix), paste0(outdir, '_pairwise_permanova_R2_matrix.csv'))
  }
  return(list(plot = plot, df = nmds_coords, permanova = permanova))
}

#' PCoAplot
#'
#' This function generates a Principal Coordinates Analysis (PCoA) plot based on the provided beta diversity distance matrix.
#' It also performs PERMANOVA analysis to assess the significance of group differences and saves the
#' results to CSV files.
#' @param mmo The mmo object containing metadata
#' @param betadiv The beta diversity distance matrix, output of GetBetaDiversity
#' @param outdir The prefix for the output files
#' @param width The width of the output PCoA plot (default: 6
#' @param height The height of the output PCoA plot (default: 6)
#' @param color A vector of colors for the points in the plot
#' @param save_output A logical value indicating whether to save the output plot (default: TRUE)
#' @return A list containing the PCoA plot, the PCoA coordinates, and the PERMANOVA results
#' @export
#' @examplesIf FALSE
#' beta_diversity <- GetBetaDiversity(mmo, method = 'Gen.Uni',
#'  normalization = 'None', distance = 'dreams', filter_feature = FALSE)
#' PCoAplot(mmo, betadiv = beta_diversity, outdir = 'output/PCoA', width = 6, height = 6)
PCoAplot <- function(mmo, betadiv, outdir, width = 6, height = 6, color, save_output = TRUE){
  .require_pkg('ape')
  metadata <- mmo$metadata
  pcoa_res <- ape::pcoa(betadiv)
  pcoa_coords <- as.data.frame(pcoa_res$vectors[, 1:2])
  colnames(pcoa_coords) <- c("PCoA1", "PCoA2")
  pcoa_coords$group <- metadata$group[match(rownames(pcoa_coords), metadata$sample)]

  plot <- ggplot(pcoa_coords, aes(x = .data$PCoA1, y = .data$PCoA2, color = .data$group)) +
    geom_point(size = 3) +
    stat_ellipse(level = 0.90) +
    theme_classic() +
    labs(x = "PCoA1", y = "PCoA2") +
    scale_color_manual(values = color) +
    theme(legend.position = "right")
  plot
  permanova <- permanova_stat(betadiv, mmo$metadata, mode = 'distance')
  if (save_output){
    ggsave(paste0(outdir, '_PCoA.pdf'), height = height, width = width)
    readr::write_csv(permanova$permanova_res, paste0(outdir, '_permanova_results.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_raw), paste0(outdir, '_pairwise_permanova_results.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_p_matrix), paste0(outdir, '_pairwise_permanova_pvalue_matrix.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_F_matrix), paste0(outdir, '_pairwise_permanova_F_matrix.csv'))
    readr::write_csv(as.data.frame(permanova$pairwise_R2_matrix), paste0(outdir, '_pairwise_permanova_R2_matrix.csv'))
  }
  return(list(plot = plot, df = pcoa_coords, permanova = permanova))
}

#' CalculateGroupBetaDistance
#'
#' This function calculates the beta diversity distance between a reference group and other groups in the metadata.
#'
#' @param mmo The mmo object containing feature data and metadata
#' @param beta_div The beta diversity distance matrix, output of GetBetaDiversity()
#' @param reference_group The name of the reference group to compare against
#' @param groups A vector of group names from the metadata to calculate distances for
#' @return A data frame containing the group names, sample names, and their corresponding beta diversity distances from the reference group.
#' @export
#' @examplesIf FALSE
#' beta_diversity <- GetBetaDiversity(mmo, method = 'Gen.Uni',
#'  normalization = 'None', distance = 'dreams', filter_feature = FALSE)
#' group_distances <- CalculateGroupBetaDistance(mmo, beta_div = beta_diversity,
#'  reference_group = 'Control', groups = c('Control', 'Treatment1', 'Treatment2'))
CalculateGroupBetaDistance <- function(mmo, beta_div, reference_group, groups) {
  metadata <- mmo$metadata
  distances <- data.frame(group = character(), distance = numeric())

  for (group in groups) {
      group_samples <- metadata |> filter(group == !!group) |> pull(sample)
      reference_samples <- metadata |> filter(group == !!reference_group) |> pull(sample)

      for (sample in group_samples) {
        for (ref_sample in reference_samples) {
          distance <- beta_div[sample, ref_sample]
          distances <- rbind(distances, data.frame(group = group,sample = sample, distance = distance))
        }

    }
  }

  return(distances)
}

#' Save entire mmo object to a file (RDS)
#'
#' @param mmo The mmo object (list) to save
#' @param file File path to write (default: "mmo.rds")
#' @param compress Compression type passed to saveRDS ("gzip", "bzip2", "xz", or logical) (default: "xz")
#' @param include_session Logical; if TRUE attach sessionInfo() as an attribute to the saved object (default: TRUE)
#' @return Invisibly returns the file path
#' @export
SaveMMO <- function(mmo, file = "mmo.rds", compress = "xz", include_session = TRUE) {
  if (missing(mmo) || !is.list(mmo)) stop("mmo must be a list-like object")
  if (include_session) {
    attr(mmo, "saved_session_info") <- utils::sessionInfo()
  }
  saveRDS(mmo, file = file, compress = compress)
  message("Saved mmo to: ", file)
  invisible(file)
}


#' Load an mmo object previously saved with SaveMMO
#'
#' This function returns the loaded mmo object (visible return). By default it prints basic
#' information about the R version and recorded packages that were present when the object
#' was saved.
#'
#' @param file Path to an RDS file created with SaveMMO
#' @param check_session Logical; if TRUE and save-time session info is present, print a short summary (default: TRUE)
#' @param verbose Logical; print messages about saved session info when available (default: TRUE)
#' @return The loaded mmo object (list)
#' @export
LoadMMO <- function(file, check_session = TRUE, verbose = TRUE) {
  if (!file.exists(file)) stop("File not found: ", file)
  mmo <- readRDS(file)
  if (check_session && !is.null(attr(mmo, "saved_session_info"))) {
    saved_si <- attr(mmo, "saved_session_info")
    if (verbose) {
      message("mmo was saved with R: ", saved_si$R.version$version.string)
      pkgs <- names(saved_si$otherPkgs)
      if (length(pkgs) > 0) message("Top packages at save-time: ", paste(head(pkgs, 20), collapse = ", "))
    }
  }
  return(mmo)
}


#' Print method for mmo objects
#' Provides a clean, human-readable overview of an `mmo` list object instead of
#' dumping the entire list when the object is printed in the console.
#' @param x An `mmo` object (a list with components such as `feature_data`,
#'   `metadata`, `pairwise`, etc.)
#' @param ... Additional arguments passed to other print methods (unused).
#' @return Invisibly returns `x` unchanged.
#' @export
print.mmo <- function(x, ...) {
  cat("MMO object\n")
  # Features
  if (!is.null(x$feature_data)) {
    cat("  Feature number: ",
        nrow(x$feature_data), "\n", sep = "")
  }

  # Samples & groups
  if (!is.null(x$metadata)) {
    n_samples <- nrow(x$metadata)
    n_groups  <- length(unique(x$metadata$group))
    cat("  ", n_samples, " samples in ", n_groups, " groups\n", sep = "")
  }

  # Components present
  cat("  MMO object contains: ",
      paste(names(x), collapse = ", "),
      "\n", sep = "")

  invisible(x)
}

#' HCplot
#'
#' Hierarchical clustering of samples from a precomputed beta-diversity matrix
#' and plotting as a phylogram with tip labels colored by species (or any grouping column).
#'
#' This function is intended for visualization (no cluster significance is implied).
#'
#' @param mmo The mmo object containing metadata in mmo$metadata
#' @param betadiv The beta diversity distance matrix, output of GetBetaDiversity()
#' @param outdir Output prefix for files (e.g., "output/HC"). If save_output=TRUE a PDF is saved.
#' @param group_col Metadata column name used to color tips (default: "Species_binomial")
#' @param sample_col Metadata column name containing sample IDs (default: "sample")
#' @param hclust_method hclust linkage method (default: "average"; alternatives: "complete","ward.D2")
#' @param palette Qualitative palette name for colorspace::qualitative_hcl (default: "Dark 3")
#' @param cex Tip label size (default: 0.6)
#' @param width PDF width (default: 10)
#' @param height PDF height (default: 7)
#' @param save_output Whether to save the plot to PDF (default: TRUE)
#' @return A list containing: hc (hclust), phy (phylo), tip_df (mapping), colors (named palette)
#' @export
#' @examplesIf FALSE
#' bet <- GetBetaDiversity(mmo, method='bray',
#'         normalization='Log', distance='dreams',
#'          filter_feature=FALSE)
#' HCplot(mmo,
#'        betadiv = bet,
#'        outdir = "output/HC_dreams_bray")
HCplot <- function(
    mmo,
    betadiv,
    outdir,
    group_col = "Species_binomial",
    sample_col = "sample",
    hclust_method = "average",
    palette = "Dark 3",
    cex = 0.6,
    width = 10,
    height = 7,
    save_output = TRUE
){
  .require_pkg("ape")
  .require_pkg("colorspace")

  metadata <- mmo$metadata
  if (is.null(metadata) || !is.data.frame(metadata))
    stop("mmo$metadata must be a data.frame.")

  if (!sample_col %in% names(metadata))
    stop("metadata is missing sample_col = '", sample_col, "'")
  if (!group_col %in% names(metadata))
    stop("metadata is missing group_col = '", group_col, "'")

  # Ensure betadiv has labels
  if (is.null(rownames(betadiv)) || is.null(colnames(betadiv)))
    stop("betadiv must have rownames and colnames equal to sample IDs.")

  # Convert to dist and hclust
  d <- as.dist(betadiv)
  hc <- stats::hclust(d, method = hclust_method)

  # Convert to phylo
  tr <- ape::as.phylo(hc)

  tip_ids <- tr$tip.label
  md_ids  <- as.character(metadata[[sample_col]])
  grp_map <- metadata[[group_col]]
  grp_vec <- grp_map[match(tip_ids, md_ids)]

  if (anyNA(grp_vec)) {
    bad <- tip_ids[is.na(grp_vec)]
    stop(
      "Group labels missing for some tree tips (ID mismatch between betadiv labels and metadata$",
      sample_col, "). Example missing IDs:\n",
      paste(head(bad, 25), collapse = "\n")
    )
  }
  grp_vec <- as.character(grp_vec)

  # Build palette
  grp_levels <- sort(unique(grp_vec))
  grp_cols <- setNames(colorspace::qualitative_hcl(length(grp_levels), palette = palette), grp_levels)
  tip_cols <- unname(grp_cols[grp_vec])

  tip_df <- data.frame(
    tip = tip_ids,
    group = grp_vec,
    color = tip_cols,
    stringsAsFactors = FALSE
  )

  # Plot
  main_title <- paste0("Hierarchical clustering (", hclust_method, ")")

  if (save_output) grDevices::pdf(paste0(outdir, "_HC.pdf"), width = width, height = height)
  op <- graphics::par(no.readonly = TRUE)
  on.exit({
    graphics::par(op)
    if (save_output) grDevices::dev.off()
  }, add = TRUE)

  graphics::par(mar = c(2, 2, 2, 12))  # wide right margin for labels
  plot(tr, type = "phylogram", cex = cex, tip.color = tip_cols, main = main_title)

  graphics::legend(
    "topleft",
    legend = grp_levels,
    col = unname(grp_cols[grp_levels]),
    pch = 15,
    cex = 0.6,
    bty = "n"
  )

  return(list(hc = hc, phy = tr, tip_df = tip_df, colors = grp_cols))
}


```


## R/ecomet-package.R
```r
#' Internal imports for ecomet
#' @keywords internal
#' @name ecomet-internal-imports
#'
#' @importFrom stats TukeyHSD aov as.dist as.formula binom.test coef cor.test fisher.test
#' @importFrom stats hclust lm p.adjust reorder sd t.test setNames dist prcomp
#' @importFrom utils head read.csv write.csv tail
#'
#' @importFrom dplyr across all_of arrange left_join mutate filter pull select
#' @importFrom dplyr group_by summarise ungroup n
#' @importFrom rlang .data sym
#' 
#' @importFrom RColorBrewer brewer.pal
#'
#' @importFrom ggplot2 ggplot aes geom_point geom_bar geom_errorbar position_dodge
#' @importFrom ggplot2 theme_classic labs theme element_text ggsave ggtitle guides
#' @importFrom ggplot2 guide_legend scale_color_manual stat_ellipse geom_segment
#' @importFrom ggplot2 geom_smooth geom_text xlab ylab facet_grid
#' @importFrom ggplot2 scale_color_gradient scale_color_gradient2 scale_size_area
#' @importFrom ggplot2 xlim geom_vline geom_hline theme_minimal annotate
#' @importFrom ggplot2 scale_fill_manual geom_boxplot
#' @importFrom ggplot2 coord_flip scale_fill_gradient position_stack
#' @importFrom ape pcoa
#' @importFrom vegan metaMDS scores
#'
NULL

```


## R/utils-deps.R
```r
#' Internal: assert an optional package is installed
#' @keywords internal
#' @noRd
.require_pkg <- function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    stop(pkg, " is required for this function. Install it with install.packages('", pkg, "').", call. = FALSE)
  }
}

```